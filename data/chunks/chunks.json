[
  {
    "chunk_id": 0,
    "text": "Data types are a way to limit the kind of data that can be stored in a table. For many applications, however, the constraint they provide is too coarse. For example, a column containing a product price should probably only accept positive values. But there is no standard data type that accepts only positive numbers. Another issue is that you might want to constrain column data with respect to other columns or rows. For example, in a table containing product information, there should be only one row for each product number.\nTo that end, SQL allows you to define constraints on columns and tables. Constraints give you as much control over the data in your tables as you wish. If a user attempts to store data in a column that would violate a constraint, an error is raised. This applies even if the value came from the default value definition.",
    "metadata": {
      "doc_name": "ddl-constraints",
      "section_title": "5.4. Constraints#",
      "url": "https://www.postgresql.org/docs/16/ddl-constraints.html"
    }
  },
  {
    "chunk_id": 1,
    "text": "A check constraint is the most generic constraint type. It allows you to specify that the value in a certain column must satisfy a Boolean (truth-value) expression. For instance, to require positive product prices, you could use:\n\n\nCODE:\n\nCREATE TABLE products (\n    product_no integer,\n    name text,\n    price numeric CHECK (price > 0)\n);\n\nAs you see, the constraint definition comes after the data type, just like default value definitions. Default values and constraints can be listed in any order. A check constraint consists of the key wordCHECKfollowed by an expression in parentheses. The check constraint expression should involve the column thus constrained, otherwise the constraint would not make too much sense.\nYou can also give the constraint a separate name. This clarifies error messages and allows you to refer to the constraint when you need to change it. The syntax is:\n\n\nCODE:\n\nCREATE TABLE products (\n    product_no integer,\n    name text,\n    price numeric CONSTRAINT positive_price CHECK (price > 0)\n);\n\nSo, to specify a named constraint, use the key wordCONSTRAINTfollowed by an identifier followed by the constraint definition. (If you don't specify a constraint name in this way, the system chooses a name for you.)\nA check constraint can also refer to several columns. Say you store a regular price and a discounted price, and you want to ensure that the discounted price is lower than the regular price:\n\n\nCODE:\n\nCREATE TABLE products (\n    product_no integer,\n    name text,\n    price numeric CHECK (price > 0),\n    discounted_price numeric CHECK (discounted_price > 0),\n    CHECK (price > discounted_price)\n);\n\nThe first two constraints should look familiar. The third one uses a new syntax. It is not attached to a particular column, instead it appears as a separate item in the comma-separated column list. Column definitions and these constraint definitions can be listed in mixed order.\nWe say that the first two constraints are column constraints, whereas the third one is a table constraint because it is written separately from any one column definition. Column constraints can also be written as table constraints, while the reverse is not necessarily possible, since a column constraint is supposed to refer to only the column it is attached to. (PostgreSQLdoesn't enforce that rule, but you should follow it if you want your table definitions to work with other database systems.) The above example could also be written as:\n\n\nCODE:\n\nCREATE TABLE products (\n    product_no integer,\n    name text,",
    "metadata": {
      "doc_name": "ddl-constraints",
      "section_title": "5.4.1. Check Constraints#",
      "url": "https://www.postgresql.org/docs/16/ddl-constraints.html"
    }
  },
  {
    "chunk_id": 2,
    "text": "a table constraint because it is written separately from any one column definition. Column constraints can also be written as table constraints, while the reverse is not necessarily possible, since a column constraint is supposed to refer to only the column it is attached to. (PostgreSQLdoesn't enforce that rule, but you should follow it if you want your table definitions to work with other database systems.) The above example could also be written as:\n\n\nCODE:\n\nCREATE TABLE products (\n    product_no integer,\n    name text,\n    price numeric,\n    CHECK (price > 0),\n    discounted_price numeric,\n    CHECK (discounted_price > 0),\n    CHECK (price > discounted_price)\n);\n\nor even:\n\n\nCODE:\n\nCREATE TABLE products (\n    product_no integer,\n    name text,\n    price numeric CHECK (price > 0),\n    discounted_price numeric,\n    CHECK (discounted_price > 0 AND price > discounted_price)\n);\n\nIt's a matter of taste.\nNames can be assigned to table constraints in the same way as column constraints:\n\n\nCODE:\n\nCREATE TABLE products (\n    product_no integer,\n    name text,\n    price numeric,\n    CHECK (price > 0),\n    discounted_price numeric,\n    CHECK (discounted_price > 0),\n    CONSTRAINT valid_discount CHECK (price > discounted_price)\n);\n\nIt should be noted that a check constraint is satisfied if the check expression evaluates to true or the null value. Since most expressions will evaluate to the null value if any operand is null, they will not prevent null values in the constrained columns. To ensure that a column does not contain null values, the not-null constraint described in the next section can be used.",
    "metadata": {
      "doc_name": "ddl-constraints",
      "section_title": "5.4.1. Check Constraints#",
      "url": "https://www.postgresql.org/docs/16/ddl-constraints.html"
    }
  },
  {
    "chunk_id": 3,
    "text": "PostgreSQLdoes not supportCHECKconstraints that reference table data other than the new or updated row being checked. While aCHECKconstraint that violates this rule may appear to work in simple tests, it cannot guarantee that the database will not reach a state in which the constraint condition is false (due to subsequent changes of the other row(s) involved). This would cause a database dump and restore to fail. The restore could fail even when the complete database state is consistent with the constraint, due to rows not being loaded in an order that will satisfy the constraint. If possible, useUNIQUE,EXCLUDE, orFOREIGN KEYconstraints to express cross-row and cross-table restrictions.\nIf what you desire is a one-time check against other rows at row insertion, rather than a continuously-maintained consistency guarantee, a customtriggercan be used to implement that. (This approach avoids the dump/restore problem becausepg_dumpdoes not reinstall triggers until after restoring data, so that the check will not be enforced during a dump/restore.)",
    "metadata": {
      "doc_name": "ddl-constraints",
      "section_title": "Note",
      "url": "https://www.postgresql.org/docs/16/ddl-constraints.html"
    }
  },
  {
    "chunk_id": 4,
    "text": "PostgreSQLassumes thatCHECKconstraints' conditions are immutable, that is, they will always give the same result for the same input row. This assumption is what justifies examiningCHECKconstraints only when rows are inserted or updated, and not at other times. (The warning above about not referencing other table data is really a special case of this restriction.)\nAn example of a common way to break this assumption is to reference a user-defined function in aCHECKexpression, and then change the behavior of that function.PostgreSQLdoes not disallow that, but it will not notice if there are rows in the table that now violate theCHECKconstraint. That would cause a subsequent database dump and restore to fail. The recommended way to handle such a change is to drop the constraint (usingALTER TABLE), adjust the function definition, and re-add the constraint, thereby rechecking it against all table rows.",
    "metadata": {
      "doc_name": "ddl-constraints",
      "section_title": "Note",
      "url": "https://www.postgresql.org/docs/16/ddl-constraints.html"
    }
  },
  {
    "chunk_id": 5,
    "text": "A not-null constraint simply specifies that a column must not assume the null value. A syntax example:\n\n\nCODE:\n\nCREATE TABLE products (\n    product_no integer NOT NULL,\n    name text NOT NULL,\n    price numeric\n);\n\nA not-null constraint is always written as a column constraint. A not-null constraint is functionally equivalent to creating a check constraintCHECK (column_nameIS NOT NULL), but inPostgreSQLcreating an explicit not-null constraint is more efficient. The drawback is that you cannot give explicit names to not-null constraints created this way.\nOf course, a column can have more than one constraint. Just write the constraints one after another:\n\n\nCODE:\n\nCREATE TABLE products (\n    product_no integer NOT NULL,\n    name text NOT NULL,\n    price numeric NOT NULL CHECK (price > 0)\n);\n\nThe order doesn't matter. It does not necessarily determine in which order the constraints are checked.\nTheNOT NULLconstraint has an inverse: theNULLconstraint. This does not mean that the column must be null, which would surely be useless. Instead, this simply selects the default behavior that the column might be null. TheNULLconstraint is not present in the SQL standard and should not be used in portable applications. (It was only added toPostgreSQLto be compatible with some other database systems.) Some users, however, like it because it makes it easy to toggle the constraint in a script file. For example, you could start with:\n\n\nCODE:\n\nCREATE TABLE products (\n    product_no integer NULL,\n    name text NULL,\n    price numeric NULL\n);\n\nand then insert theNOTkey word where desired.",
    "metadata": {
      "doc_name": "ddl-constraints",
      "section_title": "5.4.2. Not-Null Constraints#",
      "url": "https://www.postgresql.org/docs/16/ddl-constraints.html"
    }
  },
  {
    "chunk_id": 6,
    "text": "In most database designs the majority of columns should be marked not null.",
    "metadata": {
      "doc_name": "ddl-constraints",
      "section_title": "Tip",
      "url": "https://www.postgresql.org/docs/16/ddl-constraints.html"
    }
  },
  {
    "chunk_id": 7,
    "text": "Unique constraints ensure that the data contained in a column, or a group of columns, is unique among all the rows in the table. The syntax is:\n\n\nCODE:\n\nCREATE TABLE products (\n    product_no integer UNIQUE,\n    name text,\n    price numeric\n);\n\nwhen written as a column constraint, and:\n\n\nCODE:\n\nCREATE TABLE products (\n    product_no integer,\n    name text,\n    price numeric,\n    UNIQUE (product_no)\n);\n\nwhen written as a table constraint.\nTo define a unique constraint for a group of columns, write it as a table constraint with the column names separated by commas:\n\n\nCODE:\n\nCREATE TABLE example (\n    a integer,\n    b integer,\n    c integer,\n    UNIQUE (a, c)\n);\n\nThis specifies that the combination of values in the indicated columns is unique across the whole table, though any one of the columns need not be (and ordinarily isn't) unique.\nYou can assign your own name for a unique constraint, in the usual way:\n\n\nCODE:\n\nCREATE TABLE products (\n    product_no integer CONSTRAINT must_be_different UNIQUE,\n    name text,\n    price numeric\n);\n\nAdding a unique constraint will automatically create a unique B-tree index on the column or group of columns listed in the constraint. A uniqueness restriction covering only some rows cannot be written as a unique constraint, but it is possible to enforce such a restriction by creating a uniquepartial index.\nIn general, a unique constraint is violated if there is more than one row in the table where the values of all of the columns included in the constraint are equal. By default, two null values are not considered equal in this comparison. That means even in the presence of a unique constraint it is possible to store duplicate rows that contain a null value in at least one of the constrained columns. This behavior can be changed by adding the clauseNULLS NOT DISTINCT, like\n\n\nCODE:\n\nCREATE TABLE products (\n    product_no integer UNIQUE NULLS NOT DISTINCT,\n    name text,\n    price numeric\n);\n\nor\n\n\nCODE:\n\nCREATE TABLE products (\n    product_no integer,\n    name text,\n    price numeric,\n    UNIQUE NULLS NOT DISTINCT (product_no)\n);\n\nThe default behavior can be specified explicitly usingNULLS DISTINCT. The default null treatment in unique constraints is implementation-defined according to the SQL standard, and other implementations have a different behavior. So be careful when developing applications that are intended to be portable.",
    "metadata": {
      "doc_name": "ddl-constraints",
      "section_title": "5.4.3. Unique Constraints#",
      "url": "https://www.postgresql.org/docs/16/ddl-constraints.html"
    }
  },
  {
    "chunk_id": 8,
    "text": "A primary key constraint indicates that a column, or group of columns, can be used as a unique identifier for rows in the table. This requires that the values be both unique and not null. So, the following two table definitions accept the same data:\n\n\nCODE:\n\nCREATE TABLE products (\n    product_no integer UNIQUE NOT NULL,\n    name text,\n    price numeric\n);\n\n\n\nCODE:\n\nCREATE TABLE products (\n    product_no integer PRIMARY KEY,\n    name text,\n    price numeric\n);\n\nPrimary keys can span more than one column; the syntax is similar to unique constraints:\n\n\nCODE:\n\nCREATE TABLE example (\n    a integer,\n    b integer,\n    c integer,\n    PRIMARY KEY (a, c)\n);\n\nAdding a primary key will automatically create a unique B-tree index on the column or group of columns listed in the primary key, and will force the column(s) to be markedNOT NULL.\nA table can have at most one primary key. (There can be any number of unique and not-null constraints, which are functionally almost the same thing, but only one can be identified as the primary key.) Relational database theory dictates that every table must have a primary key. This rule is not enforced byPostgreSQL, but it is usually best to follow it.\nPrimary keys are useful both for documentation purposes and for client applications. For example, a GUI application that allows modifying row values probably needs to know the primary key of a table to be able to identify rows uniquely. There are also various ways in which the database system makes use of a primary key if one has been declared; for example, the primary key defines the default target column(s) for foreign keys referencing its table.",
    "metadata": {
      "doc_name": "ddl-constraints",
      "section_title": "5.4.4. Primary Keys#",
      "url": "https://www.postgresql.org/docs/16/ddl-constraints.html"
    }
  },
  {
    "chunk_id": 9,
    "text": "A foreign key constraint specifies that the values in a column (or a group of columns) must match the values appearing in some row of another table. We say this maintains thereferential integritybetween two related tables.\nSay you have the product table that we have used several times already:\n\n\nCODE:\n\nCREATE TABLE products (\n    product_no integer PRIMARY KEY,\n    name text,\n    price numeric\n);\n\nLet's also assume you have a table storing orders of those products. We want to ensure that the orders table only contains orders of products that actually exist. So we define a foreign key constraint in the orders table that references the products table:\n\n\nCODE:\n\nCREATE TABLE orders (\n    order_id integer PRIMARY KEY,\n    product_no integer REFERENCES products (product_no),\n    quantity integer\n);\n\nNow it is impossible to create orders with non-NULLproduct_noentries that do not appear in the products table.\nWe say that in this situation the orders table is thereferencingtable and the products table is thereferencedtable. Similarly, there are referencing and referenced columns.\nYou can also shorten the above command to:\n\n\nCODE:\n\nCREATE TABLE orders (\n    order_id integer PRIMARY KEY,\n    product_no integer REFERENCES products,\n    quantity integer\n);\n\nbecause in absence of a column list the primary key of the referenced table is used as the referenced column(s).\nYou can assign your own name for a foreign key constraint, in the usual way.\nA foreign key can also constrain and reference a group of columns. As usual, it then needs to be written in table constraint form. Here is a contrived syntax example:\n\n\nCODE:\n\nCREATE TABLE t1 (\n  a integer PRIMARY KEY,\n  b integer,\n  c integer,\n  FOREIGN KEY (b, c) REFERENCES other_table (c1, c2)\n);\n\nOf course, the number and type of the constrained columns need to match the number and type of the referenced columns.\nSometimes it is useful for the“other table”of a foreign key constraint to be the same table; this is called aself-referentialforeign key. For example, if you want rows of a table to represent nodes of a tree structure, you could write\n\n\nCODE:\n\nCREATE TABLE tree (\n    node_id integer PRIMARY KEY,\n    parent_id integer REFERENCES tree,\n    name text,\n    ...\n);\n\nA top-level node would have NULLparent_id, while non-NULLparent_identries would be constrained to reference valid rows of the table.\nA table can have more than one foreign key",
    "metadata": {
      "doc_name": "ddl-constraints",
      "section_title": "5.4.5. Foreign Keys#",
      "url": "https://www.postgresql.org/docs/16/ddl-constraints.html"
    }
  },
  {
    "chunk_id": 10,
    "text": "same table; this is called aself-referentialforeign key. For example, if you want rows of a table to represent nodes of a tree structure, you could write\n\n\nCODE:\n\nCREATE TABLE tree (\n    node_id integer PRIMARY KEY,\n    parent_id integer REFERENCES tree,\n    name text,\n    ...\n);\n\nA top-level node would have NULLparent_id, while non-NULLparent_identries would be constrained to reference valid rows of the table.\nA table can have more than one foreign key constraint. This is used to implement many-to-many relationships between tables. Say you have tables about products and orders, but now you want to allow one order to contain possibly many products (which the structure above did not allow). You could use this table structure:\n\n\nCODE:\n\nCREATE TABLE products (\n    product_no integer PRIMARY KEY,\n    name text,\n    price numeric\n);\n\nCREATE TABLE orders (\n    order_id integer PRIMARY KEY,\n    shipping_address text,\n    ...\n);\n\nCREATE TABLE order_items (\n    product_no integer REFERENCES products,\n    order_id integer REFERENCES orders,\n    quantity integer,\n    PRIMARY KEY (product_no, order_id)\n);\n\nNotice that the primary key overlaps with the foreign keys in the last table.\nWe know that the foreign keys disallow creation of orders that do not relate to any products. But what if a product is removed after an order is created that references it? SQL allows you to handle that as well. Intuitively, we have a few options:\nDisallow deleting a referenced product\nDelete the orders as well\nSomething else?\nTo illustrate this, let's implement the following policy on the many-to-many relationship example above: when someone wants to remove a product that is still referenced by an order (viaorder_items), we disallow it. If someone removes an order, the order items are removed as well:\n\n\nCODE:\n\nCREATE TABLE products (\n    product_no integer PRIMARY KEY,\n    name text,\n    price numeric\n);\n\nCREATE TABLE orders (\n    order_id integer PRIMARY KEY,\n    shipping_address text,\n    ...\n);\n\nCREATE TABLE order_items (\n    product_no integer REFERENCES products ON DELETE RESTRICT,\n    order_id integer REFERENCES orders ON DELETE CASCADE,\n    quantity integer,\n    PRIMARY KEY (product_no, order_id)\n);\n\nRestricting and cascading deletes are the two most common options.RESTRICTprevents deletion of a referenced row.NO ACTIONmeans that if any referencing rows still exist when the constraint is checked, an error is raised; this is the default behavior if",
    "metadata": {
      "doc_name": "ddl-constraints",
      "section_title": "5.4.5. Foreign Keys#",
      "url": "https://www.postgresql.org/docs/16/ddl-constraints.html"
    }
  },
  {
    "chunk_id": 11,
    "text": ",\n    shipping_address text,\n    ...\n);\n\nCREATE TABLE order_items (\n    product_no integer REFERENCES products ON DELETE RESTRICT,\n    order_id integer REFERENCES orders ON DELETE CASCADE,\n    quantity integer,\n    PRIMARY KEY (product_no, order_id)\n);\n\nRestricting and cascading deletes are the two most common options.RESTRICTprevents deletion of a referenced row.NO ACTIONmeans that if any referencing rows still exist when the constraint is checked, an error is raised; this is the default behavior if you do not specify anything. (The essential difference between these two choices is thatNO ACTIONallows the check to be deferred until later in the transaction, whereasRESTRICTdoes not.)CASCADEspecifies that when a referenced row is deleted, row(s) referencing it should be automatically deleted as well. There are two other options:SET NULLandSET DEFAULT. These cause the referencing column(s) in the referencing row(s) to be set to nulls or their default values, respectively, when the referenced row is deleted. Note that these do not excuse you from observing any constraints. For example, if an action specifiesSET DEFAULTbut the default value would not satisfy the foreign key constraint, the operation will fail.\nThe appropriate choice ofON DELETEaction depends on what kinds of objects the related tables represent. When the referencing table represents something that is a component of what is represented by the referenced table and cannot exist independently, thenCASCADEcould be appropriate. If the two tables represent independent objects, thenRESTRICTorNO ACTIONis more appropriate; an application that actually wants to delete both objects would then have to be explicit about this and run two delete commands. In the above example, order items are part of an order, and it is convenient if they are deleted automatically if an order is deleted. But products and orders are different things, and so making a deletion of a product automatically cause the deletion of some order items could be considered problematic. The actionsSET NULLorSET DEFAULTcan be appropriate if a foreign-key relationship represents optional information. For example, if the products table contained a reference to a product manager, and the product manager entry gets deleted, then setting the product's product manager to null or a default might be useful.\nThe actionsSET NULLandSET DEFAULTcan take a column list to specify which columns to set. Normally, all columns of the foreign-key constraint are set; setting only a subset is useful in some special cases. Consider the following example:\n\n\nCODE:\n\nCREATE TABLE tenants (\n    tenant",
    "metadata": {
      "doc_name": "ddl-constraints",
      "section_title": "5.4.5. Foreign Keys#",
      "url": "https://www.postgresql.org/docs/16/ddl-constraints.html"
    }
  },
  {
    "chunk_id": 12,
    "text": "-key relationship represents optional information. For example, if the products table contained a reference to a product manager, and the product manager entry gets deleted, then setting the product's product manager to null or a default might be useful.\nThe actionsSET NULLandSET DEFAULTcan take a column list to specify which columns to set. Normally, all columns of the foreign-key constraint are set; setting only a subset is useful in some special cases. Consider the following example:\n\n\nCODE:\n\nCREATE TABLE tenants (\n    tenant_id integer PRIMARY KEY\n);\n\nCREATE TABLE users (\n    tenant_id integer REFERENCES tenants ON DELETE CASCADE,\n    user_id integer NOT NULL,\n    PRIMARY KEY (tenant_id, user_id)\n);\n\nCREATE TABLE posts (\n    tenant_id integer REFERENCES tenants ON DELETE CASCADE,\n    post_id integer NOT NULL,\n    author_id integer,\n    PRIMARY KEY (tenant_id, post_id),\n    FOREIGN KEY (tenant_id, author_id) REFERENCES users ON DELETE SET NULL (author_id)\n);\n\nWithout the specification of the column, the foreign key would also set the columntenant_idto null, but that column is still required as part of the primary key.\nAnalogous toON DELETEthere is alsoON UPDATEwhich is invoked when a referenced column is changed (updated). The possible actions are the same, except that column lists cannot be specified forSET NULLandSET DEFAULT. In this case,CASCADEmeans that the updated values of the referenced column(s) should be copied into the referencing row(s).\nNormally, a referencing row need not satisfy the foreign key constraint if any of its referencing columns are null. IfMATCH FULLis added to the foreign key declaration, a referencing row escapes satisfying the constraint only if all its referencing columns are null (so a mix of null and non-null values is guaranteed to fail aMATCH FULLconstraint). If you don't want referencing rows to be able to avoid satisfying the foreign key constraint, declare the referencing column(s) asNOT NULL.\nA foreign key must reference columns that either are a primary key or form a unique constraint, or are columns from a non-partial unique index. This means that the referenced columns always have an index to allow efficient lookups on whether a referencing row has a match. Since aDELETEof a row from the referenced table or anUPDATEof a referenced column will require a scan of the referencing table for rows matching the old value, it is often a good idea to index the referencing columns too. Because this is not always needed, and there are",
    "metadata": {
      "doc_name": "ddl-constraints",
      "section_title": "5.4.5. Foreign Keys#",
      "url": "https://www.postgresql.org/docs/16/ddl-constraints.html"
    }
  },
  {
    "chunk_id": 13,
    "text": "are a primary key or form a unique constraint, or are columns from a non-partial unique index. This means that the referenced columns always have an index to allow efficient lookups on whether a referencing row has a match. Since aDELETEof a row from the referenced table or anUPDATEof a referenced column will require a scan of the referencing table for rows matching the old value, it is often a good idea to index the referencing columns too. Because this is not always needed, and there are many choices available on how to index, the declaration of a foreign key constraint does not automatically create an index on the referencing columns.\nMore information about updating and deleting data is inChapter 6. Also see the description of foreign key constraint syntax in the reference documentation forCREATE TABLE.",
    "metadata": {
      "doc_name": "ddl-constraints",
      "section_title": "5.4.5. Foreign Keys#",
      "url": "https://www.postgresql.org/docs/16/ddl-constraints.html"
    }
  },
  {
    "chunk_id": 14,
    "text": "Exclusion constraints ensure that if any two rows are compared on the specified columns or expressions using the specified operators, at least one of these operator comparisons will return false or null. The syntax is:\n\n\nCODE:\n\nCREATE TABLE circles (\n    c circle,\n    EXCLUDE USING gist (c WITH &&)\n);\n\nSee alsoCREATE TABLE ... CONSTRAINT ... EXCLUDEfor details.\nAdding an exclusion constraint will automatically create an index of the type specified in the constraint declaration.",
    "metadata": {
      "doc_name": "ddl-constraints",
      "section_title": "5.4.6. Exclusion Constraints#",
      "url": "https://www.postgresql.org/docs/16/ddl-constraints.html"
    }
  },
  {
    "chunk_id": 0,
    "text": "Apartial indexis an index built over a subset of a table; the subset is defined by a conditional expression (called thepredicateof the partial index). The index contains entries only for those table rows that satisfy the predicate. Partial indexes are a specialized feature, but there are several situations in which they are useful.\nOne major reason for using a partial index is to avoid indexing common values. Since a query searching for a common value (one that accounts for more than a few percent of all the table rows) will not use the index anyway, there is no point in keeping those rows in the index at all. This reduces the size of the index, which will speed up those queries that do use the index. It will also speed up many table update operations because the index does not need to be updated in all cases.Example 11.1shows a possible application of this idea.\nExample 11.1. Setting up a Partial Index to Exclude Common Values\nSuppose you are storing web server access logs in a database. Most accesses originate from the IP address range of your organization but some are from elsewhere (say, employees on dial-up connections). If your searches by IP are primarily for outside accesses, you probably do not need to index the IP range that corresponds to your organization's subnet.\nAssume a table like this:\n\n\nCODE:\n\nCREATE TABLE access_log (\n    url varchar,\n    client_ip inet,\n    ...\n);\n\nTo create a partial index that suits our example, use a command such as this:\n\n\nCODE:\n\nCREATE INDEX access_log_client_ip_ix ON access_log (client_ip)\nWHERE NOT (client_ip > inet '192.168.100.0' AND\n           client_ip < inet '192.168.100.255');\n\nA typical query that can use this index would be:\n\n\nCODE:\n\nSELECT *\nFROM access_log\nWHERE url = '/index.html' AND client_ip = inet '212.78.10.32';\n\nHere the query's IP address is covered by the partial index. The following query cannot use the partial index, as it uses an IP address that is excluded from the index:\n\n\nCODE:\n\nSELECT *\nFROM access_log\nWHERE url = '/index.html' AND client_ip = inet '192.168.100.23';\n\nObserve that this kind of partial index requires that the common values be predetermined, so such partial indexes are best used for data distributions that do not change. Such indexes can be recreated occasionally to adjust for new data distributions",
    "metadata": {
      "doc_name": "indexes-partial",
      "section_title": "11.8. Partial Indexes#",
      "url": "https://www.postgresql.org/docs/16/indexes-partial.html"
    }
  },
  {
    "chunk_id": 1,
    "text": "covered by the partial index. The following query cannot use the partial index, as it uses an IP address that is excluded from the index:\n\n\nCODE:\n\nSELECT *\nFROM access_log\nWHERE url = '/index.html' AND client_ip = inet '192.168.100.23';\n\nObserve that this kind of partial index requires that the common values be predetermined, so such partial indexes are best used for data distributions that do not change. Such indexes can be recreated occasionally to adjust for new data distributions, but this adds maintenance effort.\nAnother possible use for a partial index is to exclude values from the index that the typical query workload is not interested in; this is shown inExample 11.2. This results in the same advantages as listed above, but it prevents the“uninteresting”values from being accessed via that index, even if an index scan might be profitable in that case. Obviously, setting up partial indexes for this kind of scenario will require a lot of care and experimentation.\nExample 11.2. Setting up a Partial Index to Exclude Uninteresting Values\nIf you have a table that contains both billed and unbilled orders, where the unbilled orders take up a small fraction of the total table and yet those are the most-accessed rows, you can improve performance by creating an index on just the unbilled rows. The command to create the index would look like this:\n\n\nCODE:\n\nCREATE INDEX orders_unbilled_index ON orders (order_nr)\n    WHERE billed is not true;\n\nA possible query to use this index would be:\n\n\nCODE:\n\nSELECT * FROM orders WHERE billed is not true AND order_nr < 10000;\n\nHowever, the index can also be used in queries that do not involveorder_nrat all, e.g.:\n\n\nCODE:\n\nSELECT * FROM orders WHERE billed is not true AND amount > 5000.00;\n\nThis is not as efficient as a partial index on theamountcolumn would be, since the system has to scan the entire index. Yet, if there are relatively few unbilled orders, using this partial index just to find the unbilled orders could be a win.\nNote that this query cannot use this index:\n\n\nCODE:\n\nSELECT * FROM orders WHERE order_nr = 3501;\n\nThe order 3501 might be among the billed or unbilled orders.\nExample 11.2also illustrates that the indexed column and the column used in the predicate do not need to match.PostgreSQLsupports partial indexes with arbitrary predicates, so long",
    "metadata": {
      "doc_name": "indexes-partial",
      "section_title": "11.8. Partial Indexes#",
      "url": "https://www.postgresql.org/docs/16/indexes-partial.html"
    }
  },
  {
    "chunk_id": 2,
    "text": ". Yet, if there are relatively few unbilled orders, using this partial index just to find the unbilled orders could be a win.\nNote that this query cannot use this index:\n\n\nCODE:\n\nSELECT * FROM orders WHERE order_nr = 3501;\n\nThe order 3501 might be among the billed or unbilled orders.\nExample 11.2also illustrates that the indexed column and the column used in the predicate do not need to match.PostgreSQLsupports partial indexes with arbitrary predicates, so long as only columns of the table being indexed are involved. However, keep in mind that the predicate must match the conditions used in the queries that are supposed to benefit from the index. To be precise, a partial index can be used in a query only if the system can recognize that theWHEREcondition of the query mathematically implies the predicate of the index.PostgreSQLdoes not have a sophisticated theorem prover that can recognize mathematically equivalent expressions that are written in different forms. (Not only is such a general theorem prover extremely difficult to create, it would probably be too slow to be of any real use.) The system can recognize simple inequality implications, for example“x < 1”implies“x < 2”; otherwise the predicate condition must exactly match part of the query'sWHEREcondition or the index will not be recognized as usable. Matching takes place at query planning time, not at run time. As a result, parameterized query clauses do not work with a partial index. For example a prepared query with a parameter might specify“x < ?”which will never imply“x < 2”for all possible values of the parameter.\nA third possible use for partial indexes does not require the index to be used in queries at all. The idea here is to create a unique index over a subset of a table, as inExample 11.3. This enforces uniqueness among the rows that satisfy the index predicate, without constraining those that do not.\nExample 11.3. Setting up a Partial Unique Index\nSuppose that we have a table describing test outcomes. We wish to ensure that there is only one“successful”entry for a given subject and target combination, but there might be any number of“unsuccessful”entries. Here is one way to do it:\n\n\nCODE:\n\nCREATE TABLE tests (\n    subject text,\n    target text,\n    success boolean,\n    ...\n);\n\nCREATE UNIQUE INDEX tests_success_constraint ON tests (subject, target)",
    "metadata": {
      "doc_name": "indexes-partial",
      "section_title": "11.8. Partial Indexes#",
      "url": "https://www.postgresql.org/docs/16/indexes-partial.html"
    }
  },
  {
    "chunk_id": 3,
    "text": "11.3. Setting up a Partial Unique Index\nSuppose that we have a table describing test outcomes. We wish to ensure that there is only one“successful”entry for a given subject and target combination, but there might be any number of“unsuccessful”entries. Here is one way to do it:\n\n\nCODE:\n\nCREATE TABLE tests (\n    subject text,\n    target text,\n    success boolean,\n    ...\n);\n\nCREATE UNIQUE INDEX tests_success_constraint ON tests (subject, target)\n    WHERE success;\n\nThis is a particularly efficient approach when there are few successful tests and many unsuccessful ones. It is also possible to allow only one null in a column by creating a unique partial index with anIS NULLrestriction.\nFinally, a partial index can also be used to override the system's query plan choices. Also, data sets with peculiar distributions might cause the system to use an index when it really should not. In that case the index can be set up so that it is not available for the offending query. Normally,PostgreSQLmakes reasonable choices about index usage (e.g., it avoids them when retrieving common values, so the earlier example really only saves index size, it is not required to avoid index usage), and grossly incorrect plan choices are cause for a bug report.\nKeep in mind that setting up a partial index indicates that you know at least as much as the query planner knows, in particular you know when an index might be profitable. Forming this knowledge requires experience and understanding of how indexes inPostgreSQLwork. In most cases, the advantage of a partial index over a regular index will be minimal. There are cases where they are quite counterproductive, as inExample 11.4.\nExample 11.4. Do Not Use Partial Indexes as a Substitute for Partitioning\nYou might be tempted to create a large set of non-overlapping partial indexes, for example\n\n\nCODE:\n\nCREATE INDEX mytable_cat_1 ON mytable (data) WHERE category = 1;\nCREATE INDEX mytable_cat_2 ON mytable (data) WHERE category = 2;\nCREATE INDEX mytable_cat_3 ON mytable (data) WHERE category = 3;\n...\nCREATE INDEX mytable_cat_N ON mytable (data) WHERE category = N;\n\nThis is a bad idea! Almost certainly, you'll be better off with a single non-partial index, declared like\n\n\nCODE:\n\nCREATE INDEX mytable_cat_data ON mytable (category, data",
    "metadata": {
      "doc_name": "indexes-partial",
      "section_title": "11.8. Partial Indexes#",
      "url": "https://www.postgresql.org/docs/16/indexes-partial.html"
    }
  },
  {
    "chunk_id": 4,
    "text": "= 1;\nCREATE INDEX mytable_cat_2 ON mytable (data) WHERE category = 2;\nCREATE INDEX mytable_cat_3 ON mytable (data) WHERE category = 3;\n...\nCREATE INDEX mytable_cat_N ON mytable (data) WHERE category = N;\n\nThis is a bad idea! Almost certainly, you'll be better off with a single non-partial index, declared like\n\n\nCODE:\n\nCREATE INDEX mytable_cat_data ON mytable (category, data);\n\n(Put the category column first, for the reasons described inSection 11.3.) While a search in this larger index might have to descend through a couple more tree levels than a search in a smaller index, that's almost certainly going to be cheaper than the planner effort needed to select the appropriate one of the partial indexes. The core of the problem is that the system does not understand the relationship among the partial indexes, and will laboriously test each one to see if it's applicable to the current query.\nIf your table is large enough that a single index really is a bad idea, you should look into using partitioning instead (seeSection 5.11). With that mechanism, the system does understand that the tables and indexes are non-overlapping, so far better performance is possible.\nMore information about partial indexes can be found in[ston89b],[olson93], and[seshadri95].",
    "metadata": {
      "doc_name": "indexes-partial",
      "section_title": "11.8. Partial Indexes#",
      "url": "https://www.postgresql.org/docs/16/indexes-partial.html"
    }
  },
  {
    "chunk_id": 0,
    "text": "Table of Contents\nIndexes are a common way to enhance database performance. An index allows the database server to find and retrieve specific rows much faster than it could do without an index. But indexes also add overhead to the database system as a whole, so they should be used sensibly.",
    "metadata": {
      "doc_name": "indexes",
      "section_title": "Chapter 11. Indexes",
      "url": "https://www.postgresql.org/docs/16/indexes.html"
    }
  },
  {
    "chunk_id": 0,
    "text": "Table of Contents\nThis chapter describes the behavior of thePostgreSQLdatabase system when two or more sessions try to access the same data at the same time. The goals in that situation are to allow efficient access for all sessions while maintaining strict data integrity. Every developer of database applications should be familiar with the topics covered in this chapter.",
    "metadata": {
      "doc_name": "mvcc",
      "section_title": "Chapter 13. Concurrency Control",
      "url": "https://www.postgresql.org/docs/16/mvcc.html"
    }
  },
  {
    "chunk_id": 0,
    "text": "Table of Contents\nThere are many configuration parameters that affect the behavior of the database system. In the first section of this chapter we describe how to interact with configuration parameters. The subsequent sections discuss each parameter in detail.",
    "metadata": {
      "doc_name": "runtime-config",
      "section_title": "Chapter 20. Server Configuration",
      "url": "https://www.postgresql.org/docs/16/runtime-config.html"
    }
  },
  {
    "chunk_id": 0,
    "text": "ALTER ROLE — change a database role",
    "metadata": {
      "doc_name": "sql-alterrole",
      "section_title": "ALTER ROLE",
      "url": "https://www.postgresql.org/docs/16/sql-alterrole.html"
    }
  },
  {
    "chunk_id": 1,
    "text": "CODE:\n\nALTER ROLE role_specification [ WITH ] option [ ... ]\n\nwhere option can be:\n\n      SUPERUSER | NOSUPERUSER\n    | CREATEDB | NOCREATEDB\n    | CREATEROLE | NOCREATEROLE\n    | INHERIT | NOINHERIT\n    | LOGIN | NOLOGIN\n    | REPLICATION | NOREPLICATION\n    | BYPASSRLS | NOBYPASSRLS\n    | CONNECTION LIMIT connlimit\n    | [ ENCRYPTED ] PASSWORD 'password' | PASSWORD NULL\n    | VALID UNTIL 'timestamp'\n\nALTER ROLE name RENAME TO new_name\n\nALTER ROLE { role_specification | ALL } [ IN DATABASE database_name ] SET configuration_parameter { TO | = } { value | DEFAULT }\nALTER ROLE { role_specification | ALL } [ IN DATABASE database_name ] SET configuration_parameter FROM CURRENT\nALTER ROLE { role_specification | ALL } [ IN DATABASE database_name ] RESET configuration_parameter\nALTER ROLE { role_specification | ALL } [ IN DATABASE database_name ] RESET ALL\n\nwhere role_specification can be:\n\n    role_name\n  | CURRENT_ROLE\n  | CURRENT_USER\n  | SESSION_USER",
    "metadata": {
      "doc_name": "sql-alterrole",
      "section_title": "Synopsis",
      "url": "https://www.postgresql.org/docs/16/sql-alterrole.html"
    }
  },
  {
    "chunk_id": 2,
    "text": "ALTER ROLEchanges the attributes of aPostgreSQLrole.\nThe first variant of this command listed in the synopsis can change many of the role attributes that can be specified inCREATE ROLE. (All the possible attributes are covered, except that there are no options for adding or removing memberships; useGRANTandREVOKEfor that.) Attributes not mentioned in the command retain their previous settings. Database superusers can change any of these settings for any role. Non-superuser roles havingCREATEROLEprivilege can change most of these properties, but only for non-superuser and non-replication roles for which they have been grantedADMIN OPTION. Non-superusers cannot change theSUPERUSERproperty and can change theCREATEDB,REPLICATION, andBYPASSRLSproperties only if they possess the corresponding property themselves. Ordinary roles can only change their own password.\nThe second variant changes the name of the role. Database superusers can rename any role. Roles havingCREATEROLEprivilege can rename non-superuser roles for which they have been grantedADMIN OPTION. The current session user cannot be renamed. (Connect as a different user if you need to do that.) BecauseMD5-encrypted passwords use the role name as cryptographic salt, renaming a role clears its password if the password isMD5-encrypted.\nThe remaining variants change a role's session default for a configuration variable, either for all databases or, when theIN DATABASEclause is specified, only for sessions in the named database. IfALLis specified instead of a role name, this changes the setting for all roles. UsingALLwithIN DATABASEis effectively the same as using the commandALTER DATABASE ... SET ....\nWhenever the role subsequently starts a new session, the specified value becomes the session default, overriding whatever setting is present inpostgresql.confor has been received from thepostgrescommand line. This only happens at login time; executingSET ROLEorSET SESSION AUTHORIZATIONdoes not cause new configuration values to be set. Settings set for all databases are overridden by database-specific settings attached to a role. Settings for specific databases or specific roles override settings for all roles.\nSuperusers can change anyone's session defaults. Roles havingCREATEROLEprivilege can change defaults for non-superuser roles for which they have been grantedADMIN OPTION. Ordinary roles can only set defaults for themselves. Certain configuration variables cannot be set this way, or can only be set if a superuser issues the command. Only superusers can change a setting",
    "metadata": {
      "doc_name": "sql-alterrole",
      "section_title": "Description",
      "url": "https://www.postgresql.org/docs/16/sql-alterrole.html"
    }
  },
  {
    "chunk_id": 3,
    "text": "set for all databases are overridden by database-specific settings attached to a role. Settings for specific databases or specific roles override settings for all roles.\nSuperusers can change anyone's session defaults. Roles havingCREATEROLEprivilege can change defaults for non-superuser roles for which they have been grantedADMIN OPTION. Ordinary roles can only set defaults for themselves. Certain configuration variables cannot be set this way, or can only be set if a superuser issues the command. Only superusers can change a setting for all roles in all databases.",
    "metadata": {
      "doc_name": "sql-alterrole",
      "section_title": "Description",
      "url": "https://www.postgresql.org/docs/16/sql-alterrole.html"
    }
  },
  {
    "chunk_id": 4,
    "text": "The name of the role whose attributes are to be altered.\nAlter the current user instead of an explicitly identified role.\nAlter the current session user instead of an explicitly identified role.\nThese clauses alter attributes originally set byCREATE ROLE. For more information, see theCREATE ROLEreference page.\nThe new name of the role.\nThe name of the database the configuration variable should be set in.\nSet this role's session default for the specified configuration parameter to the given value. IfvalueisDEFAULTor, equivalently,RESETis used, the role-specific variable setting is removed, so the role will inherit the system-wide default setting in new sessions. UseRESET ALLto clear all role-specific settings.SET FROM CURRENTsaves the session's current value of the parameter as the role-specific value. IfIN DATABASEis specified, the configuration parameter is set or removed for the given role and database only.\nRole-specific variable settings take effect only at login;SET ROLEandSET SESSION AUTHORIZATIONdo not process role-specific variable settings.\nSeeSETandChapter 20for more information about allowed parameter names and values.",
    "metadata": {
      "doc_name": "sql-alterrole",
      "section_title": "Parameters",
      "url": "https://www.postgresql.org/docs/16/sql-alterrole.html"
    }
  },
  {
    "chunk_id": 5,
    "text": "UseCREATE ROLEto add new roles, andDROP ROLEto remove a role.\nALTER ROLEcannot change a role's memberships. UseGRANTandREVOKEto do that.\nCaution must be exercised when specifying an unencrypted password with this command. The password will be transmitted to the server in cleartext, and it might also be logged in the client's command history or the server log.psqlcontains a command\\passwordthat can be used to change a role's password without exposing the cleartext password.\nIt is also possible to tie a session default to a specific database rather than to a role; seeALTER DATABASE. If there is a conflict, database-role-specific settings override role-specific ones, which in turn override database-specific ones.",
    "metadata": {
      "doc_name": "sql-alterrole",
      "section_title": "Notes",
      "url": "https://www.postgresql.org/docs/16/sql-alterrole.html"
    }
  },
  {
    "chunk_id": 6,
    "text": "Change a role's password:\n\n\nCODE:\n\nALTER ROLE davide WITH PASSWORD 'hu8jmn3';\n\nRemove a role's password:\n\n\nCODE:\n\nALTER ROLE davide WITH PASSWORD NULL;\n\nChange a password expiration date, specifying that the password should expire at midday on 4th May 2015 using the time zone which is one hour ahead ofUTC:\n\n\nCODE:\n\nALTER ROLE chris VALID UNTIL 'May 4 12:00:00 2015 +1';\n\nMake a password valid forever:\n\n\nCODE:\n\nALTER ROLE fred VALID UNTIL 'infinity';\n\nGive a role the ability to manage other roles and create new databases:\n\n\nCODE:\n\nALTER ROLE miriam CREATEROLE CREATEDB;\n\nGive a role a non-default setting of themaintenance_work_memparameter:\n\n\nCODE:\n\nALTER ROLE worker_bee SET maintenance_work_mem = 100000;\n\nGive a role a non-default, database-specific setting of theclient_min_messagesparameter:\n\n\nCODE:\n\nALTER ROLE fred IN DATABASE devel SET client_min_messages = DEBUG;",
    "metadata": {
      "doc_name": "sql-alterrole",
      "section_title": "Examples",
      "url": "https://www.postgresql.org/docs/16/sql-alterrole.html"
    }
  },
  {
    "chunk_id": 7,
    "text": "TheALTER ROLEstatement is aPostgreSQLextension.",
    "metadata": {
      "doc_name": "sql-alterrole",
      "section_title": "Compatibility",
      "url": "https://www.postgresql.org/docs/16/sql-alterrole.html"
    }
  },
  {
    "chunk_id": 0,
    "text": "ALTER TABLE — change the definition of a table",
    "metadata": {
      "doc_name": "sql-altertable",
      "section_title": "ALTER TABLE",
      "url": "https://www.postgresql.org/docs/16/sql-altertable.html"
    }
  },
  {
    "chunk_id": 1,
    "text": "CODE:\n\nALTER TABLE [ IF EXISTS ] [ ONLY ] name [ * ]\n    action [, ... ]\nALTER TABLE [ IF EXISTS ] [ ONLY ] name [ * ]\n    RENAME [ COLUMN ] column_name TO new_column_name\nALTER TABLE [ IF EXISTS ] [ ONLY ] name [ * ]\n    RENAME CONSTRAINT constraint_name TO new_constraint_name\nALTER TABLE [ IF EXISTS ] name\n    RENAME TO new_name\nALTER TABLE [ IF EXISTS ] name\n    SET SCHEMA new_schema\nALTER TABLE ALL IN TABLESPACE name [ OWNED BY role_name [, ... ] ]\n    SET TABLESPACE new_tablespace [ NOWAIT ]\nALTER TABLE [ IF EXISTS ] name\n    ATTACH PARTITION partition_name { FOR VALUES partition_bound_spec | DEFAULT }\nALTER TABLE [ IF EXISTS ] name\n    DETACH PARTITION partition_name [ CONCURRENTLY | FINALIZE ]\n\nwhere action is one of:\n\n    ADD [ COLUMN ] [ IF NOT EXISTS ] column_name data_type [ COLLATE collation ] [ column_constraint [ ... ] ]\n    DROP [ COLUMN ] [ IF EXISTS ] column_name [ RESTRICT | CASCADE ]\n    ALTER [ COLUMN ] column_name [ SET DATA ] TYPE data_type [ COLLATE collation ] [ USING expression ]\n    ALTER [ COLUMN ] column_name SET DEFAULT expression\n    ALTER [ COLUMN ] column_name DROP DEFAULT\n    ALTER [ COLUMN ] column_name { SET | DROP } NOT NULL\n    ALTER [ COLUMN ] column_name DROP EXPRESSION [ IF EXISTS ]\n    ALTER [ COLUMN ] column_name ADD GENERATED { ALWAYS | BY DEFAULT } AS IDENTITY [ ( sequence_options ) ]\n    ALTER [ COLUMN ] column_name { SET GENERATED { ALWAYS | BY DEFAULT } | SET sequence_option | RESTART [ [ WITH ] restart ] } [...]\n    ALTER [ COLUMN ] column_name DROP IDENTITY [ IF EXISTS ]\n    ALTER [ COLUMN ] column_name SET STATISTICS integer\n    ALTER [ COLUMN ] column_name SET ( attribute_option = value [, ... ] )\n    ALTER [ COLUMN ] column_name RESET ( attribute_option [, ... ] )\n    ALTER [ COLUMN ] column_name SET STORAGE { PLAIN | EXTERNAL | EXTENDED | MAIN | DEFAULT }\n    ALTER [ COLUMN ] column_name SET COMPRESSION compression_method\n    ADD table_constraint [ NOT VALID ]\n    ADD table_constraint_using_index\n    ALTER CONSTRAINT constraint_name [ DEFERRABLE | NOT DEFERRABLE ] [ INITIALLY DEFERRED | INITIALLY IMMEDIATE ]\n    VALIDATE CONSTRAINT constraint_name",
    "metadata": {
      "doc_name": "sql-altertable",
      "section_title": "Synopsis",
      "url": "https://www.postgresql.org/docs/16/sql-altertable.html"
    }
  },
  {
    "chunk_id": 2,
    "text": "[ COLUMN ] column_name RESET ( attribute_option [, ... ] )\n    ALTER [ COLUMN ] column_name SET STORAGE { PLAIN | EXTERNAL | EXTENDED | MAIN | DEFAULT }\n    ALTER [ COLUMN ] column_name SET COMPRESSION compression_method\n    ADD table_constraint [ NOT VALID ]\n    ADD table_constraint_using_index\n    ALTER CONSTRAINT constraint_name [ DEFERRABLE | NOT DEFERRABLE ] [ INITIALLY DEFERRED | INITIALLY IMMEDIATE ]\n    VALIDATE CONSTRAINT constraint_name\n    DROP CONSTRAINT [ IF EXISTS ]  constraint_name [ RESTRICT | CASCADE ]\n    DISABLE TRIGGER [ trigger_name | ALL | USER ]\n    ENABLE TRIGGER [ trigger_name | ALL | USER ]\n    ENABLE REPLICA TRIGGER trigger_name\n    ENABLE ALWAYS TRIGGER trigger_name\n    DISABLE RULE rewrite_rule_name\n    ENABLE RULE rewrite_rule_name\n    ENABLE REPLICA RULE rewrite_rule_name\n    ENABLE ALWAYS RULE rewrite_rule_name\n    DISABLE ROW LEVEL SECURITY\n    ENABLE ROW LEVEL SECURITY\n    FORCE ROW LEVEL SECURITY\n    NO FORCE ROW LEVEL SECURITY\n    CLUSTER ON index_name\n    SET WITHOUT CLUSTER\n    SET WITHOUT OIDS\n    SET ACCESS METHOD new_access_method\n    SET TABLESPACE new_tablespace\n    SET { LOGGED | UNLOGGED }\n    SET ( storage_parameter [= value] [, ... ] )\n    RESET ( storage_parameter [, ... ] )\n    INHERIT parent_table\n    NO INHERIT parent_table\n    OF type_name\n    NOT OF\n    OWNER TO { new_owner | CURRENT_ROLE | CURRENT_USER | SESSION_USER }\n    REPLICA IDENTITY { DEFAULT | USING INDEX index_name | FULL | NOTHING }\n\nand partition_bound_spec is:\n\nIN ( partition_bound_expr [, ...] ) |\nFROM ( { partition_bound_expr | MINVALUE | MAXVALUE } [, ...] )\n  TO ( { partition_bound_expr | MINVALUE | MAXVALUE } [, ...] ) |\nWITH ( MODULUS numeric_literal, REMAINDER numeric_literal )\n\nand column_constraint is:\n\n[ CONSTRAINT constraint_name ]\n{ NOT NULL |\n  NULL |\n  CHECK ( expression ) [ NO INHERIT ] |\n  DEFAULT default_expr |\n  GENERATED ALWAYS AS ( generation_expr ) STORED |\n  GENERATED { ALWAYS | BY DEFAULT } AS IDENTITY [ ( sequence_options ) ] |\n  UNIQUE [ NULLS [ NOT ] DISTINCT ] index_parameters |\n  PRIMARY KEY index_parameters |\n  REFERENCES reftable [ ( refcolumn ) ] [ MATCH FULL | MATCH",
    "metadata": {
      "doc_name": "sql-altertable",
      "section_title": "Synopsis",
      "url": "https://www.postgresql.org/docs/16/sql-altertable.html"
    }
  },
  {
    "chunk_id": 3,
    "text": "_literal )\n\nand column_constraint is:\n\n[ CONSTRAINT constraint_name ]\n{ NOT NULL |\n  NULL |\n  CHECK ( expression ) [ NO INHERIT ] |\n  DEFAULT default_expr |\n  GENERATED ALWAYS AS ( generation_expr ) STORED |\n  GENERATED { ALWAYS | BY DEFAULT } AS IDENTITY [ ( sequence_options ) ] |\n  UNIQUE [ NULLS [ NOT ] DISTINCT ] index_parameters |\n  PRIMARY KEY index_parameters |\n  REFERENCES reftable [ ( refcolumn ) ] [ MATCH FULL | MATCH PARTIAL | MATCH SIMPLE ]\n    [ ON DELETE referential_action ] [ ON UPDATE referential_action ] }\n[ DEFERRABLE | NOT DEFERRABLE ] [ INITIALLY DEFERRED | INITIALLY IMMEDIATE ]\n\nand table_constraint is:\n\n[ CONSTRAINT constraint_name ]\n{ CHECK ( expression ) [ NO INHERIT ] |\n  UNIQUE [ NULLS [ NOT ] DISTINCT ] ( column_name [, ... ] ) index_parameters |\n  PRIMARY KEY ( column_name [, ... ] ) index_parameters |\n  EXCLUDE [ USING index_method ] ( exclude_element WITH operator [, ... ] ) index_parameters [ WHERE ( predicate ) ] |\n  FOREIGN KEY ( column_name [, ... ] ) REFERENCES reftable [ ( refcolumn [, ... ] ) ]\n    [ MATCH FULL | MATCH PARTIAL | MATCH SIMPLE ] [ ON DELETE referential_action ] [ ON UPDATE referential_action ] }\n[ DEFERRABLE | NOT DEFERRABLE ] [ INITIALLY DEFERRED | INITIALLY IMMEDIATE ]\n\nand table_constraint_using_index is:\n\n    [ CONSTRAINT constraint_name ]\n    { UNIQUE | PRIMARY KEY } USING INDEX index_name\n    [ DEFERRABLE | NOT DEFERRABLE ] [ INITIALLY DEFERRED | INITIALLY IMMEDIATE ]\n\nindex_parameters in UNIQUE, PRIMARY KEY, and EXCLUDE constraints are:\n\n[ INCLUDE ( column_name [, ... ] ) ]\n[ WITH ( storage_parameter [= value] [, ... ] ) ]\n[ USING INDEX TABLESPACE tablespace_name ]\n\nexclude_element in an EXCLUDE constraint is:\n\n{ column_name | ( expression ) } [ COLLATE collation ] [ opclass [ ( opclass_parameter = value [, ... ] ) ] ] [ ASC | DESC ] [ NULLS { FIRST | LAST } ]\n\nreferential_action in a FOREIGN KEY/REFERENCES constraint is:\n\n{ NO ACTION | RESTRICT | CASCADE | SET NULL [ ( column_name [, ... ] ) ] | SET DEFAULT [ ( column_name [, ... ] ) ] }",
    "metadata": {
      "doc_name": "sql-altertable",
      "section_title": "Synopsis",
      "url": "https://www.postgresql.org/docs/16/sql-altertable.html"
    }
  },
  {
    "chunk_id": 4,
    "text": "ALTER TABLEchanges the definition of an existing table. There are several subforms described below. Note that the lock level required may differ for each subform. AnACCESS EXCLUSIVElock is acquired unless explicitly noted. When multiple subcommands are given, the lock acquired will be the strictest one required by any subcommand.\nThis form adds a new column to the table, using the same syntax asCREATE TABLE. IfIF NOT EXISTSis specified and a column already exists with this name, no error is thrown.\nThis form drops a column from a table. Indexes and table constraints involving the column will be automatically dropped as well. Multivariate statistics referencing the dropped column will also be removed if the removal of the column would cause the statistics to contain data for only a single column. You will need to sayCASCADEif anything outside the table depends on the column, for example, foreign key references or views. IfIF EXISTSis specified and the column does not exist, no error is thrown. In this case a notice is issued instead.\nThis form changes the type of a column of a table. Indexes and simple table constraints involving the column will be automatically converted to use the new column type by reparsing the originally supplied expression. The optionalCOLLATEclause specifies a collation for the new column; if omitted, the collation is the default for the new column type. The optionalUSINGclause specifies how to compute the new column value from the old; if omitted, the default conversion is the same as an assignment cast from old data type to new. AUSINGclause must be provided if there is no implicit or assignment cast from old to new type.\nWhen this form is used, the column's statistics are removed, so runningANALYZEon the table afterwards is recommended.\nThese forms set or remove the default value for a column (where removal is equivalent to setting the default value to NULL). The new default value will only apply in subsequentINSERTorUPDATEcommands; it does not cause rows already in the table to change.\nThese forms change whether a column is marked to allow null values or to reject null values.\nSET NOT NULLmay only be applied to a column provided none of the records in the table contain aNULLvalue for the column. Ordinarily this is checked during theALTER TABLEby scanning the entire table; however, if a validCHECKconstraint exists (and is not dropped in the same command) which proves noNULLcan exist, then the table scan is",
    "metadata": {
      "doc_name": "sql-altertable",
      "section_title": "Description",
      "url": "https://www.postgresql.org/docs/16/sql-altertable.html"
    }
  },
  {
    "chunk_id": 5,
    "text": "not cause rows already in the table to change.\nThese forms change whether a column is marked to allow null values or to reject null values.\nSET NOT NULLmay only be applied to a column provided none of the records in the table contain aNULLvalue for the column. Ordinarily this is checked during theALTER TABLEby scanning the entire table; however, if a validCHECKconstraint exists (and is not dropped in the same command) which proves noNULLcan exist, then the table scan is skipped.\nIf this table is a partition, one cannot performDROP NOT NULLon a column if it is markedNOT NULLin the parent table. To drop theNOT NULLconstraint from all the partitions, performDROP NOT NULLon the parent table. Even if there is noNOT NULLconstraint on the parent, such a constraint can still be added to individual partitions, if desired; that is, the children can disallow nulls even if the parent allows them, but not the other way around.\nThis form turns a stored generated column into a normal base column. Existing data in the columns is retained, but future changes will no longer apply the generation expression.\nIfDROP EXPRESSION IF EXISTSis specified and the column is not a stored generated column, no error is thrown. In this case a notice is issued instead.\nThese forms change whether a column is an identity column or change the generation attribute of an existing identity column. SeeCREATE TABLEfor details. LikeSET DEFAULT, these forms only affect the behavior of subsequentINSERTandUPDATEcommands; they do not cause rows already in the table to change.\nIfDROP IDENTITY IF EXISTSis specified and the column is not an identity column, no error is thrown. In this case a notice is issued instead.\nThese forms alter the sequence that underlies an existing identity column.sequence_optionis an option supported byALTER SEQUENCEsuch asINCREMENT BY.\nThis form sets the per-column statistics-gathering target for subsequentANALYZEoperations. The target can be set in the range 0 to 10000; alternatively, set it to -1 to revert to using the system default statistics target (default_statistics_target). For more information on the use of statistics by thePostgreSQLquery planner, refer toSection 14.2.\nSET STATISTICSacquires aSHARE UPDATE EXCLUSIVElock.\nThis form sets or resets per-attribute options. Currently, the only defined per-attribute options aren_distinctandn_distinct_inherited, which override the number-of",
    "metadata": {
      "doc_name": "sql-altertable",
      "section_title": "Description",
      "url": "https://www.postgresql.org/docs/16/sql-altertable.html"
    }
  },
  {
    "chunk_id": 6,
    "text": "in the range 0 to 10000; alternatively, set it to -1 to revert to using the system default statistics target (default_statistics_target). For more information on the use of statistics by thePostgreSQLquery planner, refer toSection 14.2.\nSET STATISTICSacquires aSHARE UPDATE EXCLUSIVElock.\nThis form sets or resets per-attribute options. Currently, the only defined per-attribute options aren_distinctandn_distinct_inherited, which override the number-of-distinct-values estimates made by subsequentANALYZEoperations.n_distinctaffects the statistics for the table itself, whilen_distinct_inheritedaffects the statistics gathered for the table plus its inheritance children, and for the statistics gathered for partitioned tables. When the value specified is a positive value, the query planner will assume that the column contains exactly the specified number of distinct nonnull values. Fractional values may also be specified by using values below 0 and above or equal to -1. This instructs the query planner to estimate the number of distinct values by multiplying the absolute value of the specified number by the estimated number of rows in the table. For example, a value of -1 implies that all values in the column are distinct, while a value of -0.5 implies that each value appears twice on average. This can be useful when the size of the table changes over time. For more information on the use of statistics by thePostgreSQLquery planner, refer toSection 14.2.\nChanging per-attribute options acquires aSHARE UPDATE EXCLUSIVElock.\nThis form sets the storage mode for a column. This controls whether this column is held inline or in a secondaryTOASTtable, and whether the data should be compressed or not.PLAINmust be used for fixed-length values such asintegerand is inline, uncompressed.MAINis for inline, compressible data.EXTERNALis for external, uncompressed data, andEXTENDEDis for external, compressed data. WritingDEFAULTsets the storage mode to the default mode for the column's data type.EXTENDEDis the default for most data types that support non-PLAINstorage. Use ofEXTERNALwill make substring operations on very largetextandbyteavalues run faster, at the penalty of increased storage space. Note thatALTER TABLE ... SET STORAGEdoesn't itself change anything in the table; it just sets the strategy to be pursued during future table updates. SeeSection 73.2for",
    "metadata": {
      "doc_name": "sql-altertable",
      "section_title": "Description",
      "url": "https://www.postgresql.org/docs/16/sql-altertable.html"
    }
  },
  {
    "chunk_id": 7,
    "text": "DEFAULTsets the storage mode to the default mode for the column's data type.EXTENDEDis the default for most data types that support non-PLAINstorage. Use ofEXTERNALwill make substring operations on very largetextandbyteavalues run faster, at the penalty of increased storage space. Note thatALTER TABLE ... SET STORAGEdoesn't itself change anything in the table; it just sets the strategy to be pursued during future table updates. SeeSection 73.2for more information.\nThis form sets the compression method for a column, determining how values inserted in future will be compressed (if the storage mode permits compression at all). This does not cause the table to be rewritten, so existing data may still be compressed with other compression methods. If the table is restored withpg_restore, then all values are rewritten with the configured compression method. However, when data is inserted from another relation (for example, byINSERT ... SELECT), values from the source table are not necessarily detoasted, so any previously compressed data may retain its existing compression method, rather than being recompressed with the compression method of the target column. The supported compression methods arepglzandlz4. (lz4is available only if--with-lz4was used when buildingPostgreSQL.) In addition,compression_methodcan bedefault, which selects the default behavior of consulting thedefault_toast_compressionsetting at the time of data insertion to determine the method to use.\nThis form adds a new constraint to a table using the same constraint syntax asCREATE TABLE, plus the optionNOT VALID, which is currently only allowed for foreign key and CHECK constraints.\nNormally, this form will cause a scan of the table to verify that all existing rows in the table satisfy the new constraint. But if theNOT VALIDoption is used, this potentially-lengthy scan is skipped. The constraint will still be enforced against subsequent inserts or updates (that is, they'll fail unless there is a matching row in the referenced table, in the case of foreign keys, or they'll fail unless the new row matches the specified check condition). But the database will not assume that the constraint holds for all rows in the table, until it is validated by using theVALIDATE CONSTRAINToption. SeeNotesbelow for more information about using theNOT VALIDoption.\nAlthough most forms ofADDtable_constraintrequire anACCESS EXCLUSIVElock,ADD FOREIGN KEYrequires only aSHARE ROW EXCLUSIVElock. Note thatADD FOREIGN KEY",
    "metadata": {
      "doc_name": "sql-altertable",
      "section_title": "Description",
      "url": "https://www.postgresql.org/docs/16/sql-altertable.html"
    }
  },
  {
    "chunk_id": 8,
    "text": "the referenced table, in the case of foreign keys, or they'll fail unless the new row matches the specified check condition). But the database will not assume that the constraint holds for all rows in the table, until it is validated by using theVALIDATE CONSTRAINToption. SeeNotesbelow for more information about using theNOT VALIDoption.\nAlthough most forms ofADDtable_constraintrequire anACCESS EXCLUSIVElock,ADD FOREIGN KEYrequires only aSHARE ROW EXCLUSIVElock. Note thatADD FOREIGN KEYalso acquires aSHARE ROW EXCLUSIVElock on the referenced table, in addition to the lock on the table on which the constraint is declared.\nAdditional restrictions apply when unique or primary key constraints are added to partitioned tables; seeCREATE TABLE. Also, foreign key constraints on partitioned tables may not be declaredNOT VALIDat present.\nThis form adds a newPRIMARY KEYorUNIQUEconstraint to a table based on an existing unique index. All the columns of the index will be included in the constraint.\nThe index cannot have expression columns nor be a partial index. Also, it must be a b-tree index with default sort ordering. These restrictions ensure that the index is equivalent to one that would be built by a regularADD PRIMARY KEYorADD UNIQUEcommand.\nIfPRIMARY KEYis specified, and the index's columns are not already markedNOT NULL, then this command will attempt to doALTER COLUMN SET NOT NULLagainst each such column. That requires a full table scan to verify the column(s) contain no nulls. In all other cases, this is a fast operation.\nIf a constraint name is provided then the index will be renamed to match the constraint name. Otherwise the constraint will be named the same as the index.\nAfter this command is executed, the index is“owned”by the constraint, in the same way as if the index had been built by a regularADD PRIMARY KEYorADD UNIQUEcommand. In particular, dropping the constraint will make the index disappear too.\nThis form is not currently supported on partitioned tables.",
    "metadata": {
      "doc_name": "sql-altertable",
      "section_title": "Description",
      "url": "https://www.postgresql.org/docs/16/sql-altertable.html"
    }
  },
  {
    "chunk_id": 9,
    "text": "Adding a constraint using an existing index can be helpful in situations where a new constraint needs to be added without blocking table updates for a long time. To do that, create the index usingCREATE INDEX CONCURRENTLY, and then install it as an official constraint using this syntax. See the example below.\nThis form alters the attributes of a constraint that was previously created. Currently only foreign key constraints may be altered.\nThis form validates a foreign key or check constraint that was previously created asNOT VALID, by scanning the table to ensure there are no rows for which the constraint is not satisfied. Nothing happens if the constraint is already marked valid. (SeeNotesbelow for an explanation of the usefulness of this command.)\nThis command acquires aSHARE UPDATE EXCLUSIVElock.\nThis form drops the specified constraint on a table, along with any index underlying the constraint. IfIF EXISTSis specified and the constraint does not exist, no error is thrown. In this case a notice is issued instead.\nThese forms configure the firing of trigger(s) belonging to the table. A disabled trigger is still known to the system, but is not executed when its triggering event occurs. (For a deferred trigger, the enable status is checked when the event occurs, not when the trigger function is actually executed.) One can disable or enable a single trigger specified by name, or all triggers on the table, or only user triggers (this option excludes internally generated constraint triggers, such as those that are used to implement foreign key constraints or deferrable uniqueness and exclusion constraints). Disabling or enabling internally generated constraint triggers requires superuser privileges; it should be done with caution since of course the integrity of the constraint cannot be guaranteed if the triggers are not executed.\nThe trigger firing mechanism is also affected by the configuration variablesession_replication_role. Simply enabled triggers (the default) will fire when the replication role is“origin”(the default) or“local”. Triggers configured asENABLE REPLICAwill only fire if the session is in“replica”mode, and triggers configured asENABLE ALWAYSwill fire regardless of the current replication role.\nThe effect of this mechanism is that in the default configuration, triggers do not fire on replicas. This is useful because if a trigger is used on the origin to propagate data between tables, then the replication system will also replicate the propagated data; so the trigger should not fire a second time on the replica, because that would lead to duplication. However, if a trigger is used for another",
    "metadata": {
      "doc_name": "sql-altertable",
      "section_title": "Note",
      "url": "https://www.postgresql.org/docs/16/sql-altertable.html"
    }
  },
  {
    "chunk_id": 10,
    "text": "“replica”mode, and triggers configured asENABLE ALWAYSwill fire regardless of the current replication role.\nThe effect of this mechanism is that in the default configuration, triggers do not fire on replicas. This is useful because if a trigger is used on the origin to propagate data between tables, then the replication system will also replicate the propagated data; so the trigger should not fire a second time on the replica, because that would lead to duplication. However, if a trigger is used for another purpose such as creating external alerts, then it might be appropriate to set it toENABLE ALWAYSso that it is also fired on replicas.\nWhen this command is applied to a partitioned table, the states of corresponding clone triggers in the partitions are updated too, unlessONLYis specified.\nThis command acquires aSHARE ROW EXCLUSIVElock.\nThese forms configure the firing of rewrite rules belonging to the table. A disabled rule is still known to the system, but is not applied during query rewriting. The semantics are as for disabled/enabled triggers. This configuration is ignored forON SELECTrules, which are always applied in order to keep views working even if the current session is in a non-default replication role.\nThe rule firing mechanism is also affected by the configuration variablesession_replication_role, analogous to triggers as described above.\nThese forms control the application of row security policies belonging to the table. If enabled and no policies exist for the table, then a default-deny policy is applied. Note that policies can exist for a table even if row-level security is disabled. In this case, the policies willnotbe applied and the policies will be ignored. See alsoCREATE POLICY.\nThese forms control the application of row security policies belonging to the table when the user is the table owner. If enabled, row-level security policies will be applied when the user is the table owner. If disabled (the default) then row-level security will not be applied when the user is the table owner. See alsoCREATE POLICY.\nThis form selects the default index for futureCLUSTERoperations. It does not actually re-cluster the table.\nChanging cluster options acquires aSHARE UPDATE EXCLUSIVElock.\nThis form removes the most recently usedCLUSTERindex specification from the table. This affects future cluster operations that don't specify an index.\nChanging cluster options acquires aSHARE UPDATE EXCLUSIVElock.\nBackward-compatible syntax for removing theoidsystem column. Asoidsystem columns cannot be added anymore, this never has an effect.",
    "metadata": {
      "doc_name": "sql-altertable",
      "section_title": "Note",
      "url": "https://www.postgresql.org/docs/16/sql-altertable.html"
    }
  },
  {
    "chunk_id": 11,
    "text": "ICY.\nThis form selects the default index for futureCLUSTERoperations. It does not actually re-cluster the table.\nChanging cluster options acquires aSHARE UPDATE EXCLUSIVElock.\nThis form removes the most recently usedCLUSTERindex specification from the table. This affects future cluster operations that don't specify an index.\nChanging cluster options acquires aSHARE UPDATE EXCLUSIVElock.\nBackward-compatible syntax for removing theoidsystem column. Asoidsystem columns cannot be added anymore, this never has an effect.\nThis form changes the access method of the table by rewriting it. SeeChapter 63for more information.\nThis form changes the table's tablespace to the specified tablespace and moves the data file(s) associated with the table to the new tablespace. Indexes on the table, if any, are not moved; but they can be moved separately with additionalSET TABLESPACEcommands. When applied to a partitioned table, nothing is moved, but any partitions created afterwards withCREATE TABLE PARTITION OFwill use that tablespace, unless overridden by aTABLESPACEclause.\nAll tables in the current database in a tablespace can be moved by using theALL IN TABLESPACEform, which will lock all tables to be moved first and then move each one. This form also supportsOWNED BY, which will only move tables owned by the roles specified. If theNOWAIToption is specified then the command will fail if it is unable to acquire all of the locks required immediately. Note that system catalogs are not moved by this command; useALTER DATABASEor explicitALTER TABLEinvocations instead if desired. Theinformation_schemarelations are not considered part of the system catalogs and will be moved. See alsoCREATE TABLESPACE.\nThis form changes the table from unlogged to logged or vice-versa (seeUNLOGGED). It cannot be applied to a temporary table.\nThis also changes the persistence of any sequences linked to the table (for identity or serial columns). However, it is also possible to change the persistence of such sequences separately.\nThis form changes one or more storage parameters for the table. SeeStorage Parametersin theCREATE TABLEdocumentation for details on the available parameters. Note that the table contents will not be modified immediately by this command; depending on the parameter you might need to rewrite the table to get the desired effects. That can be done withVACUUM FULL,CLUSTERor one of the forms ofALTER TABLEthat forces a table rewrite. For planner related parameters, changes will take",
    "metadata": {
      "doc_name": "sql-altertable",
      "section_title": "Note",
      "url": "https://www.postgresql.org/docs/16/sql-altertable.html"
    }
  },
  {
    "chunk_id": 12,
    "text": "the persistence of such sequences separately.\nThis form changes one or more storage parameters for the table. SeeStorage Parametersin theCREATE TABLEdocumentation for details on the available parameters. Note that the table contents will not be modified immediately by this command; depending on the parameter you might need to rewrite the table to get the desired effects. That can be done withVACUUM FULL,CLUSTERor one of the forms ofALTER TABLEthat forces a table rewrite. For planner related parameters, changes will take effect from the next time the table is locked so currently executing queries will not be affected.\nSHARE UPDATE EXCLUSIVElock will be taken for fillfactor, toast and autovacuum storage parameters, as well as the planner parameterparallel_workers.\nThis form resets one or more storage parameters to their defaults. As withSET, a table rewrite might be needed to update the table entirely.\nThis form adds the target table as a new child of the specified parent table. Subsequently, queries against the parent will include records of the target table. To be added as a child, the target table must already contain all the same columns as the parent (it could have additional columns, too). The columns must have matching data types, and if they haveNOT NULLconstraints in the parent then they must also haveNOT NULLconstraints in the child.\nThere must also be matching child-table constraints for allCHECKconstraints of the parent, except those marked non-inheritable (that is, created withALTER TABLE ... ADD CONSTRAINT ... NO INHERIT) in the parent, which are ignored; all child-table constraints matched must not be marked non-inheritable. CurrentlyUNIQUE,PRIMARY KEY, andFOREIGN KEYconstraints are not considered, but this might change in the future.\nThis form removes the target table from the list of children of the specified parent table. Queries against the parent table will no longer include records drawn from the target table.\nThis form links the table to a composite type as thoughCREATE TABLE OFhad formed it. The table's list of column names and types must precisely match that of the composite type. The table must not inherit from any other table. These restrictions ensure thatCREATE TABLE OFwould permit an equivalent table definition.\nThis form dissociates a typed table from its type.\nThis form changes the owner of the table, sequence, view, materialized view, or foreign table to the specified user.\nThis form changes the information which is written to the write-ahead log to identify rows which are updated",
    "metadata": {
      "doc_name": "sql-altertable",
      "section_title": "Note",
      "url": "https://www.postgresql.org/docs/16/sql-altertable.html"
    }
  },
  {
    "chunk_id": 13,
    "text": "formed it. The table's list of column names and types must precisely match that of the composite type. The table must not inherit from any other table. These restrictions ensure thatCREATE TABLE OFwould permit an equivalent table definition.\nThis form dissociates a typed table from its type.\nThis form changes the owner of the table, sequence, view, materialized view, or foreign table to the specified user.\nThis form changes the information which is written to the write-ahead log to identify rows which are updated or deleted. In most cases, the old value of each column is only logged if it differs from the new value; however, if the old value is stored externally, it is always logged regardless of whether it changed. This option has no effect except when logical replication is in use.\nRecords the old values of the columns of the primary key, if any. This is the default for non-system tables.\nRecords the old values of the columns covered by the named index, that must be unique, not partial, not deferrable, and include only columns markedNOT NULL. If this index is dropped, the behavior is the same asNOTHING.\nRecords the old values of all columns in the row.\nRecords no information about the old row. This is the default for system tables.\nTheRENAMEforms change the name of a table (or an index, sequence, view, materialized view, or foreign table), the name of an individual column in a table, or the name of a constraint of the table. When renaming a constraint that has an underlying index, the index is renamed as well. There is no effect on the stored data.\nThis form moves the table into another schema. Associated indexes, constraints, and sequences owned by table columns are moved as well.\nThis form attaches an existing table (which might itself be partitioned) as a partition of the target table. The table can be attached as a partition for specific values usingFOR VALUESor as a default partition by usingDEFAULT. For each index in the target table, a corresponding one will be created in the attached table; or, if an equivalent index already exists, it will be attached to the target table's index, as ifALTER INDEX ATTACH PARTITIONhad been executed. Note that if the existing table is a foreign table, it is currently not allowed to attach the table as a partition of the target table if there areUNIQUEindexes on the target table. (See alsoCREATE FOREIGN TABLE.) For each user-defined",
    "metadata": {
      "doc_name": "sql-altertable",
      "section_title": "Note",
      "url": "https://www.postgresql.org/docs/16/sql-altertable.html"
    }
  },
  {
    "chunk_id": 14,
    "text": "For each index in the target table, a corresponding one will be created in the attached table; or, if an equivalent index already exists, it will be attached to the target table's index, as ifALTER INDEX ATTACH PARTITIONhad been executed. Note that if the existing table is a foreign table, it is currently not allowed to attach the table as a partition of the target table if there areUNIQUEindexes on the target table. (See alsoCREATE FOREIGN TABLE.) For each user-defined row-level trigger that exists in the target table, a corresponding one is created in the attached table.\nA partition usingFOR VALUESuses same syntax forpartition_bound_specasCREATE TABLE. The partition bound specification must correspond to the partitioning strategy and partition key of the target table. The table to be attached must have all the same columns as the target table and no more; moreover, the column types must also match. Also, it must have all theNOT NULLandCHECKconstraints of the target table, not markedNO INHERIT. CurrentlyFOREIGN KEYconstraints are not considered.UNIQUEandPRIMARY KEYconstraints from the parent table will be created in the partition, if they don't already exist.\nIf the new partition is a regular table, a full table scan is performed to check that existing rows in the table do not violate the partition constraint. It is possible to avoid this scan by adding a validCHECKconstraint to the table that allows only rows satisfying the desired partition constraint before running this command. TheCHECKconstraint will be used to determine that the table need not be scanned to validate the partition constraint. This does not work, however, if any of the partition keys is an expression and the partition does not acceptNULLvalues. If attaching a list partition that will not acceptNULLvalues, also add aNOT NULLconstraint to the partition key column, unless it's an expression.\nIf the new partition is a foreign table, nothing is done to verify that all the rows in the foreign table obey the partition constraint. (See the discussion inCREATE FOREIGN TABLEabout constraints on the foreign table.)\nWhen a table has a default partition, defining a new partition changes the partition constraint for the default partition. The default partition can't contain any rows that would need to be moved to the new partition, and will be scanned to verify that none are present. This scan, like the scan of the new partition, can be avoided if an appropriateCHECKconstraint is present. Also like the scan of the new partition, it",
    "metadata": {
      "doc_name": "sql-altertable",
      "section_title": "Note",
      "url": "https://www.postgresql.org/docs/16/sql-altertable.html"
    }
  },
  {
    "chunk_id": 15,
    "text": "constraint. (See the discussion inCREATE FOREIGN TABLEabout constraints on the foreign table.)\nWhen a table has a default partition, defining a new partition changes the partition constraint for the default partition. The default partition can't contain any rows that would need to be moved to the new partition, and will be scanned to verify that none are present. This scan, like the scan of the new partition, can be avoided if an appropriateCHECKconstraint is present. Also like the scan of the new partition, it is always skipped when the default partition is a foreign table.\nAttaching a partition acquires aSHARE UPDATE EXCLUSIVElock on the parent table, in addition to theACCESS EXCLUSIVElocks on the table being attached and on the default partition (if any).\nFurther locks must also be held on all sub-partitions if the table being attached is itself a partitioned table. Likewise if the default partition is itself a partitioned table. The locking of the sub-partitions can be avoided by adding aCHECKconstraint as described inSection 5.11.2.2.\nThis form detaches the specified partition of the target table. The detached partition continues to exist as a standalone table, but no longer has any ties to the table from which it was detached. Any indexes that were attached to the target table's indexes are detached. Any triggers that were created as clones of those in the target table are removed.SHARElock is obtained on any tables that reference this partitioned table in foreign key constraints.\nIfCONCURRENTLYis specified, it runs using a reduced lock level to avoid blocking other sessions that might be accessing the partitioned table. In this mode, two transactions are used internally. During the first transaction, aSHARE UPDATE EXCLUSIVElock is taken on both parent table and partition, and the partition is marked as undergoing detach; at that point, the transaction is committed and all other transactions using the partitioned table are waited for. Once all those transactions have completed, the second transaction acquiresSHARE UPDATE EXCLUSIVEon the partitioned table andACCESS EXCLUSIVEon the partition, and the detach process completes. ACHECKconstraint that duplicates the partition constraint is added to the partition.CONCURRENTLYcannot be run in a transaction block and is not allowed if the partitioned table contains a default partition.\nIfFINALIZEis specified, a previousDETACH CONCURRENTLYinvocation that was canceled or interrupted is completed. At most one partition in a partitioned table can be pending detach at a time.",
    "metadata": {
      "doc_name": "sql-altertable",
      "section_title": "Note",
      "url": "https://www.postgresql.org/docs/16/sql-altertable.html"
    }
  },
  {
    "chunk_id": 16,
    "text": "SHARE UPDATE EXCLUSIVEon the partitioned table andACCESS EXCLUSIVEon the partition, and the detach process completes. ACHECKconstraint that duplicates the partition constraint is added to the partition.CONCURRENTLYcannot be run in a transaction block and is not allowed if the partitioned table contains a default partition.\nIfFINALIZEis specified, a previousDETACH CONCURRENTLYinvocation that was canceled or interrupted is completed. At most one partition in a partitioned table can be pending detach at a time.\nAll the forms of ALTER TABLE that act on a single table, exceptRENAME,SET SCHEMA,ATTACH PARTITION, andDETACH PARTITIONcan be combined into a list of multiple alterations to be applied together. For example, it is possible to add several columns and/or alter the type of several columns in a single command. This is particularly useful with large tables, since only one pass over the table need be made.\nYou must own the table to useALTER TABLE. To change the schema or tablespace of a table, you must also haveCREATEprivilege on the new schema or tablespace. To add the table as a new child of a parent table, you must own the parent table as well. Also, to attach a table as a new partition of the table, you must own the table being attached. To alter the owner, you must be able toSET ROLEto the new owning role, and that role must haveCREATEprivilege on the table's schema. (These restrictions enforce that altering the owner doesn't do anything you couldn't do by dropping and recreating the table. However, a superuser can alter ownership of any table anyway.) To add a column or alter a column type or use theOFclause, you must also haveUSAGEprivilege on the data type.",
    "metadata": {
      "doc_name": "sql-altertable",
      "section_title": "Note",
      "url": "https://www.postgresql.org/docs/16/sql-altertable.html"
    }
  },
  {
    "chunk_id": 17,
    "text": "Do not throw an error if the table does not exist. A notice is issued in this case.\nThe name (optionally schema-qualified) of an existing table to alter. IfONLYis specified before the table name, only that table is altered. IfONLYis not specified, the table and all its descendant tables (if any) are altered. Optionally,*can be specified after the table name to explicitly indicate that descendant tables are included.\nName of a new or existing column.\nNew name for an existing column.\nNew name for the table.\nData type of the new column, or new data type for an existing column.\nNew table constraint for the table.\nName of a new or existing constraint.\nAutomatically drop objects that depend on the dropped column or constraint (for example, views referencing the column), and in turn all objects that depend on those objects (seeSection 5.14).\nRefuse to drop the column or constraint if there are any dependent objects. This is the default behavior.\nName of a single trigger to disable or enable.\nDisable or enable all triggers belonging to the table. (This requires superuser privilege if any of the triggers are internally generated constraint triggers, such as those that are used to implement foreign key constraints or deferrable uniqueness and exclusion constraints.)\nDisable or enable all triggers belonging to the table except for internally generated constraint triggers, such as those that are used to implement foreign key constraints or deferrable uniqueness and exclusion constraints.\nThe name of an existing index.\nThe name of a table storage parameter.\nThe new value for a table storage parameter. This might be a number or a word depending on the parameter.\nA parent table to associate or de-associate with this table.\nThe user name of the new owner of the table.\nThe name of the access method to which the table will be converted.\nThe name of the tablespace to which the table will be moved.\nThe name of the schema to which the table will be moved.\nThe name of the table to attach as a new partition or to detach from this table.\nThe partition bound specification for a new partition. Refer toCREATE TABLEfor more details on the syntax of the same.",
    "metadata": {
      "doc_name": "sql-altertable",
      "section_title": "Parameters",
      "url": "https://www.postgresql.org/docs/16/sql-altertable.html"
    }
  },
  {
    "chunk_id": 18,
    "text": "The key wordCOLUMNis noise and can be omitted.\nWhen a column is added withADD COLUMNand a non-volatileDEFAULTis specified, the default is evaluated at the time of the statement and the result stored in the table's metadata. That value will be used for the column for all existing rows. If noDEFAULTis specified, NULL is used. In neither case is a rewrite of the table required.\nAdding a column with a volatileDEFAULTor changing the type of an existing column will require the entire table and its indexes to be rewritten. As an exception, when changing the type of an existing column, if theUSINGclause does not change the column contents and the old type is either binary coercible to the new type or an unconstrained domain over the new type, a table rewrite is not needed. However, indexes must always be rebuilt unless the system can verify that the new index would be logically equivalent to the existing one. For example, if the collation for a column has been changed, an index rebuild is always required because the new sort order might be different. However, in the absence of a collation change, a column can be changed fromtexttovarchar(or vice versa) without rebuilding the indexes because these data types sort identically. Table and/or index rebuilds may take a significant amount of time for a large table; and will temporarily require as much as double the disk space.\nAdding aCHECKorNOT NULLconstraint requires scanning the table to verify that existing rows meet the constraint, but does not require a table rewrite.\nSimilarly, when attaching a new partition it may be scanned to verify that existing rows meet the partition constraint.\nThe main reason for providing the option to specify multiple changes in a singleALTER TABLEis that multiple table scans or rewrites can thereby be combined into a single pass over the table.\nScanning a large table to verify a new foreign key or check constraint can take a long time, and other updates to the table are locked out until theALTER TABLE ADD CONSTRAINTcommand is committed. The main purpose of theNOT VALIDconstraint option is to reduce the impact of adding a constraint on concurrent updates. WithNOT VALID, theADD CONSTRAINTcommand does not scan the table and can be committed immediately. After that, aVALIDATE CONSTRAINTcommand can be issued to verify that existing rows satisfy the constraint. The validation step does not need to lock out concurrent updates, since it knows that other transactions will be enforcing the constraint for rows that they insert or update",
    "metadata": {
      "doc_name": "sql-altertable",
      "section_title": "Notes",
      "url": "https://www.postgresql.org/docs/16/sql-altertable.html"
    }
  },
  {
    "chunk_id": 19,
    "text": "theALTER TABLE ADD CONSTRAINTcommand is committed. The main purpose of theNOT VALIDconstraint option is to reduce the impact of adding a constraint on concurrent updates. WithNOT VALID, theADD CONSTRAINTcommand does not scan the table and can be committed immediately. After that, aVALIDATE CONSTRAINTcommand can be issued to verify that existing rows satisfy the constraint. The validation step does not need to lock out concurrent updates, since it knows that other transactions will be enforcing the constraint for rows that they insert or update; only pre-existing rows need to be checked. Hence, validation acquires only aSHARE UPDATE EXCLUSIVElock on the table being altered. (If the constraint is a foreign key then aROW SHARElock is also required on the table referenced by the constraint.) In addition to improving concurrency, it can be useful to useNOT VALIDandVALIDATE CONSTRAINTin cases where the table is known to contain pre-existing violations. Once the constraint is in place, no new violations can be inserted, and the existing problems can be corrected at leisure untilVALIDATE CONSTRAINTfinally succeeds.\nTheDROP COLUMNform does not physically remove the column, but simply makes it invisible to SQL operations. Subsequent insert and update operations in the table will store a null value for the column. Thus, dropping a column is quick but it will not immediately reduce the on-disk size of your table, as the space occupied by the dropped column is not reclaimed. The space will be reclaimed over time as existing rows are updated.\nTo force immediate reclamation of space occupied by a dropped column, you can execute one of the forms ofALTER TABLEthat performs a rewrite of the whole table. This results in reconstructing each row with the dropped column replaced by a null value.\nThe rewriting forms ofALTER TABLEare not MVCC-safe. After a table rewrite, the table will appear empty to concurrent transactions, if they are using a snapshot taken before the rewrite occurred. SeeSection 13.6for more details.\nTheUSINGoption ofSET DATA TYPEcan actually specify any expression involving the old values of the row; that is, it can refer to other columns as well as the one being converted. This allows very general conversions to be done with theSET DATA TYPEsyntax. Because of this flexibility, theUSINGexpression is not applied to the column's default value (if any); the result might not be a constant expression as required for a default. This means that when there is no implicit or assignment cast from old to new type",
    "metadata": {
      "doc_name": "sql-altertable",
      "section_title": "Notes",
      "url": "https://www.postgresql.org/docs/16/sql-altertable.html"
    }
  },
  {
    "chunk_id": 20,
    "text": "SET DATA TYPEcan actually specify any expression involving the old values of the row; that is, it can refer to other columns as well as the one being converted. This allows very general conversions to be done with theSET DATA TYPEsyntax. Because of this flexibility, theUSINGexpression is not applied to the column's default value (if any); the result might not be a constant expression as required for a default. This means that when there is no implicit or assignment cast from old to new type,SET DATA TYPEmight fail to convert the default even though aUSINGclause is supplied. In such cases, drop the default withDROP DEFAULT, perform theALTER TYPE, and then useSET DEFAULTto add a suitable new default. Similar considerations apply to indexes and constraints involving the column.\nIf a table has any descendant tables, it is not permitted to add, rename, or change the type of a column in the parent table without doing the same to the descendants. This ensures that the descendants always have columns matching the parent. Similarly, aCHECKconstraint cannot be renamed in the parent without also renaming it in all descendants, so thatCHECKconstraints also match between the parent and its descendants. (That restriction does not apply to index-based constraints, however.) Also, because selecting from the parent also selects from its descendants, a constraint on the parent cannot be marked valid unless it is also marked valid for those descendants. In all of these cases,ALTER TABLE ONLYwill be rejected.\nA recursiveDROP COLUMNoperation will remove a descendant table's column only if the descendant does not inherit that column from any other parents and never had an independent definition of the column. A nonrecursiveDROP COLUMN(i.e.,ALTER TABLE ONLY ... DROP COLUMN) never removes any descendant columns, but instead marks them as independently defined rather than inherited. A nonrecursiveDROP COLUMNcommand will fail for a partitioned table, because all partitions of a table must have the same columns as the partitioning root.\nThe actions for identity columns (ADD GENERATED,SETetc.,DROP IDENTITY), as well as the actionsCLUSTER,OWNER, andTABLESPACEnever recurse to descendant tables; that is, they always act as thoughONLYwere specified. Actions affecting trigger states recurse to partitions of partitioned tables (unlessONLYis specified), but never to traditional-inheritance descendants. Adding a constraint recurses only forCHECKconstraints that are not markedNO INHERIT.\nChanging any part of a system catalog table is not permitted.\nRefer toCREATE TABLE",
    "metadata": {
      "doc_name": "sql-altertable",
      "section_title": "Notes",
      "url": "https://www.postgresql.org/docs/16/sql-altertable.html"
    }
  },
  {
    "chunk_id": 21,
    "text": "ADD GENERATED,SETetc.,DROP IDENTITY), as well as the actionsCLUSTER,OWNER, andTABLESPACEnever recurse to descendant tables; that is, they always act as thoughONLYwere specified. Actions affecting trigger states recurse to partitions of partitioned tables (unlessONLYis specified), but never to traditional-inheritance descendants. Adding a constraint recurses only forCHECKconstraints that are not markedNO INHERIT.\nChanging any part of a system catalog table is not permitted.\nRefer toCREATE TABLEfor a further description of valid parameters.Chapter 5has further information on inheritance.",
    "metadata": {
      "doc_name": "sql-altertable",
      "section_title": "Notes",
      "url": "https://www.postgresql.org/docs/16/sql-altertable.html"
    }
  },
  {
    "chunk_id": 22,
    "text": "To add a column of typevarcharto a table:\n\n\nCODE:\n\nALTER TABLE distributors ADD COLUMN address varchar(30);\n\nThat will cause all existing rows in the table to be filled with null values for the new column.\nTo add a column with a non-null default:\n\n\nCODE:\n\nALTER TABLE measurements\n  ADD COLUMN mtime timestamp with time zone DEFAULT now();\n\nExisting rows will be filled with the current time as the value of the new column, and then new rows will receive the time of their insertion.\nTo add a column and fill it with a value different from the default to be used later:\n\n\nCODE:\n\nALTER TABLE transactions\n  ADD COLUMN status varchar(30) DEFAULT 'old',\n  ALTER COLUMN status SET default 'current';\n\nExisting rows will be filled withold, but then the default for subsequent commands will becurrent. The effects are the same as if the two sub-commands had been issued in separateALTER TABLEcommands.\nTo drop a column from a table:\n\n\nCODE:\n\nALTER TABLE distributors DROP COLUMN address RESTRICT;\n\nTo change the types of two existing columns in one operation:\n\n\nCODE:\n\nALTER TABLE distributors\n    ALTER COLUMN address TYPE varchar(80),\n    ALTER COLUMN name TYPE varchar(100);\n\nTo change an integer column containing Unix timestamps totimestamp with time zonevia aUSINGclause:\n\n\nCODE:\n\nALTER TABLE foo\n    ALTER COLUMN foo_timestamp SET DATA TYPE timestamp with time zone\n    USING\n        timestamp with time zone 'epoch' + foo_timestamp * interval '1 second';\n\nThe same, when the column has a default expression that won't automatically cast to the new data type:\n\n\nCODE:\n\nALTER TABLE foo\n    ALTER COLUMN foo_timestamp DROP DEFAULT,\n    ALTER COLUMN foo_timestamp TYPE timestamp with time zone\n    USING\n        timestamp with time zone 'epoch' + foo_timestamp * interval '1 second',\n    ALTER COLUMN foo_timestamp SET DEFAULT now();\n\nTo rename an existing column:\n\n\nCODE:\n\nALTER TABLE distributors RENAME COLUMN address TO city;\n\nTo rename an existing table:\n\n\nCODE:\n\nALTER TABLE distributors RENAME TO suppliers;\n\nTo rename an existing constraint:\n\n\nCODE:\n\nALTER TABLE distributors RENAME CONSTRAINT zipchk TO zip_check;\n\nTo add a not-null constraint to a column:\n\n\nCODE:\n\nALTER TABLE distributors ALTER COLUMN street SET NOT NULL;\n\nTo remove a not-null constraint from a column:\n\n\nCODE:\n\nALTER TABLE distributors ALTER COLUMN street DROP NOT NULL;\n\nTo add a check constraint to a table and all its children:\n\n\nCODE:\n\nALTER TABLE distributors ADD CONSTRAINT zipchk CHECK (char_length(zip",
    "metadata": {
      "doc_name": "sql-altertable",
      "section_title": "Examples",
      "url": "https://www.postgresql.org/docs/16/sql-altertable.html"
    }
  },
  {
    "chunk_id": 23,
    "text": ":\n\nALTER TABLE distributors RENAME TO suppliers;\n\nTo rename an existing constraint:\n\n\nCODE:\n\nALTER TABLE distributors RENAME CONSTRAINT zipchk TO zip_check;\n\nTo add a not-null constraint to a column:\n\n\nCODE:\n\nALTER TABLE distributors ALTER COLUMN street SET NOT NULL;\n\nTo remove a not-null constraint from a column:\n\n\nCODE:\n\nALTER TABLE distributors ALTER COLUMN street DROP NOT NULL;\n\nTo add a check constraint to a table and all its children:\n\n\nCODE:\n\nALTER TABLE distributors ADD CONSTRAINT zipchk CHECK (char_length(zipcode) = 5);\n\nTo add a check constraint only to a table and not to its children:\n\n\nCODE:\n\nALTER TABLE distributors ADD CONSTRAINT zipchk CHECK (char_length(zipcode) = 5) NO INHERIT;\n\n(The check constraint will not be inherited by future children, either.)\nTo remove a check constraint from a table and all its children:\n\n\nCODE:\n\nALTER TABLE distributors DROP CONSTRAINT zipchk;\n\nTo remove a check constraint from one table only:\n\n\nCODE:\n\nALTER TABLE ONLY distributors DROP CONSTRAINT zipchk;\n\n(The check constraint remains in place for any child tables.)\nTo add a foreign key constraint to a table:\n\n\nCODE:\n\nALTER TABLE distributors ADD CONSTRAINT distfk FOREIGN KEY (address) REFERENCES addresses (address);\n\nTo add a foreign key constraint to a table with the least impact on other work:\n\n\nCODE:\n\nALTER TABLE distributors ADD CONSTRAINT distfk FOREIGN KEY (address) REFERENCES addresses (address) NOT VALID;\nALTER TABLE distributors VALIDATE CONSTRAINT distfk;\n\nTo add a (multicolumn) unique constraint to a table:\n\n\nCODE:\n\nALTER TABLE distributors ADD CONSTRAINT dist_id_zipcode_key UNIQUE (dist_id, zipcode);\n\nTo add an automatically named primary key constraint to a table, noting that a table can only ever have one primary key:\n\n\nCODE:\n\nALTER TABLE distributors ADD PRIMARY KEY (dist_id);\n\nTo move a table to a different tablespace:\n\n\nCODE:\n\nALTER TABLE distributors SET TABLESPACE fasttablespace;\n\nTo move a table to a different schema:\n\n\nCODE:\n\nALTER TABLE myschema.distributors SET SCHEMA yourschema;\n\nTo recreate a primary key constraint, without blocking updates while the index is rebuilt:\n\n\nCODE:\n\nCREATE UNIQUE INDEX CONCURRENTLY dist_id_temp_idx ON distributors (dist_id);\nALTER TABLE distributors DROP CONSTRAINT distributors_pkey,\n    ADD CONSTRAINT distributors_pkey PRIMARY KEY USING INDEX dist_id_temp_idx;\n\nTo attach a partition to a range-partitioned table:\n\n\nCODE:\n\nALTER TABLE measurement\n    ATTACH PARTITION measurement_y2016m07 FOR VALUES FROM ('2016-",
    "metadata": {
      "doc_name": "sql-altertable",
      "section_title": "Examples",
      "url": "https://www.postgresql.org/docs/16/sql-altertable.html"
    }
  },
  {
    "chunk_id": 24,
    "text": "SET SCHEMA yourschema;\n\nTo recreate a primary key constraint, without blocking updates while the index is rebuilt:\n\n\nCODE:\n\nCREATE UNIQUE INDEX CONCURRENTLY dist_id_temp_idx ON distributors (dist_id);\nALTER TABLE distributors DROP CONSTRAINT distributors_pkey,\n    ADD CONSTRAINT distributors_pkey PRIMARY KEY USING INDEX dist_id_temp_idx;\n\nTo attach a partition to a range-partitioned table:\n\n\nCODE:\n\nALTER TABLE measurement\n    ATTACH PARTITION measurement_y2016m07 FOR VALUES FROM ('2016-07-01') TO ('2016-08-01');\n\nTo attach a partition to a list-partitioned table:\n\n\nCODE:\n\nALTER TABLE cities\n    ATTACH PARTITION cities_ab FOR VALUES IN ('a', 'b');\n\nTo attach a partition to a hash-partitioned table:\n\n\nCODE:\n\nALTER TABLE orders\n    ATTACH PARTITION orders_p4 FOR VALUES WITH (MODULUS 4, REMAINDER 3);\n\nTo attach a default partition to a partitioned table:\n\n\nCODE:\n\nALTER TABLE cities\n    ATTACH PARTITION cities_partdef DEFAULT;\n\nTo detach a partition from a partitioned table:\n\n\nCODE:\n\nALTER TABLE measurement\n    DETACH PARTITION measurement_y2015m12;",
    "metadata": {
      "doc_name": "sql-altertable",
      "section_title": "Examples",
      "url": "https://www.postgresql.org/docs/16/sql-altertable.html"
    }
  },
  {
    "chunk_id": 25,
    "text": "The formsADD(withoutUSING INDEX),DROP [COLUMN],DROP IDENTITY,RESTART,SET DEFAULT,SET DATA TYPE(withoutUSING),SET GENERATED, andSETsequence_optionconform with the SQL standard. The other forms arePostgreSQLextensions of the SQL standard. Also, the ability to specify more than one manipulation in a singleALTER TABLEcommand is an extension.\nALTER TABLE DROP COLUMNcan be used to drop the only column of a table, leaving a zero-column table. This is an extension of SQL, which disallows zero-column tables.",
    "metadata": {
      "doc_name": "sql-altertable",
      "section_title": "Compatibility",
      "url": "https://www.postgresql.org/docs/16/sql-altertable.html"
    }
  },
  {
    "chunk_id": 0,
    "text": "ANALYZE — collect statistics about a database",
    "metadata": {
      "doc_name": "sql-analyze",
      "section_title": "ANALYZE",
      "url": "https://www.postgresql.org/docs/16/sql-analyze.html"
    }
  },
  {
    "chunk_id": 1,
    "text": "CODE:\n\nANALYZE [ ( option [, ...] ) ] [ table_and_columns [, ...] ]\nANALYZE [ VERBOSE ] [ table_and_columns [, ...] ]\n\nwhere option can be one of:\n\n    VERBOSE [ boolean ]\n    SKIP_LOCKED [ boolean ]\n    BUFFER_USAGE_LIMIT size\n\nand table_and_columns is:\n\n    table_name [ ( column_name [, ...] ) ]",
    "metadata": {
      "doc_name": "sql-analyze",
      "section_title": "Synopsis",
      "url": "https://www.postgresql.org/docs/16/sql-analyze.html"
    }
  },
  {
    "chunk_id": 2,
    "text": "ANALYZEcollects statistics about the contents of tables in the database, and stores the results in thepg_statisticsystem catalog. Subsequently, the query planner uses these statistics to help determine the most efficient execution plans for queries.\nWithout atable_and_columnslist,ANALYZEprocesses every table and materialized view in the current database that the current user has permission to analyze. With a list,ANALYZEprocesses only those table(s). It is further possible to give a list of column names for a table, in which case only the statistics for those columns are collected.\nWhen the option list is surrounded by parentheses, the options can be written in any order. The parenthesized syntax was added inPostgreSQL11; the unparenthesized syntax is deprecated.",
    "metadata": {
      "doc_name": "sql-analyze",
      "section_title": "Description",
      "url": "https://www.postgresql.org/docs/16/sql-analyze.html"
    }
  },
  {
    "chunk_id": 3,
    "text": "Enables display of progress messages.\nSpecifies thatANALYZEshould not wait for any conflicting locks to be released when beginning work on a relation: if a relation cannot be locked immediately without waiting, the relation is skipped. Note that even with this option,ANALYZEmay still block when opening the relation's indexes or when acquiring sample rows from partitions, table inheritance children, and some types of foreign tables. Also, whileANALYZEordinarily processes all partitions of specified partitioned tables, this option will causeANALYZEto skip all partitions if there is a conflicting lock on the partitioned table.\nSpecifies theBuffer Access Strategyring buffer size forANALYZE. This size is used to calculate the number of shared buffers which will be reused as part of this strategy.0disables use of aBuffer Access Strategy. When this option is not specified,ANALYZEuses the value fromvacuum_buffer_usage_limit. Higher settings can allowANALYZEto run more quickly, but having too large a setting may cause too many other useful pages to be evicted from shared buffers. The minimum value is128 kBand the maximum value is16 GB.\nSpecifies whether the selected option should be turned on or off. You can writeTRUE,ON, or1to enable the option, andFALSE,OFF, or0to disable it. Thebooleanvalue can also be omitted, in which caseTRUEis assumed.\nSpecifies an amount of memory in kilobytes. Sizes may also be specified as a string containing the numerical size followed by any one of the following memory units:B(bytes),kB(kilobytes),MB(megabytes),GB(gigabytes), orTB(terabytes).\nThe name (possibly schema-qualified) of a specific table to analyze. If omitted, all regular tables, partitioned tables, and materialized views in the current database are analyzed (but not foreign tables). If the specified table is a partitioned table, both the inheritance statistics of the partitioned table as a whole and statistics of the individual partitions are updated.\nThe name of a specific column to analyze. Defaults to all columns.",
    "metadata": {
      "doc_name": "sql-analyze",
      "section_title": "Parameters",
      "url": "https://www.postgresql.org/docs/16/sql-analyze.html"
    }
  },
  {
    "chunk_id": 4,
    "text": "WhenVERBOSEis specified,ANALYZEemits progress messages to indicate which table is currently being processed. Various statistics about the tables are printed as well.",
    "metadata": {
      "doc_name": "sql-analyze",
      "section_title": "Outputs",
      "url": "https://www.postgresql.org/docs/16/sql-analyze.html"
    }
  },
  {
    "chunk_id": 5,
    "text": "To analyze a table, one must ordinarily be the table's owner or a superuser. However, database owners are allowed to analyze all tables in their databases, except shared catalogs. (The restriction for shared catalogs means that a true database-wideANALYZEcan only be performed by a superuser.)ANALYZEwill skip over any tables that the calling user does not have permission to analyze.\nForeign tables are analyzed only when explicitly selected. Not all foreign data wrappers supportANALYZE. If the table's wrapper does not supportANALYZE, the command prints a warning and does nothing.\nIn the defaultPostgreSQLconfiguration, the autovacuum daemon (seeSection 25.1.6) takes care of automatic analyzing of tables when they are first loaded with data, and as they change throughout regular operation. When autovacuum is disabled, it is a good idea to runANALYZEperiodically, or just after making major changes in the contents of a table. Accurate statistics will help the planner to choose the most appropriate query plan, and thereby improve the speed of query processing. A common strategy for read-mostly databases is to runVACUUMandANALYZEonce a day during a low-usage time of day. (This will not be sufficient if there is heavy update activity.)\nANALYZErequires only a read lock on the target table, so it can run in parallel with other activity on the table.\nThe statistics collected byANALYZEusually include a list of some of the most common values in each column and a histogram showing the approximate data distribution in each column. One or both of these can be omitted ifANALYZEdeems them uninteresting (for example, in a unique-key column, there are no common values) or if the column data type does not support the appropriate operators. There is more information about the statistics inChapter 25.\nFor large tables,ANALYZEtakes a random sample of the table contents, rather than examining every row. This allows even very large tables to be analyzed in a small amount of time. Note, however, that the statistics are only approximate, and will change slightly each timeANALYZEis run, even if the actual table contents did not change. This might result in small changes in the planner's estimated costs shown byEXPLAIN. In rare situations, this non-determinism will cause the planner's choices of query",
    "metadata": {
      "doc_name": "sql-analyze",
      "section_title": "Notes",
      "url": "https://www.postgresql.org/docs/16/sql-analyze.html"
    }
  },
  {
    "chunk_id": 6,
    "text": "Etakes a random sample of the table contents, rather than examining every row. This allows even very large tables to be analyzed in a small amount of time. Note, however, that the statistics are only approximate, and will change slightly each timeANALYZEis run, even if the actual table contents did not change. This might result in small changes in the planner's estimated costs shown byEXPLAIN. In rare situations, this non-determinism will cause the planner's choices of query plans to change afterANALYZEis run. To avoid this, raise the amount of statistics collected byANALYZE, as described below.\nThe extent of analysis can be controlled by adjusting thedefault_statistics_targetconfiguration variable, or on a column-by-column basis by setting the per-column statistics target withALTER TABLE ... ALTER COLUMN ... SET STATISTICS. The target value sets the maximum number of entries in the most-common-value list and the maximum number of bins in the histogram. The default target value is 100, but this can be adjusted up or down to trade off accuracy of planner estimates against the time taken forANALYZEand the amount of space occupied inpg_statistic. In particular, setting the statistics target to zero disables collection of statistics for that column. It might be useful to do that for columns that are never used as part of theWHERE,GROUP BY, orORDER BYclauses of queries, since the planner will have no use for statistics on such columns.\nThe largest statistics target among the columns being analyzed determines the number of table rows sampled to prepare the statistics. Increasing the target causes a proportional increase in the time and space needed to doANALYZE.\nOne of the values estimated byANALYZEis the number of distinct values that appear in each column. Because only a subset of the rows are examined, this estimate can sometimes be quite inaccurate, even with the largest possible statistics target. If this inaccuracy leads to bad query plans, a more accurate value can be determined manually and then installed withALTER TABLE ... ALTER COLUMN ... SET (n_distinct = ...).\nIf the table being analyzed has inheritance children,ANALYZEgathers two sets of statistics: one on the rows of the parent table only, and a second including rows of both the parent table and all of its children. This second set of statistics is needed when planning queries that process the inheritance tree as a whole. The child tables themselves are not individually analyzed in this",
    "metadata": {
      "doc_name": "sql-analyze",
      "section_title": "Notes",
      "url": "https://www.postgresql.org/docs/16/sql-analyze.html"
    }
  },
  {
    "chunk_id": 7,
    "text": "more accurate value can be determined manually and then installed withALTER TABLE ... ALTER COLUMN ... SET (n_distinct = ...).\nIf the table being analyzed has inheritance children,ANALYZEgathers two sets of statistics: one on the rows of the parent table only, and a second including rows of both the parent table and all of its children. This second set of statistics is needed when planning queries that process the inheritance tree as a whole. The child tables themselves are not individually analyzed in this case. The autovacuum daemon, however, will only consider inserts or updates on the parent table itself when deciding whether to trigger an automatic analyze for that table. If that table is rarely inserted into or updated, the inheritance statistics will not be up to date unless you runANALYZEmanually.\nFor partitioned tables,ANALYZEgathers statistics by sampling rows from all partitions; in addition, it will recurse into each partition and update its statistics. Each leaf partition is analyzed only once, even with multi-level partitioning. No statistics are collected for only the parent table (without data from its partitions), because with partitioning it's guaranteed to be empty.\nThe autovacuum daemon does not process partitioned tables, nor does it process inheritance parents if only the children are ever modified. It is usually necessary to periodically run a manualANALYZEto keep the statistics of the table hierarchy up to date.\nIf any child tables or partitions are foreign tables whose foreign data wrappers do not supportANALYZE, those tables are ignored while gathering inheritance statistics.\nIf the table being analyzed is completely empty,ANALYZEwill not record new statistics for that table. Any existing statistics will be retained.\nEach backend runningANALYZEwill report its progress in thepg_stat_progress_analyzeview. SeeSection 28.4.1for details.",
    "metadata": {
      "doc_name": "sql-analyze",
      "section_title": "Notes",
      "url": "https://www.postgresql.org/docs/16/sql-analyze.html"
    }
  },
  {
    "chunk_id": 8,
    "text": "There is noANALYZEstatement in the SQL standard.",
    "metadata": {
      "doc_name": "sql-analyze",
      "section_title": "Compatibility",
      "url": "https://www.postgresql.org/docs/16/sql-analyze.html"
    }
  },
  {
    "chunk_id": 0,
    "text": "BEGIN — start a transaction block",
    "metadata": {
      "doc_name": "sql-begin",
      "section_title": "BEGIN",
      "url": "https://www.postgresql.org/docs/16/sql-begin.html"
    }
  },
  {
    "chunk_id": 1,
    "text": "CODE:\n\nBEGIN [ WORK | TRANSACTION ] [ transaction_mode [, ...] ]\n\nwhere transaction_mode is one of:\n\n    ISOLATION LEVEL { SERIALIZABLE | REPEATABLE READ | READ COMMITTED | READ UNCOMMITTED }\n    READ WRITE | READ ONLY\n    [ NOT ] DEFERRABLE",
    "metadata": {
      "doc_name": "sql-begin",
      "section_title": "Synopsis",
      "url": "https://www.postgresql.org/docs/16/sql-begin.html"
    }
  },
  {
    "chunk_id": 2,
    "text": "BEGINinitiates a transaction block, that is, all statements after aBEGINcommand will be executed in a single transaction until an explicitCOMMITorROLLBACKis given. By default (withoutBEGIN),PostgreSQLexecutes transactions in“autocommit”mode, that is, each statement is executed in its own transaction and a commit is implicitly performed at the end of the statement (if execution was successful, otherwise a rollback is done).\nStatements are executed more quickly in a transaction block, because transaction start/commit requires significant CPU and disk activity. Execution of multiple statements inside a transaction is also useful to ensure consistency when making several related changes: other sessions will be unable to see the intermediate states wherein not all the related updates have been done.\nIf the isolation level, read/write mode, or deferrable mode is specified, the new transaction has those characteristics, as ifSET TRANSACTIONwas executed.",
    "metadata": {
      "doc_name": "sql-begin",
      "section_title": "Description",
      "url": "https://www.postgresql.org/docs/16/sql-begin.html"
    }
  },
  {
    "chunk_id": 3,
    "text": "Optional key words. They have no effect.\nRefer toSET TRANSACTIONfor information on the meaning of the other parameters to this statement.",
    "metadata": {
      "doc_name": "sql-begin",
      "section_title": "Parameters",
      "url": "https://www.postgresql.org/docs/16/sql-begin.html"
    }
  },
  {
    "chunk_id": 4,
    "text": "START TRANSACTIONhas the same functionality asBEGIN.\nUseCOMMITorROLLBACKto terminate a transaction block.\nIssuingBEGINwhen already inside a transaction block will provoke a warning message. The state of the transaction is not affected. To nest transactions within a transaction block, use savepoints (seeSAVEPOINT).\nFor reasons of backwards compatibility, the commas between successivetransaction_modescan be omitted.",
    "metadata": {
      "doc_name": "sql-begin",
      "section_title": "Notes",
      "url": "https://www.postgresql.org/docs/16/sql-begin.html"
    }
  },
  {
    "chunk_id": 5,
    "text": "To begin a transaction block:\n\n\nCODE:\n\nBEGIN;",
    "metadata": {
      "doc_name": "sql-begin",
      "section_title": "Examples",
      "url": "https://www.postgresql.org/docs/16/sql-begin.html"
    }
  },
  {
    "chunk_id": 6,
    "text": "BEGINis aPostgreSQLlanguage extension. It is equivalent to the SQL-standard commandSTART TRANSACTION, whose reference page contains additional compatibility information.\nTheDEFERRABLEtransaction_modeis aPostgreSQLlanguage extension.\nIncidentally, theBEGINkey word is used for a different purpose in embedded SQL. You are advised to be careful about the transaction semantics when porting database applications.",
    "metadata": {
      "doc_name": "sql-begin",
      "section_title": "Compatibility",
      "url": "https://www.postgresql.org/docs/16/sql-begin.html"
    }
  },
  {
    "chunk_id": 0,
    "text": "COMMIT — commit the current transaction",
    "metadata": {
      "doc_name": "sql-commit",
      "section_title": "COMMIT",
      "url": "https://www.postgresql.org/docs/16/sql-commit.html"
    }
  },
  {
    "chunk_id": 1,
    "text": "CODE:\n\nCOMMIT [ WORK | TRANSACTION ] [ AND [ NO ] CHAIN ]",
    "metadata": {
      "doc_name": "sql-commit",
      "section_title": "Synopsis",
      "url": "https://www.postgresql.org/docs/16/sql-commit.html"
    }
  },
  {
    "chunk_id": 2,
    "text": "COMMITcommits the current transaction. All changes made by the transaction become visible to others and are guaranteed to be durable if a crash occurs.",
    "metadata": {
      "doc_name": "sql-commit",
      "section_title": "Description",
      "url": "https://www.postgresql.org/docs/16/sql-commit.html"
    }
  },
  {
    "chunk_id": 3,
    "text": "Optional key words. They have no effect.\nIfAND CHAINis specified, a new transaction is immediately started with the same transaction characteristics (seeSET TRANSACTION) as the just finished one. Otherwise, no new transaction is started.",
    "metadata": {
      "doc_name": "sql-commit",
      "section_title": "Parameters",
      "url": "https://www.postgresql.org/docs/16/sql-commit.html"
    }
  },
  {
    "chunk_id": 4,
    "text": "UseROLLBACKto abort a transaction.\nIssuingCOMMITwhen not inside a transaction does no harm, but it will provoke a warning message.COMMIT AND CHAINwhen not inside a transaction is an error.",
    "metadata": {
      "doc_name": "sql-commit",
      "section_title": "Notes",
      "url": "https://www.postgresql.org/docs/16/sql-commit.html"
    }
  },
  {
    "chunk_id": 5,
    "text": "To commit the current transaction and make all changes permanent:\n\n\nCODE:\n\nCOMMIT;",
    "metadata": {
      "doc_name": "sql-commit",
      "section_title": "Examples",
      "url": "https://www.postgresql.org/docs/16/sql-commit.html"
    }
  },
  {
    "chunk_id": 6,
    "text": "The commandCOMMITconforms to the SQL standard. The formCOMMIT TRANSACTIONis a PostgreSQL extension.",
    "metadata": {
      "doc_name": "sql-commit",
      "section_title": "Compatibility",
      "url": "https://www.postgresql.org/docs/16/sql-commit.html"
    }
  },
  {
    "chunk_id": 0,
    "text": "COPY — copy data between a file and a table",
    "metadata": {
      "doc_name": "sql-copy",
      "section_title": "COPY",
      "url": "https://www.postgresql.org/docs/16/sql-copy.html"
    }
  },
  {
    "chunk_id": 1,
    "text": "CODE:\n\nCOPY table_name [ ( column_name [, ...] ) ]\n    FROM { 'filename' | PROGRAM 'command' | STDIN }\n    [ [ WITH ] ( option [, ...] ) ]\n    [ WHERE condition ]\n\nCOPY { table_name [ ( column_name [, ...] ) ] | ( query ) }\n    TO { 'filename' | PROGRAM 'command' | STDOUT }\n    [ [ WITH ] ( option [, ...] ) ]\n\nwhere option can be one of:\n\n    FORMAT format_name\n    FREEZE [ boolean ]\n    DELIMITER 'delimiter_character'\n    NULL 'null_string'\n    DEFAULT 'default_string'\n    HEADER [ boolean | MATCH ]\n    QUOTE 'quote_character'\n    ESCAPE 'escape_character'\n    FORCE_QUOTE { ( column_name [, ...] ) | * }\n    FORCE_NOT_NULL ( column_name [, ...] )\n    FORCE_NULL ( column_name [, ...] )\n    ENCODING 'encoding_name'",
    "metadata": {
      "doc_name": "sql-copy",
      "section_title": "Synopsis",
      "url": "https://www.postgresql.org/docs/16/sql-copy.html"
    }
  },
  {
    "chunk_id": 2,
    "text": "COPYmoves data betweenPostgreSQLtables and standard file-system files.COPY TOcopies the contents of a tabletoa file, whileCOPY FROMcopies datafroma file to a table (appending the data to whatever is in the table already).COPY TOcan also copy the results of aSELECTquery.\nIf a column list is specified,COPY TOcopies only the data in the specified columns to the file. ForCOPY FROM, each field in the file is inserted, in order, into the specified column. Table columns not specified in theCOPY FROMcolumn list will receive their default values.\nCOPYwith a file name instructs thePostgreSQLserver to directly read from or write to a file. The file must be accessible by thePostgreSQLuser (the user ID the server runs as) and the name must be specified from the viewpoint of the server. WhenPROGRAMis specified, the server executes the given command and reads from the standard output of the program, or writes to the standard input of the program. The command must be specified from the viewpoint of the server, and be executable by thePostgreSQLuser. WhenSTDINorSTDOUTis specified, data is transmitted via the connection between the client and the server.\nEach backend runningCOPYwill report its progress in thepg_stat_progress_copyview. SeeSection 28.4.3for details.",
    "metadata": {
      "doc_name": "sql-copy",
      "section_title": "Description",
      "url": "https://www.postgresql.org/docs/16/sql-copy.html"
    }
  },
  {
    "chunk_id": 3,
    "text": "The name (optionally schema-qualified) of an existing table.\nAn optional list of columns to be copied. If no column list is specified, all columns of the table except generated columns will be copied.\nASELECT,VALUES,INSERT,UPDATE, orDELETEcommand whose results are to be copied. Note that parentheses are required around the query.\nForINSERT,UPDATEandDELETEqueries aRETURNINGclause must be provided, and the target relation must not have a conditional rule, nor anALSOrule, nor anINSTEADrule that expands to multiple statements.\nThe path name of the input or output file. An input file name can be an absolute or relative path, but an output file name must be an absolute path. Windows users might need to use anE''string and double any backslashes used in the path name.\nA command to execute. InCOPY FROM, the input is read from standard output of the command, and inCOPY TO, the output is written to the standard input of the command.\nNote that the command is invoked by the shell, so if you need to pass any arguments that come from an untrusted source, you must be careful to strip or escape any special characters that might have a special meaning for the shell. For security reasons, it is best to use a fixed command string, or at least avoid including any user input in it.\nSpecifies that input comes from the client application.\nSpecifies that output goes to the client application.\nSpecifies whether the selected option should be turned on or off. You can writeTRUE,ON, or1to enable the option, andFALSE,OFF, or0to disable it. Thebooleanvalue can also be omitted, in which caseTRUEis assumed.\nSelects the data format to be read or written:text,csv(Comma Separated Values), orbinary. The default istext.\nRequests copying the data with rows already frozen, just as they would be after running theVACUUM FREEZEcommand. This is intended as a performance option for initial data loading. Rows will be frozen only if the table being loaded has been created or truncated in the current subtransaction, there are no cursors open and there are no older snapshots held by this transaction. It is currently not possible to perform aCOPY FREEZEon a partitioned table.\nNote that all other sessions will immediately be able to see the data once it has been successfully loaded. This violates the normal rules of MVCC visibility and users should be",
    "metadata": {
      "doc_name": "sql-copy",
      "section_title": "Parameters",
      "url": "https://www.postgresql.org/docs/16/sql-copy.html"
    }
  },
  {
    "chunk_id": 4,
    "text": "This is intended as a performance option for initial data loading. Rows will be frozen only if the table being loaded has been created or truncated in the current subtransaction, there are no cursors open and there are no older snapshots held by this transaction. It is currently not possible to perform aCOPY FREEZEon a partitioned table.\nNote that all other sessions will immediately be able to see the data once it has been successfully loaded. This violates the normal rules of MVCC visibility and users should be aware of the potential problems this might cause.\nSpecifies the character that separates columns within each row (line) of the file. The default is a tab character in text format, a comma inCSVformat. This must be a single one-byte character. This option is not allowed when usingbinaryformat.\nSpecifies the string that represents a null value. The default is\\N(backslash-N) in text format, and an unquoted empty string inCSVformat. You might prefer an empty string even in text format for cases where you don't want to distinguish nulls from empty strings. This option is not allowed when usingbinaryformat.",
    "metadata": {
      "doc_name": "sql-copy",
      "section_title": "Parameters",
      "url": "https://www.postgresql.org/docs/16/sql-copy.html"
    }
  },
  {
    "chunk_id": 5,
    "text": "When usingCOPY FROM, any data item that matches this string will be stored as a null value, so you should make sure that you use the same string as you used withCOPY TO.\nSpecifies the string that represents a default value. Each time the string is found in the input file, the default value of the corresponding column will be used. This option is allowed only inCOPY FROM, and only when not usingbinaryformat.\nSpecifies that the file contains a header line with the names of each column in the file. On output, the first line contains the column names from the table. On input, the first line is discarded when this option is set totrue(or equivalent Boolean value). If this option is set toMATCH, the number and names of the columns in the header line must match the actual column names of the table, in order; otherwise an error is raised. This option is not allowed when usingbinaryformat. TheMATCHoption is only valid forCOPY FROMcommands.\nSpecifies the quoting character to be used when a data value is quoted. The default is double-quote. This must be a single one-byte character. This option is allowed only when usingCSVformat.\nSpecifies the character that should appear before a data character that matches theQUOTEvalue. The default is the same as theQUOTEvalue (so that the quoting character is doubled if it appears in the data). This must be a single one-byte character. This option is allowed only when usingCSVformat.\nForces quoting to be used for all non-NULLvalues in each specified column.NULLoutput is never quoted. If*is specified, non-NULLvalues will be quoted in all columns. This option is allowed only inCOPY TO, and only when usingCSVformat.\nDo not match the specified columns' values against the null string. In the default case where the null string is empty, this means that empty values will be read as zero-length strings rather than nulls, even when they are not quoted. This option is allowed only inCOPY FROM, and only when usingCSVformat.\nMatch the specified columns' values against the null string, even if it has been quoted, and if a match is found set the value toNULL. In the default case where the null string is empty, this converts a quoted empty string into NULL. This option is allowed only inCOPY FROM, and only when usingCSVformat.\nSpecifies that the file is encoded in theencoding_name. If this option is omitted, the current client encoding",
    "metadata": {
      "doc_name": "sql-copy",
      "section_title": "Note",
      "url": "https://www.postgresql.org/docs/16/sql-copy.html"
    }
  },
  {
    "chunk_id": 6,
    "text": "allowed only inCOPY FROM, and only when usingCSVformat.\nMatch the specified columns' values against the null string, even if it has been quoted, and if a match is found set the value toNULL. In the default case where the null string is empty, this converts a quoted empty string into NULL. This option is allowed only inCOPY FROM, and only when usingCSVformat.\nSpecifies that the file is encoded in theencoding_name. If this option is omitted, the current client encoding is used. See the Notes below for more details.\nThe optionalWHEREclause has the general form\n\n\nCODE:\n\nWHERE condition\n\nwhereconditionis any expression that evaluates to a result of typeboolean. Any row that does not satisfy this condition will not be inserted to the table. A row satisfies the condition if it returns true when the actual row values are substituted for any variable references.\nCurrently, subqueries are not allowed inWHEREexpressions, and the evaluation does not see any changes made by theCOPYitself (this matters when the expression contains calls toVOLATILEfunctions).",
    "metadata": {
      "doc_name": "sql-copy",
      "section_title": "Note",
      "url": "https://www.postgresql.org/docs/16/sql-copy.html"
    }
  },
  {
    "chunk_id": 7,
    "text": "On successful completion, aCOPYcommand returns a command tag of the form\n\n\nCODE:\n\nCOPY count\n\nThecountis the number of rows copied.",
    "metadata": {
      "doc_name": "sql-copy",
      "section_title": "Outputs",
      "url": "https://www.postgresql.org/docs/16/sql-copy.html"
    }
  },
  {
    "chunk_id": 8,
    "text": "psqlwill print this command tag only if the command was notCOPY ... TO STDOUT, or the equivalentpsqlmeta-command\\copy ... to stdout. This is to prevent confusing the command tag with the data that was just printed.",
    "metadata": {
      "doc_name": "sql-copy",
      "section_title": "Note",
      "url": "https://www.postgresql.org/docs/16/sql-copy.html"
    }
  },
  {
    "chunk_id": 9,
    "text": "COPY TOcan be used only with plain tables, not views, and does not copy rows from child tables or child partitions. For example,COPYtableTOcopies the same rows asSELECT * FROM ONLYtable. The syntaxCOPY (SELECT * FROMtable) TO ...can be used to dump all of the rows in an inheritance hierarchy, partitioned table, or view.\nCOPY FROMcan be used with plain, foreign, or partitioned tables or with views that haveINSTEAD OF INSERTtriggers.\nYou must have select privilege on the table whose values are read byCOPY TO, and insert privilege on the table into which values are inserted byCOPY FROM. It is sufficient to have column privileges on the column(s) listed in the command.\nIf row-level security is enabled for the table, the relevantSELECTpolicies will apply toCOPYtableTOstatements. Currently,COPY FROMis not supported for tables with row-level security. Use equivalentINSERTstatements instead.\nFiles named in aCOPYcommand are read or written directly by the server, not by the client application. Therefore, they must reside on or be accessible to the database server machine, not the client. They must be accessible to and readable or writable by thePostgreSQLuser (the user ID the server runs as), not the client. Similarly, the command specified withPROGRAMis executed directly by the server, not by the client application, must be executable by thePostgreSQLuser.COPYnaming a file or command is only allowed to database superusers or users who are granted one of the rolespg_read_server_files,pg_write_server_files, orpg_execute_server_program, since it allows reading or writing any file or running a program that the server has privileges to access.\nDo not confuseCOPYwith thepsqlinstruction\\copy.\\copyinvokesCOPY FROM STDINorCOPY TO STDOUT, and then fetches/stores the data in a file accessible to thepsqlclient. Thus, file accessibility and access rights depend on the client rather than the server when\\copyis used.\nIt is recommended that the file name used inCOPYalways be specified as an absolute path. This is enforced by the server in the case ofCOPY TO, but forCOPY FROMyou do have the option of reading from a file specified by a relative path. The path will be interpreted relative to the working directory of the server process (normally the cluster's data directory), not the client's working directory.\nExecuting a command withPROGRAMmight be restricted by the",
    "metadata": {
      "doc_name": "sql-copy",
      "section_title": "Notes",
      "url": "https://www.postgresql.org/docs/16/sql-copy.html"
    }
  },
  {
    "chunk_id": 10,
    "text": "rather than the server when\\copyis used.\nIt is recommended that the file name used inCOPYalways be specified as an absolute path. This is enforced by the server in the case ofCOPY TO, but forCOPY FROMyou do have the option of reading from a file specified by a relative path. The path will be interpreted relative to the working directory of the server process (normally the cluster's data directory), not the client's working directory.\nExecuting a command withPROGRAMmight be restricted by the operating system's access control mechanisms, such as SELinux.\nCOPY FROMwill invoke any triggers and check constraints on the destination table. However, it will not invoke rules.\nFor identity columns, theCOPY FROMcommand will always write the column values provided in the input data, like theINSERToptionOVERRIDING SYSTEM VALUE.\nCOPYinput and output is affected byDateStyle. To ensure portability to otherPostgreSQLinstallations that might use non-defaultDateStylesettings,DateStyleshould be set toISObefore usingCOPY TO. It is also a good idea to avoid dumping data withIntervalStyleset tosql_standard, because negative interval values might be misinterpreted by a server that has a different setting forIntervalStyle.\nInput data is interpreted according toENCODINGoption or the current client encoding, and output data is encoded inENCODINGor the current client encoding, even if the data does not pass through the client but is read from or written to a file directly by the server.\nCOPYstops operation at the first error. This should not lead to problems in the event of aCOPY TO, but the target table will already have received earlier rows in aCOPY FROM. These rows will not be visible or accessible, but they still occupy disk space. This might amount to a considerable amount of wasted disk space if the failure happened well into a large copy operation. You might wish to invokeVACUUMto recover the wasted space.\nFORCE_NULLandFORCE_NOT_NULLcan be used simultaneously on the same column. This results in converting quoted null strings to null values and unquoted null strings to empty strings.",
    "metadata": {
      "doc_name": "sql-copy",
      "section_title": "Notes",
      "url": "https://www.postgresql.org/docs/16/sql-copy.html"
    }
  },
  {
    "chunk_id": 11,
    "text": "When thetextformat is used, the data read or written is a text file with one line per table row. Columns in a row are separated by the delimiter character. The column values themselves are strings generated by the output function, or acceptable to the input function, of each attribute's data type. The specified null string is used in place of columns that are null.COPY FROMwill raise an error if any line of the input file contains more or fewer columns than are expected.\nEnd of data can be represented by a single line containing just backslash-period (\\.). An end-of-data marker is not necessary when reading from a file, since the end of file serves perfectly well; it is needed only when copying data to or from client applications using pre-3.0 client protocol.\nBackslash characters (\\) can be used in theCOPYdata to quote data characters that might otherwise be taken as row or column delimiters. In particular, the following charactersmustbe preceded by a backslash if they appear as part of a column value: backslash itself, newline, carriage return, and the current delimiter character.\nThe specified null string is sent byCOPY TOwithout adding any backslashes; conversely,COPY FROMmatches the input against the null string before removing backslashes. Therefore, a null string such as\\Ncannot be confused with the actual data value\\N(which would be represented as\\\\N).\nThe following special backslash sequences are recognized byCOPY FROM:\nPresently,COPY TOwill never emit an octal or hex-digits backslash sequence, but it does use the other sequences listed above for those control characters.\nAny other backslashed character that is not mentioned in the above table will be taken to represent itself. However, beware of adding backslashes unnecessarily, since that might accidentally produce a string matching the end-of-data marker (\\.) or the null string (\\Nby default). These strings will be recognized before any other backslash processing is done.\nIt is strongly recommended that applications generatingCOPYdata convert data newlines and carriage returns to the\\nand\\rsequences respectively. At present it is possible to represent a data carriage return by a backslash and carriage return, and to represent a data newline by a backslash and newline. However, these representations might not be accepted in future releases. They are also highly vulnerable to corruption if theCOPYfile is transferred across different machines (for example, from Unix to Windows or vice versa).\nAll backslash sequences are interpreted after encoding",
    "metadata": {
      "doc_name": "sql-copy",
      "section_title": "Text Format",
      "url": "https://www.postgresql.org/docs/16/sql-copy.html"
    }
  },
  {
    "chunk_id": 12,
    "text": "that applications generatingCOPYdata convert data newlines and carriage returns to the\\nand\\rsequences respectively. At present it is possible to represent a data carriage return by a backslash and carriage return, and to represent a data newline by a backslash and newline. However, these representations might not be accepted in future releases. They are also highly vulnerable to corruption if theCOPYfile is transferred across different machines (for example, from Unix to Windows or vice versa).\nAll backslash sequences are interpreted after encoding conversion. The bytes specified with the octal and hex-digit backslash sequences must form valid characters in the database encoding.\nCOPY TOwill terminate each row with a Unix-style newline (“\\n”). Servers running on Microsoft Windows instead output carriage return/newline (“\\r\\n”), but only forCOPYto a server file; for consistency across platforms,COPY TO STDOUTalways sends“\\n”regardless of server platform.COPY FROMcan handle lines ending with newlines, carriage returns, or carriage return/newlines. To reduce the risk of error due to un-backslashed newlines or carriage returns that were meant as data,COPY FROMwill complain if the line endings in the input are not all alike.",
    "metadata": {
      "doc_name": "sql-copy",
      "section_title": "Text Format",
      "url": "https://www.postgresql.org/docs/16/sql-copy.html"
    }
  },
  {
    "chunk_id": 13,
    "text": "This format option is used for importing and exporting the Comma Separated Value (CSV) file format used by many other programs, such as spreadsheets. Instead of the escaping rules used byPostgreSQL's standard text format, it produces and recognizes the commonCSVescaping mechanism.\nThe values in each record are separated by theDELIMITERcharacter. If the value contains the delimiter character, theQUOTEcharacter, theNULLstring, a carriage return, or line feed character, then the whole value is prefixed and suffixed by theQUOTEcharacter, and any occurrence within the value of aQUOTEcharacter or theESCAPEcharacter is preceded by the escape character. You can also useFORCE_QUOTEto force quotes when outputting non-NULLvalues in specific columns.\nTheCSVformat has no standard way to distinguish aNULLvalue from an empty string.PostgreSQL'sCOPYhandles this by quoting. ANULLis output as theNULLparameter string and is not quoted, while a non-NULLvalue matching theNULLparameter string is quoted. For example, with the default settings, aNULLis written as an unquoted empty string, while an empty string data value is written with double quotes (\"\"). Reading values follows similar rules. You can useFORCE_NOT_NULLto preventNULLinput comparisons for specific columns. You can also useFORCE_NULLto convert quoted null string data values toNULL.\nBecause backslash is not a special character in theCSVformat,\\., the end-of-data marker, could also appear as a data value. To avoid any misinterpretation, a\\.data value appearing as a lone entry on a line is automatically quoted on output, and on input, if quoted, is not interpreted as the end-of-data marker. If you are loading a file created by another application that has a single unquoted column and might have a value of\\., you might need to quote that value in the input file.",
    "metadata": {
      "doc_name": "sql-copy",
      "section_title": "CSV Format",
      "url": "https://www.postgresql.org/docs/16/sql-copy.html"
    }
  },
  {
    "chunk_id": 14,
    "text": "InCSVformat, all characters are significant. A quoted value surrounded by white space, or any characters other thanDELIMITER, will include those characters. This can cause errors if you import data from a system that padsCSVlines with white space out to some fixed width. If such a situation arises you might need to preprocess theCSVfile to remove the trailing white space, before importing the data intoPostgreSQL.",
    "metadata": {
      "doc_name": "sql-copy",
      "section_title": "Note",
      "url": "https://www.postgresql.org/docs/16/sql-copy.html"
    }
  },
  {
    "chunk_id": 15,
    "text": "CSVformat will both recognize and produceCSVfiles with quoted values containing embedded carriage returns and line feeds. Thus the files are not strictly one line per table row like text-format files.",
    "metadata": {
      "doc_name": "sql-copy",
      "section_title": "Note",
      "url": "https://www.postgresql.org/docs/16/sql-copy.html"
    }
  },
  {
    "chunk_id": 16,
    "text": "Many programs produce strange and occasionally perverseCSVfiles, so the file format is more a convention than a standard. Thus you might encounter some files that cannot be imported using this mechanism, andCOPYmight produce files that other programs cannot process.",
    "metadata": {
      "doc_name": "sql-copy",
      "section_title": "Note",
      "url": "https://www.postgresql.org/docs/16/sql-copy.html"
    }
  },
  {
    "chunk_id": 17,
    "text": "Thebinaryformat option causes all data to be stored/read as binary format rather than as text. It is somewhat faster than the text andCSVformats, but a binary-format file is less portable across machine architectures andPostgreSQLversions. Also, the binary format is very data type specific; for example it will not work to output binary data from asmallintcolumn and read it into anintegercolumn, even though that would work fine in text format.\nThebinaryfile format consists of a file header, zero or more tuples containing the row data, and a file trailer. Headers and data are in network byte order.",
    "metadata": {
      "doc_name": "sql-copy",
      "section_title": "Binary Format",
      "url": "https://www.postgresql.org/docs/16/sql-copy.html"
    }
  },
  {
    "chunk_id": 18,
    "text": "PostgreSQLreleases before 7.4 used a different binary file format.\nThe file header consists of 15 bytes of fixed fields, followed by a variable-length header extension area. The fixed fields are:\n11-byte sequencePGCOPY\\n\\377\\r\\n\\0— note that the zero byte is a required part of the signature. (The signature is designed to allow easy identification of files that have been munged by a non-8-bit-clean transfer. This signature will be changed by end-of-line-translation filters, dropped zero bytes, dropped high bits, or parity changes.)\n32-bit integer bit mask to denote important aspects of the file format. Bits are numbered from 0 (LSB) to 31 (MSB). Note that this field is stored in network byte order (most significant byte first), as are all the integer fields used in the file format. Bits 16–31 are reserved to denote critical file format issues; a reader should abort if it finds an unexpected bit set in this range. Bits 0–15 are reserved to signal backwards-compatible format issues; a reader should simply ignore any unexpected bits set in this range. Currently only one flag bit is defined, and the rest must be zero:\nIf 1, OIDs are included in the data; if 0, not. Oid system columns are not supported inPostgreSQLanymore, but the format still contains the indicator.\n32-bit integer, length in bytes of remainder of header, not including self. Currently, this is zero, and the first tuple follows immediately. Future changes to the format might allow additional data to be present in the header. A reader should silently skip over any header extension data it does not know what to do with.\nThe header extension area is envisioned to contain a sequence of self-identifying chunks. The flags field is not intended to tell readers what is in the extension area. Specific design of header extension contents is left for a later release.\nThis design allows for both backwards-compatible header additions (add header extension chunks, or set low-order flag bits) and non-backwards-compatible changes (set high-order flag bits to signal such changes, and add supporting data to the extension area if needed).\nEach tuple begins with a 16-bit integer count of the number of fields in the tuple. (Presently, all tuples in a table will have the same count, but that might not always be true.) Then, repeated for each field in the tuple",
    "metadata": {
      "doc_name": "sql-copy",
      "section_title": "Note",
      "url": "https://www.postgresql.org/docs/16/sql-copy.html"
    }
  },
  {
    "chunk_id": 19,
    "text": "design allows for both backwards-compatible header additions (add header extension chunks, or set low-order flag bits) and non-backwards-compatible changes (set high-order flag bits to signal such changes, and add supporting data to the extension area if needed).\nEach tuple begins with a 16-bit integer count of the number of fields in the tuple. (Presently, all tuples in a table will have the same count, but that might not always be true.) Then, repeated for each field in the tuple, there is a 32-bit length word followed by that many bytes of field data. (The length word does not include itself, and can be zero.) As a special case, -1 indicates a NULL field value. No value bytes follow in the NULL case.\nThere is no alignment padding or any other extra data between fields.\nPresently, all data values in a binary-format file are assumed to be in binary format (format code one). It is anticipated that a future extension might add a header field that allows per-column format codes to be specified.\nTo determine the appropriate binary format for the actual tuple data you should consult thePostgreSQLsource, in particular the*sendand*recvfunctions for each column's data type (typically these functions are found in thesrc/backend/utils/adt/directory of the source distribution).\nIf OIDs are included in the file, the OID field immediately follows the field-count word. It is a normal field except that it's not included in the field-count. Note that oid system columns are not supported in current versions ofPostgreSQL.\nThe file trailer consists of a 16-bit integer word containing -1. This is easily distinguished from a tuple's field-count word.\nA reader should report an error if a field-count word is neither -1 nor the expected number of columns. This provides an extra check against somehow getting out of sync with the data.",
    "metadata": {
      "doc_name": "sql-copy",
      "section_title": "Note",
      "url": "https://www.postgresql.org/docs/16/sql-copy.html"
    }
  },
  {
    "chunk_id": 20,
    "text": "The following example copies a table to the client using the vertical bar (|) as the field delimiter:\n\n\nCODE:\n\nCOPY country TO STDOUT (DELIMITER '|');\n\nTo copy data from a file into thecountrytable:\n\n\nCODE:\n\nCOPY country FROM '/usr1/proj/bray/sql/country_data';\n\nTo copy into a file just the countries whose names start with 'A':\n\n\nCODE:\n\nCOPY (SELECT * FROM country WHERE country_name LIKE 'A%') TO '/usr1/proj/bray/sql/a_list_countries.copy';\n\nTo copy into a compressed file, you can pipe the output through an external compression program:\n\n\nCODE:\n\nCOPY country TO PROGRAM 'gzip > /usr1/proj/bray/sql/country_data.gz';\n\nHere is a sample of data suitable for copying into a table fromSTDIN:\n\n\nCODE:\n\nAF      AFGHANISTAN\nAL      ALBANIA\nDZ      ALGERIA\nZM      ZAMBIA\nZW      ZIMBABWE\n\nNote that the white space on each line is actually a tab character.\nThe following is the same data, output in binary format. The data is shown after filtering through the Unix utilityod -c. The table has three columns; the first has typechar(2), the second has typetext, and the third has typeinteger. All the rows have a null value in the third column.\n\n\nCODE:\n\n0000000   P   G   C   O   P   Y  \\n 377  \\r  \\n  \\0  \\0  \\0  \\0  \\0  \\0\n0000020  \\0  \\0  \\0  \\0 003  \\0  \\0  \\0 002   A   F  \\0  \\0  \\0 013   A\n0000040   F   G   H   A   N   I   S   T   A   N 377 377 377 377  \\0 003\n0000060  \\0  \\0  \\0 002   A   L  \\0  \\0  \\0 007   A   L   B   A   N   I\n0000100   A 377 377 377 377  \\0 003  \\0  \\0  \\0 002   D   Z  \\0  \\0  \\0\n000",
    "metadata": {
      "doc_name": "sql-copy",
      "section_title": "Examples",
      "url": "https://www.postgresql.org/docs/16/sql-copy.html"
    }
  },
  {
    "chunk_id": 21,
    "text": "377 377 377 377  \\0 003\n0000060  \\0  \\0  \\0 002   A   L  \\0  \\0  \\0 007   A   L   B   A   N   I\n0000100   A 377 377 377 377  \\0 003  \\0  \\0  \\0 002   D   Z  \\0  \\0  \\0\n0000120 007   A   L   G   E   R   I   A 377 377 377 377  \\0 003  \\0  \\0\n0000140  \\0 002   Z   M  \\0  \\0  \\0 006   Z   A   M   B   I   A 377 377\n0000160 377 377  \\0 003  \\0  \\0  \\0 002   Z   W  \\0  \\0  \\0  \\b   Z   I\n0000200   M   B   A   B   W   E 377 377 377 377 377 377",
    "metadata": {
      "doc_name": "sql-copy",
      "section_title": "Examples",
      "url": "https://www.postgresql.org/docs/16/sql-copy.html"
    }
  },
  {
    "chunk_id": 22,
    "text": "There is noCOPYstatement in the SQL standard.\nThe following syntax was used beforePostgreSQLversion 9.0 and is still supported:\n\n\nCODE:\n\nCOPY table_name [ ( column_name [, ...] ) ]\n    FROM { 'filename' | STDIN }\n    [ [ WITH ]\n          [ BINARY ]\n          [ DELIMITER [ AS ] 'delimiter_character' ]\n          [ NULL [ AS ] 'null_string' ]\n          [ CSV [ HEADER ]\n                [ QUOTE [ AS ] 'quote_character' ]\n                [ ESCAPE [ AS ] 'escape_character' ]\n                [ FORCE NOT NULL column_name [, ...] ] ] ]\n\nCOPY { table_name [ ( column_name [, ...] ) ] | ( query ) }\n    TO { 'filename' | STDOUT }\n    [ [ WITH ]\n          [ BINARY ]\n          [ DELIMITER [ AS ] 'delimiter_character' ]\n          [ NULL [ AS ] 'null_string' ]\n          [ CSV [ HEADER ]\n                [ QUOTE [ AS ] 'quote_character' ]\n                [ ESCAPE [ AS ] 'escape_character' ]\n                [ FORCE QUOTE { column_name [, ...] | * } ] ] ]\n\nNote that in this syntax,BINARYandCSVare treated as independent keywords, not as arguments of aFORMAToption.\nThe following syntax was used beforePostgreSQLversion 7.3 and is still supported:\n\n\nCODE:\n\nCOPY [ BINARY ] table_name\n    FROM { 'filename' | STDIN }\n    [ [USING] DELIMITERS 'delimiter_character' ]\n    [ WITH NULL AS 'null_string' ]\n\nCOPY [ BINARY ] table_name\n    TO { 'filename' | STDOUT }\n    [ [USING] DELIMITERS 'delimiter_character' ]\n    [ WITH NULL AS 'null_string' ]",
    "metadata": {
      "doc_name": "sql-copy",
      "section_title": "Compatibility",
      "url": "https://www.postgresql.org/docs/16/sql-copy.html"
    }
  },
  {
    "chunk_id": 0,
    "text": "CREATE DATABASE — create a new database",
    "metadata": {
      "doc_name": "sql-createdatabase",
      "section_title": "CREATE DATABASE",
      "url": "https://www.postgresql.org/docs/16/sql-createdatabase.html"
    }
  },
  {
    "chunk_id": 1,
    "text": "CODE:\n\nCREATE DATABASE name\n    [ WITH ] [ OWNER [=] user_name ]\n           [ TEMPLATE [=] template ]\n           [ ENCODING [=] encoding ]\n           [ STRATEGY [=] strategy ]\n           [ LOCALE [=] locale ]\n           [ LC_COLLATE [=] lc_collate ]\n           [ LC_CTYPE [=] lc_ctype ]\n           [ ICU_LOCALE [=] icu_locale ]\n           [ ICU_RULES [=] icu_rules ]\n           [ LOCALE_PROVIDER [=] locale_provider ]\n           [ COLLATION_VERSION = collation_version ]\n           [ TABLESPACE [=] tablespace_name ]\n           [ ALLOW_CONNECTIONS [=] allowconn ]\n           [ CONNECTION LIMIT [=] connlimit ]\n           [ IS_TEMPLATE [=] istemplate ]\n           [ OID [=] oid ]",
    "metadata": {
      "doc_name": "sql-createdatabase",
      "section_title": "Synopsis",
      "url": "https://www.postgresql.org/docs/16/sql-createdatabase.html"
    }
  },
  {
    "chunk_id": 2,
    "text": "CREATE DATABASEcreates a newPostgreSQLdatabase.\nTo create a database, you must be a superuser or have the specialCREATEDBprivilege. SeeCREATE ROLE.\nBy default, the new database will be created by cloning the standard system databasetemplate1. A different template can be specified by writingTEMPLATEname. In particular, by writingTEMPLATE template0, you can create a pristine database (one where no user-defined objects exist and where the system objects have not been altered) containing only the standard objects predefined by your version ofPostgreSQL. This is useful if you wish to avoid copying any installation-local objects that might have been added totemplate1.",
    "metadata": {
      "doc_name": "sql-createdatabase",
      "section_title": "Description",
      "url": "https://www.postgresql.org/docs/16/sql-createdatabase.html"
    }
  },
  {
    "chunk_id": 3,
    "text": "The name of a database to create.\nThe role name of the user who will own the new database, orDEFAULTto use the default (namely, the user executing the command). To create a database owned by another role, you must be able toSET ROLEto that role.\nThe name of the template from which to create the new database, orDEFAULTto use the default template (template1).\nCharacter set encoding to use in the new database. Specify a string constant (e.g.,'SQL_ASCII'), or an integer encoding number, orDEFAULTto use the default encoding (namely, the encoding of the template database). The character sets supported by thePostgreSQLserver are described inSection 24.3.1. See below for additional restrictions.\nStrategy to be used in creating the new database. If theWAL_LOGstrategy is used, the database will be copied block by block and each block will be separately written to the write-ahead log. This is the most efficient strategy in cases where the template database is small, and therefore it is the default. The olderFILE_COPYstrategy is also available. This strategy writes a small record to the write-ahead log for each tablespace used by the target database. Each such record represents copying an entire directory to a new location at the filesystem level. While this does reduce the write-ahead log volume substantially, especially if the template database is large, it also forces the system to perform a checkpoint both before and after the creation of the new database. In some situations, this may have a noticeable negative impact on overall system performance.\nSets the default collation order and character classification in the new database. Collation affects the sort order applied to strings, e.g., in queries withORDER BY, as well as the order used in indexes on text columns. Character classification affects the categorization of characters, e.g., lower, upper, and digit. Also sets the associated aspects of the operating system environment,LC_COLLATEandLC_CTYPE. The default is the same setting as the template database. SeeSection 24.2.2.3.1andSection 24.2.2.3.2for details.\nCan be overridden by settinglc_collate,lc_ctype, oricu_localeindividually.",
    "metadata": {
      "doc_name": "sql-createdatabase",
      "section_title": "Parameters",
      "url": "https://www.postgresql.org/docs/16/sql-createdatabase.html"
    }
  },
  {
    "chunk_id": 4,
    "text": "The other locale settingslc_messages,lc_monetary,lc_numeric, andlc_timeare not fixed per database and are not set by this command. If you want to make them the default for a specific database, you can useALTER DATABASE ... SET.\nSetsLC_COLLATEin the database server's operating system environment. The default is the setting oflocaleif specified, otherwise the same setting as the template database. See below for additional restrictions.\nIflocale_providerislibc, also sets the default collation order to use in the new database, overriding the settinglocale.\nSetsLC_CTYPEin the database server's operating system environment. The default is the setting oflocaleif specified, otherwise the same setting as the template database. See below for additional restrictions.\nIflocale_providerislibc, also sets the default character classification to use in the new database, overriding the settinglocale.\nSpecifies the ICU locale (seeSection 24.2.2.3.2) for the database default collation order and character classification, overriding the settinglocale. Thelocale providermust be ICU. The default is the setting oflocaleif specified; otherwise the same setting as the template database.\nSpecifies additional collation rules to customize the behavior of the default collation of this database. This is supported for ICU only. SeeSection 24.2.3.4for details.\nSpecifies the provider to use for the default collation in this database. Possible values areicu(if the server was built with ICU support) orlibc. By default, the provider is the same as that of thetemplate. SeeSection 24.1.4for details.\nSpecifies the collation version string to store with the database. Normally, this should be omitted, which will cause the version to be computed from the actual version of the database collation as provided by the operating system. This option is intended to be used bypg_upgradefor copying the version from an existing installation.\nSee alsoALTER DATABASEfor how to handle database collation version mismatches.\nThe name of the tablespace that will be associated with the new database, orDEFAULTto use the template database's tablespace. This tablespace will be the default tablespace used for objects created in this database. SeeCREATE TABLESPACEfor more information.\nIf false then no one can connect to this database. The default is true, allowing connections (except as restricted by other mechanisms, such asGRANT/REVOKE CONNECT).\nHow many concurrent",
    "metadata": {
      "doc_name": "sql-createdatabase",
      "section_title": "Tip",
      "url": "https://www.postgresql.org/docs/16/sql-createdatabase.html"
    }
  },
  {
    "chunk_id": 5,
    "text": "for how to handle database collation version mismatches.\nThe name of the tablespace that will be associated with the new database, orDEFAULTto use the template database's tablespace. This tablespace will be the default tablespace used for objects created in this database. SeeCREATE TABLESPACEfor more information.\nIf false then no one can connect to this database. The default is true, allowing connections (except as restricted by other mechanisms, such asGRANT/REVOKE CONNECT).\nHow many concurrent connections can be made to this database. -1 (the default) means no limit.\nIf true, then this database can be cloned by any user withCREATEDBprivileges; if false (the default), then only superusers or the owner of the database can clone it.\nThe object identifier to be used for the new database. If this parameter is not specified,PostgreSQLwill choose a suitable OID automatically. This parameter is primarily intended for internal use bypg_upgrade, and onlypg_upgradecan specify a value less than 16384.\nOptional parameters can be written in any order, not only the order illustrated above.",
    "metadata": {
      "doc_name": "sql-createdatabase",
      "section_title": "Tip",
      "url": "https://www.postgresql.org/docs/16/sql-createdatabase.html"
    }
  },
  {
    "chunk_id": 6,
    "text": "CREATE DATABASEcannot be executed inside a transaction block.\nErrors along the line of“could not initialize database directory”are most likely related to insufficient permissions on the data directory, a full disk, or other file system problems.\nUseDROP DATABASEto remove a database.\nThe programcreatedbis a wrapper program around this command, provided for convenience.\nDatabase-level configuration parameters (set viaALTER DATABASE) and database-level permissions (set viaGRANT) are not copied from the template database.\nAlthough it is possible to copy a database other thantemplate1by specifying its name as the template, this is not (yet) intended as a general-purpose“COPY DATABASE”facility. The principal limitation is that no other sessions can be connected to the template database while it is being copied.CREATE DATABASEwill fail if any other connection exists when it starts; otherwise, new connections to the template database are locked out untilCREATE DATABASEcompletes. SeeSection 23.3for more information.\nThe character set encoding specified for the new database must be compatible with the chosen locale settings (LC_COLLATEandLC_CTYPE). If the locale isC(or equivalentlyPOSIX), then all encodings are allowed, but for other locale settings there is only one encoding that will work properly. (On Windows, however, UTF-8 encoding can be used with any locale.)CREATE DATABASEwill allow superusers to specifySQL_ASCIIencoding regardless of the locale settings, but this choice is deprecated and may result in misbehavior of character-string functions if data that is not encoding-compatible with the locale is stored in the database.\nThe encoding and locale settings must match those of the template database, except whentemplate0is used as template. This is because other databases might contain data that does not match the specified encoding, or might contain indexes whose sort ordering is affected byLC_COLLATEandLC_CTYPE. Copying such data would result in a database that is corrupt according to the new settings.template0, however, is known to not contain any data or indexes that would be affected.\nThere is currently no option to use a database locale with nondeterministic comparisons (seeCREATE COLLATIONfor an explanation). If this is needed, then per-column collations would need to be used.\nTheCONNECTION LIMIToption is only enforced approximately; if two new sessions start at about the same time when just one connection“slot”remains for the database, it is possible that both will fail. Also, the limit is not enforced against",
    "metadata": {
      "doc_name": "sql-createdatabase",
      "section_title": "Notes",
      "url": "https://www.postgresql.org/docs/16/sql-createdatabase.html"
    }
  },
  {
    "chunk_id": 7,
    "text": "not contain any data or indexes that would be affected.\nThere is currently no option to use a database locale with nondeterministic comparisons (seeCREATE COLLATIONfor an explanation). If this is needed, then per-column collations would need to be used.\nTheCONNECTION LIMIToption is only enforced approximately; if two new sessions start at about the same time when just one connection“slot”remains for the database, it is possible that both will fail. Also, the limit is not enforced against superusers or background worker processes.",
    "metadata": {
      "doc_name": "sql-createdatabase",
      "section_title": "Notes",
      "url": "https://www.postgresql.org/docs/16/sql-createdatabase.html"
    }
  },
  {
    "chunk_id": 8,
    "text": "To create a new database:\n\n\nCODE:\n\nCREATE DATABASE lusiadas;\n\nTo create a databasesalesowned by usersalesappwith a default tablespace ofsalesspace:\n\n\nCODE:\n\nCREATE DATABASE sales OWNER salesapp TABLESPACE salesspace;\n\nTo create a databasemusicwith a different locale:\n\n\nCODE:\n\nCREATE DATABASE music\n    LOCALE 'sv_SE.utf8'\n    TEMPLATE template0;\n\nIn this example, theTEMPLATE template0clause is required if the specified locale is different from the one intemplate1. (If it is not, then specifying the locale explicitly is redundant.)\nTo create a databasemusic2with a different locale and a different character set encoding:\n\n\nCODE:\n\nCREATE DATABASE music2\n    LOCALE 'sv_SE.iso885915'\n    ENCODING LATIN9\n    TEMPLATE template0;\n\nThe specified locale and encoding settings must match, or an error will be reported.\nNote that locale names are specific to the operating system, so that the above commands might not work in the same way everywhere.",
    "metadata": {
      "doc_name": "sql-createdatabase",
      "section_title": "Examples",
      "url": "https://www.postgresql.org/docs/16/sql-createdatabase.html"
    }
  },
  {
    "chunk_id": 9,
    "text": "There is noCREATE DATABASEstatement in the SQL standard. Databases are equivalent to catalogs, whose creation is implementation-defined.",
    "metadata": {
      "doc_name": "sql-createdatabase",
      "section_title": "Compatibility",
      "url": "https://www.postgresql.org/docs/16/sql-createdatabase.html"
    }
  },
  {
    "chunk_id": 0,
    "text": "CREATE INDEX — define a new index",
    "metadata": {
      "doc_name": "sql-createindex",
      "section_title": "CREATE INDEX",
      "url": "https://www.postgresql.org/docs/16/sql-createindex.html"
    }
  },
  {
    "chunk_id": 1,
    "text": "CODE:\n\nCREATE [ UNIQUE ] INDEX [ CONCURRENTLY ] [ [ IF NOT EXISTS ] name ] ON [ ONLY ] table_name [ USING method ]\n    ( { column_name | ( expression ) } [ COLLATE collation ] [ opclass [ ( opclass_parameter = value [, ... ] ) ] ] [ ASC | DESC ] [ NULLS { FIRST | LAST } ] [, ...] )\n    [ INCLUDE ( column_name [, ...] ) ]\n    [ NULLS [ NOT ] DISTINCT ]\n    [ WITH ( storage_parameter [= value] [, ... ] ) ]\n    [ TABLESPACE tablespace_name ]\n    [ WHERE predicate ]",
    "metadata": {
      "doc_name": "sql-createindex",
      "section_title": "Synopsis",
      "url": "https://www.postgresql.org/docs/16/sql-createindex.html"
    }
  },
  {
    "chunk_id": 2,
    "text": "CREATE INDEXconstructs an index on the specified column(s) of the specified relation, which can be a table or a materialized view. Indexes are primarily used to enhance database performance (though inappropriate use can result in slower performance).\nThe key field(s) for the index are specified as column names, or alternatively as expressions written in parentheses. Multiple fields can be specified if the index method supports multicolumn indexes.\nAn index field can be an expression computed from the values of one or more columns of the table row. This feature can be used to obtain fast access to data based on some transformation of the basic data. For example, an index computed onupper(col)would allow the clauseWHERE upper(col) = 'JIM'to use an index.\nPostgreSQLprovides the index methods B-tree, hash, GiST, SP-GiST, GIN, and BRIN. Users can also define their own index methods, but that is fairly complicated.\nWhen theWHEREclause is present, apartial indexis created. A partial index is an index that contains entries for only a portion of a table, usually a portion that is more useful for indexing than the rest of the table. For example, if you have a table that contains both billed and unbilled orders where the unbilled orders take up a small fraction of the total table and yet that is an often used section, you can improve performance by creating an index on just that portion. Another possible application is to useWHEREwithUNIQUEto enforce uniqueness over a subset of a table. SeeSection 11.8for more discussion.\nThe expression used in theWHEREclause can refer only to columns of the underlying table, but it can use all columns, not just the ones being indexed. Presently, subqueries and aggregate expressions are also forbidden inWHERE. The same restrictions apply to index fields that are expressions.\nAll functions and operators used in an index definition must be“immutable”, that is, their results must depend only on their arguments and never on any outside influence (such as the contents of another table or the current time). This restriction ensures that the behavior of the index is well-defined. To use a user-defined function in an index expression orWHEREclause, remember to mark the function immutable when you create it.",
    "metadata": {
      "doc_name": "sql-createindex",
      "section_title": "Description",
      "url": "https://www.postgresql.org/docs/16/sql-createindex.html"
    }
  },
  {
    "chunk_id": 3,
    "text": "Causes the system to check for duplicate values in the table when the index is created (if data already exist) and each time data is added. Attempts to insert or update data which would result in duplicate entries will generate an error.\nAdditional restrictions apply when unique indexes are applied to partitioned tables; seeCREATE TABLE.\nWhen this option is used,PostgreSQLwill build the index without taking any locks that prevent concurrent inserts, updates, or deletes on the table; whereas a standard index build locks out writes (but not reads) on the table until it's done. There are several caveats to be aware of when using this option — seeBuilding Indexes Concurrentlybelow.\nFor temporary tables,CREATE INDEXis always non-concurrent, as no other session can access them, and non-concurrent index creation is cheaper.\nDo not throw an error if a relation with the same name already exists. A notice is issued in this case. Note that there is no guarantee that the existing index is anything like the one that would have been created. Index name is required whenIF NOT EXISTSis specified.\nThe optionalINCLUDEclause specifies a list of columns which will be included in the index asnon-keycolumns. A non-key column cannot be used in an index scan search qualification, and it is disregarded for purposes of any uniqueness or exclusion constraint enforced by the index. However, an index-only scan can return the contents of non-key columns without having to visit the index's table, since they are available directly from the index entry. Thus, addition of non-key columns allows index-only scans to be used for queries that otherwise could not use them.\nIt's wise to be conservative about adding non-key columns to an index, especially wide columns. If an index tuple exceeds the maximum size allowed for the index type, data insertion will fail. In any case, non-key columns duplicate data from the index's table and bloat the size of the index, thus potentially slowing searches. Furthermore, B-tree deduplication is never used with indexes that have a non-key column.\nColumns listed in theINCLUDEclause don't need appropriate operator classes; the clause can include columns whose data types don't have operator classes defined for a given access method.\nExpressions are not supported as included columns since they cannot be used in index-only scans.\nCurrently, the B-tree, GiST and SP-GiST index access methods support this feature. In these indexes, the values of columns listed in theINCLUDEclause are included in",
    "metadata": {
      "doc_name": "sql-createindex",
      "section_title": "Parameters",
      "url": "https://www.postgresql.org/docs/16/sql-createindex.html"
    }
  },
  {
    "chunk_id": 4,
    "text": "uplication is never used with indexes that have a non-key column.\nColumns listed in theINCLUDEclause don't need appropriate operator classes; the clause can include columns whose data types don't have operator classes defined for a given access method.\nExpressions are not supported as included columns since they cannot be used in index-only scans.\nCurrently, the B-tree, GiST and SP-GiST index access methods support this feature. In these indexes, the values of columns listed in theINCLUDEclause are included in leaf tuples which correspond to heap tuples, but are not included in upper-level index entries used for tree navigation.\nThe name of the index to be created. No schema name can be included here; the index is always created in the same schema as its parent table. The name of the index must be distinct from the name of any other relation (table, sequence, index, view, materialized view, or foreign table) in that schema. If the name is omitted,PostgreSQLchooses a suitable name based on the parent table's name and the indexed column name(s).\nIndicates not to recurse creating indexes on partitions, if the table is partitioned. The default is to recurse.\nThe name (possibly schema-qualified) of the table to be indexed.\nThe name of the index method to be used. Choices arebtree,hash,gist,spgist,gin,brin, or user-installed access methods likebloom. The default method isbtree.\nThe name of a column of the table.\nAn expression based on one or more columns of the table. The expression usually must be written with surrounding parentheses, as shown in the syntax. However, the parentheses can be omitted if the expression has the form of a function call.\nThe name of the collation to use for the index. By default, the index uses the collation declared for the column to be indexed or the result collation of the expression to be indexed. Indexes with non-default collations can be useful for queries that involve expressions using non-default collations.\nThe name of an operator class. See below for details.\nThe name of an operator class parameter. See below for details.\nSpecifies ascending sort order (which is the default).\nSpecifies descending sort order.\nSpecifies that nulls sort before non-nulls. This is the default whenDESCis specified.\nSpecifies that nulls sort after non-nulls. This is the default whenDESCis not specified.\nSpecifies whether for a unique index,",
    "metadata": {
      "doc_name": "sql-createindex",
      "section_title": "Parameters",
      "url": "https://www.postgresql.org/docs/16/sql-createindex.html"
    }
  },
  {
    "chunk_id": 5,
    "text": "can be useful for queries that involve expressions using non-default collations.\nThe name of an operator class. See below for details.\nThe name of an operator class parameter. See below for details.\nSpecifies ascending sort order (which is the default).\nSpecifies descending sort order.\nSpecifies that nulls sort before non-nulls. This is the default whenDESCis specified.\nSpecifies that nulls sort after non-nulls. This is the default whenDESCis not specified.\nSpecifies whether for a unique index, null values should be considered distinct (not equal). The default is that they are distinct, so that a unique index could contain multiple null values in a column.\nThe name of an index-method-specific storage parameter. SeeIndex Storage Parametersbelow for details.\nThe tablespace in which to create the index. If not specified,default_tablespaceis consulted, ortemp_tablespacesfor indexes on temporary tables.\nThe constraint expression for a partial index.",
    "metadata": {
      "doc_name": "sql-createindex",
      "section_title": "Parameters",
      "url": "https://www.postgresql.org/docs/16/sql-createindex.html"
    }
  },
  {
    "chunk_id": 6,
    "text": "The optionalWITHclause specifiesstorage parametersfor the index. Each index method has its own set of allowed storage parameters. The B-tree, hash, GiST and SP-GiST index methods all accept this parameter:\nThe fillfactor for an index is a percentage that determines how full the index method will try to pack index pages. For B-trees, leaf pages are filled to this percentage during initial index builds, and also when extending the index at the right (adding new largest key values). If pages subsequently become completely full, they will be split, leading to fragmentation of the on-disk index structure. B-trees use a default fillfactor of 90, but any integer value from 10 to 100 can be selected.\nB-tree indexes on tables where many inserts and/or updates are anticipated can benefit from lower fillfactor settings atCREATE INDEXtime (following bulk loading into the table). Values in the range of 50 - 90 can usefully“smooth out”therateof page splits during the early life of the B-tree index (lowering fillfactor like this may even lower the absolute number of page splits, though this effect is highly workload dependent). The B-tree bottom-up index deletion technique described inSection 67.4.2is dependent on having some“extra”space on pages to store“extra”tuple versions, and so can be affected by fillfactor (though the effect is usually not significant).\nIn other specific cases it might be useful to increase fillfactor to 100 atCREATE INDEXtime as a way of maximizing space utilization. You should only consider this when you are completely sure that the table is static (i.e. that it will never be affected by either inserts or updates). A fillfactor setting of 100 otherwise risksharmingperformance: even a few updates or inserts will cause a sudden flood of page splits.\nThe other index methods use fillfactor in different but roughly analogous ways; the default fillfactor varies between methods.\nB-tree indexes additionally accept this parameter:\nControls usage of the B-tree deduplication technique described inSection 67.4.3. Set toONorOFFto enable or disable the optimization. (Alternative spellings ofONandOFFare allowed as described inSection 20.1.) The default isON.",
    "metadata": {
      "doc_name": "sql-createindex",
      "section_title": "Index Storage Parameters",
      "url": "https://www.postgresql.org/docs/16/sql-createindex.html"
    }
  },
  {
    "chunk_id": 7,
    "text": "Turningdeduplicate_itemsoff viaALTER INDEXprevents future insertions from triggering deduplication, but does not in itself make existing posting list tuples use the standard tuple representation.\nGiST indexes additionally accept this parameter:\nDetermines whether the buffered build technique described inSection 68.4.1is used to build the index. WithOFFbuffering is disabled, withONit is enabled, and withAUTOit is initially disabled, but is turned on on-the-fly once the index size reacheseffective_cache_size. The default isAUTO. Note that if sorted build is possible, it will be used instead of buffered build unlessbuffering=ONis specified.\nGIN indexes accept different parameters:\nThis setting controls usage of the fast update technique described inSection 70.4.1. It is a Boolean parameter:ONenables fast update,OFFdisables it. The default isON.",
    "metadata": {
      "doc_name": "sql-createindex",
      "section_title": "Note",
      "url": "https://www.postgresql.org/docs/16/sql-createindex.html"
    }
  },
  {
    "chunk_id": 8,
    "text": "Turningfastupdateoff viaALTER INDEXprevents future insertions from going into the list of pending index entries, but does not in itself flush previous entries. You might want toVACUUMthe table or callgin_clean_pending_listfunction afterward to ensure the pending list is emptied.\nCustomgin_pending_list_limitparameter. This value is specified in kilobytes.\nBRINindexes accept different parameters:\nDefines the number of table blocks that make up one block range for each entry of aBRINindex (seeSection 71.1for more details). The default is128.\nDefines whether a summarization run is queued for the previous page range whenever an insertion is detected on the next one. SeeSection 71.1.1for more details. The default isoff.",
    "metadata": {
      "doc_name": "sql-createindex",
      "section_title": "Note",
      "url": "https://www.postgresql.org/docs/16/sql-createindex.html"
    }
  },
  {
    "chunk_id": 9,
    "text": "Creating an index can interfere with regular operation of a database. NormallyPostgreSQLlocks the table to be indexed against writes and performs the entire index build with a single scan of the table. Other transactions can still read the table, but if they try to insert, update, or delete rows in the table they will block until the index build is finished. This could have a severe effect if the system is a live production database. Very large tables can take many hours to be indexed, and even for smaller tables, an index build can lock out writers for periods that are unacceptably long for a production system.\nPostgreSQLsupports building indexes without locking out writes. This method is invoked by specifying theCONCURRENTLYoption ofCREATE INDEX. When this option is used,PostgreSQLmust perform two scans of the table, and in addition it must wait for all existing transactions that could potentially modify or use the index to terminate. Thus this method requires more total work than a standard index build and takes significantly longer to complete. However, since it allows normal operations to continue while the index is built, this method is useful for adding new indexes in a production environment. Of course, the extra CPU and I/O load imposed by the index creation might slow other operations.\nIn a concurrent index build, the index is actually entered as an“invalid”index into the system catalogs in one transaction, then two table scans occur in two more transactions. Before each table scan, the index build must wait for existing transactions that have modified the table to terminate. After the second scan, the index build must wait for any transactions that have a snapshot (seeChapter 13) predating the second scan to terminate, including transactions used by any phase of concurrent index builds on other tables, if the indexes involved are partial or have columns that are not simple column references. Then finally the index can be marked“valid”and ready for use, and theCREATE INDEXcommand terminates. Even then, however, the index may not be immediately usable for queries: in the worst case, it cannot be used as long as transactions exist that predate the start of the index build.\nIf a problem arises while scanning the table, such as a deadlock or a uniqueness violation in a unique index, theCREATE INDEXcommand will fail but leave behind an“invalid”index. This index will be ignored for querying purposes because it might be incomplete; however it will still consume update overhead. Thepsql\\dcommand will report such an index asINVALID",
    "metadata": {
      "doc_name": "sql-createindex",
      "section_title": "Building Indexes Concurrently",
      "url": "https://www.postgresql.org/docs/16/sql-createindex.html"
    }
  },
  {
    "chunk_id": 10,
    "text": "immediately usable for queries: in the worst case, it cannot be used as long as transactions exist that predate the start of the index build.\nIf a problem arises while scanning the table, such as a deadlock or a uniqueness violation in a unique index, theCREATE INDEXcommand will fail but leave behind an“invalid”index. This index will be ignored for querying purposes because it might be incomplete; however it will still consume update overhead. Thepsql\\dcommand will report such an index asINVALID:\n\n\nCODE:\n\npostgres=# \\d tab\n       Table \"public.tab\"\n Column |  Type   | Collation | Nullable | Default\n--------+---------+-----------+----------+---------\n col    | integer |           |          |\nIndexes:\n    \"idx\" btree (col) INVALID\n\nThe recommended recovery method in such cases is to drop the index and try again to performCREATE INDEX CONCURRENTLY. (Another possibility is to rebuild the index withREINDEX INDEX CONCURRENTLY).\nAnother caveat when building a unique index concurrently is that the uniqueness constraint is already being enforced against other transactions when the second table scan begins. This means that constraint violations could be reported in other queries prior to the index becoming available for use, or even in cases where the index build eventually fails. Also, if a failure does occur in the second scan, the“invalid”index continues to enforce its uniqueness constraint afterwards.\nConcurrent builds of expression indexes and partial indexes are supported. Errors occurring in the evaluation of these expressions could cause behavior similar to that described above for unique constraint violations.\nRegular index builds permit other regular index builds on the same table to occur simultaneously, but only one concurrent index build can occur on a table at a time. In either case, schema modification of the table is not allowed while the index is being built. Another difference is that a regularCREATE INDEXcommand can be performed within a transaction block, butCREATE INDEX CONCURRENTLYcannot.\nConcurrent builds for indexes on partitioned tables are currently not supported. However, you may concurrently build the index on each partition individually and then finally create the partitioned index non-concurrently in order to reduce the time where writes to the partitioned table will be locked out. In this case, building the partitioned index is a metadata only operation.",
    "metadata": {
      "doc_name": "sql-createindex",
      "section_title": "Building Indexes Concurrently",
      "url": "https://www.postgresql.org/docs/16/sql-createindex.html"
    }
  },
  {
    "chunk_id": 11,
    "text": "SeeChapter 11for information about when indexes can be used, when they are not used, and in which particular situations they can be useful.\nCurrently, only the B-tree, GiST, GIN, and BRIN index methods support multiple-key-column indexes. Whether there can be multiple key columns is independent of whetherINCLUDEcolumns can be added to the index. Indexes can have up to 32 columns, includingINCLUDEcolumns. (This limit can be altered when buildingPostgreSQL.) Only B-tree currently supports unique indexes.\nAnoperator classwith optional parameters can be specified for each column of an index. The operator class identifies the operators to be used by the index for that column. For example, a B-tree index on four-byte integers would use theint4_opsclass; this operator class includes comparison functions for four-byte integers. In practice the default operator class for the column's data type is usually sufficient. The main point of having operator classes is that for some data types, there could be more than one meaningful ordering. For example, we might want to sort a complex-number data type either by absolute value or by real part. We could do this by defining two operator classes for the data type and then selecting the proper class when creating an index. More information about operator classes is inSection 11.10and inSection 38.16.\nWhenCREATE INDEXis invoked on a partitioned table, the default behavior is to recurse to all partitions to ensure they all have matching indexes. Each partition is first checked to determine whether an equivalent index already exists, and if so, that index will become attached as a partition index to the index being created, which will become its parent index. If no matching index exists, a new index will be created and automatically attached; the name of the new index in each partition will be determined as if no index name had been specified in the command. If theONLYoption is specified, no recursion is done, and the index is marked invalid. (ALTER INDEX ... ATTACH PARTITIONmarks the index valid, once all partitions acquire matching indexes.) Note, however, that any partition that is created in the future usingCREATE TABLE ... PARTITION OFwill automatically have a matching index, regardless of whetherONLYis specified.\nFor index methods that support ordered scans (currently, only B-tree), the optional clausesASC,DESC,NULLS FIRST, and/orNULLS LASTcan be specified to modify the sort ordering of the index. Since an ordered index can",
    "metadata": {
      "doc_name": "sql-createindex",
      "section_title": "Notes",
      "url": "https://www.postgresql.org/docs/16/sql-createindex.html"
    }
  },
  {
    "chunk_id": 12,
    "text": "(ALTER INDEX ... ATTACH PARTITIONmarks the index valid, once all partitions acquire matching indexes.) Note, however, that any partition that is created in the future usingCREATE TABLE ... PARTITION OFwill automatically have a matching index, regardless of whetherONLYis specified.\nFor index methods that support ordered scans (currently, only B-tree), the optional clausesASC,DESC,NULLS FIRST, and/orNULLS LASTcan be specified to modify the sort ordering of the index. Since an ordered index can be scanned either forward or backward, it is not normally useful to create a single-columnDESCindex — that sort ordering is already available with a regular index. The value of these options is that multicolumn indexes can be created that match the sort ordering requested by a mixed-ordering query, such asSELECT ... ORDER BY x ASC, y DESC. TheNULLSoptions are useful if you need to support“nulls sort low”behavior, rather than the default“nulls sort high”, in queries that depend on indexes to avoid sorting steps.\nThe system regularly collects statistics on all of a table's columns. Newly-created non-expression indexes can immediately use these statistics to determine an index's usefulness. For new expression indexes, it is necessary to runANALYZEor wait for theautovacuum daemonto analyze the table to generate statistics for these indexes.\nFor most index methods, the speed of creating an index is dependent on the setting ofmaintenance_work_mem. Larger values will reduce the time needed for index creation, so long as you don't make it larger than the amount of memory really available, which would drive the machine into swapping.\nPostgreSQLcan build indexes while leveraging multiple CPUs in order to process the table rows faster. This feature is known asparallel index build. For index methods that support building indexes in parallel (currently, only B-tree),maintenance_work_memspecifies the maximum amount of memory that can be used by each index build operation as a whole, regardless of how many worker processes were started. Generally, a cost model automatically determines how many worker processes should be requested, if any.\nParallel index builds may benefit from increasingmaintenance_work_memwhere an equivalent serial index build will see little or no benefit. Note thatmaintenance_work_memmay influence the number of worker processes requested, since parallel workers must have at least a32MBshare of the totalmaintenance_work_membudget. There must also be a remaining32MBshare for the leader process. Increasingmax_parallel_maintenance",
    "metadata": {
      "doc_name": "sql-createindex",
      "section_title": "Notes",
      "url": "https://www.postgresql.org/docs/16/sql-createindex.html"
    }
  },
  {
    "chunk_id": 13,
    "text": "many worker processes were started. Generally, a cost model automatically determines how many worker processes should be requested, if any.\nParallel index builds may benefit from increasingmaintenance_work_memwhere an equivalent serial index build will see little or no benefit. Note thatmaintenance_work_memmay influence the number of worker processes requested, since parallel workers must have at least a32MBshare of the totalmaintenance_work_membudget. There must also be a remaining32MBshare for the leader process. Increasingmax_parallel_maintenance_workersmay allow more workers to be used, which will reduce the time needed for index creation, so long as the index build is not already I/O bound. Of course, there should also be sufficient CPU capacity that would otherwise lie idle.\nSetting a value forparallel_workersviaALTER TABLEdirectly controls how many parallel worker processes will be requested by aCREATE INDEXagainst the table. This bypasses the cost model completely, and preventsmaintenance_work_memfrom affecting how many parallel workers are requested. Settingparallel_workersto 0 viaALTER TABLEwill disable parallel index builds on the table in all cases.",
    "metadata": {
      "doc_name": "sql-createindex",
      "section_title": "Notes",
      "url": "https://www.postgresql.org/docs/16/sql-createindex.html"
    }
  },
  {
    "chunk_id": 14,
    "text": "You might want to resetparallel_workersafter setting it as part of tuning an index build. This avoids inadvertent changes to query plans, sinceparallel_workersaffectsallparallel table scans.\nWhileCREATE INDEXwith theCONCURRENTLYoption supports parallel builds without special restrictions, only the first table scan is actually performed in parallel.\nUseDROP INDEXto remove an index.\nLike any long-running transaction,CREATE INDEXon a table can affect which tuples can be removed by concurrentVACUUMon any other table.\nPrior releases ofPostgreSQLalso had an R-tree index method. This method has been removed because it had no significant advantages over the GiST method. IfUSING rtreeis specified,CREATE INDEXwill interpret it asUSING gist, to simplify conversion of old databases to GiST.\nEach backend runningCREATE INDEXwill report its progress in thepg_stat_progress_create_indexview. SeeSection 28.4.4for details.",
    "metadata": {
      "doc_name": "sql-createindex",
      "section_title": "Tip",
      "url": "https://www.postgresql.org/docs/16/sql-createindex.html"
    }
  },
  {
    "chunk_id": 15,
    "text": "To create a unique B-tree index on the columntitlein the tablefilms:\n\n\nCODE:\n\nCREATE UNIQUE INDEX title_idx ON films (title);\n\nTo create a unique B-tree index on the columntitlewith included columnsdirectorandratingin the tablefilms:\n\n\nCODE:\n\nCREATE UNIQUE INDEX title_idx ON films (title) INCLUDE (director, rating);\n\nTo create a B-Tree index with deduplication disabled:\n\n\nCODE:\n\nCREATE INDEX title_idx ON films (title) WITH (deduplicate_items = off);\n\nTo create an index on the expressionlower(title), allowing efficient case-insensitive searches:\n\n\nCODE:\n\nCREATE INDEX ON films ((lower(title)));\n\n(In this example we have chosen to omit the index name, so the system will choose a name, typicallyfilms_lower_idx.)\nTo create an index with non-default collation:\n\n\nCODE:\n\nCREATE INDEX title_idx_german ON films (title COLLATE \"de_DE\");\n\nTo create an index with non-default sort ordering of nulls:\n\n\nCODE:\n\nCREATE INDEX title_idx_nulls_low ON films (title NULLS FIRST);\n\nTo create an index with non-default fill factor:\n\n\nCODE:\n\nCREATE UNIQUE INDEX title_idx ON films (title) WITH (fillfactor = 70);\n\nTo create aGINindex with fast updates disabled:\n\n\nCODE:\n\nCREATE INDEX gin_idx ON documents_table USING GIN (locations) WITH (fastupdate = off);\n\nTo create an index on the columncodein the tablefilmsand have the index reside in the tablespaceindexspace:\n\n\nCODE:\n\nCREATE INDEX code_idx ON films (code) TABLESPACE indexspace;\n\nTo create a GiST index on a point attribute so that we can efficiently use box operators on the result of the conversion function:\n\n\nCODE:\n\nCREATE INDEX pointloc\n    ON points USING gist (box(location,location));\nSELECT * FROM points\n    WHERE box(location,location) && '(0,0),(1,1)'::box;\n\nTo create an index without locking out writes to the table:\n\n\nCODE:\n\nCREATE INDEX CONCURRENTLY sales_quantity_index ON sales_table (quantity);",
    "metadata": {
      "doc_name": "sql-createindex",
      "section_title": "Examples",
      "url": "https://www.postgresql.org/docs/16/sql-createindex.html"
    }
  },
  {
    "chunk_id": 16,
    "text": "CREATE INDEXis aPostgreSQLlanguage extension. There are no provisions for indexes in the SQL standard.",
    "metadata": {
      "doc_name": "sql-createindex",
      "section_title": "Compatibility",
      "url": "https://www.postgresql.org/docs/16/sql-createindex.html"
    }
  },
  {
    "chunk_id": 0,
    "text": "CREATE ROLE — define a new database role",
    "metadata": {
      "doc_name": "sql-createrole",
      "section_title": "CREATE ROLE",
      "url": "https://www.postgresql.org/docs/16/sql-createrole.html"
    }
  },
  {
    "chunk_id": 1,
    "text": "CODE:\n\nCREATE ROLE name [ [ WITH ] option [ ... ] ]\n\nwhere option can be:\n\n      SUPERUSER | NOSUPERUSER\n    | CREATEDB | NOCREATEDB\n    | CREATEROLE | NOCREATEROLE\n    | INHERIT | NOINHERIT\n    | LOGIN | NOLOGIN\n    | REPLICATION | NOREPLICATION\n    | BYPASSRLS | NOBYPASSRLS\n    | CONNECTION LIMIT connlimit\n    | [ ENCRYPTED ] PASSWORD 'password' | PASSWORD NULL\n    | VALID UNTIL 'timestamp'\n    | IN ROLE role_name [, ...]\n    | IN GROUP role_name [, ...]\n    | ROLE role_name [, ...]\n    | ADMIN role_name [, ...]\n    | USER role_name [, ...]\n    | SYSID uid",
    "metadata": {
      "doc_name": "sql-createrole",
      "section_title": "Synopsis",
      "url": "https://www.postgresql.org/docs/16/sql-createrole.html"
    }
  },
  {
    "chunk_id": 2,
    "text": "CREATE ROLEadds a new role to aPostgreSQLdatabase cluster. A role is an entity that can own database objects and have database privileges; a role can be considered a“user”, a“group”, or both depending on how it is used. Refer toChapter 22andChapter 21for information about managing users and authentication. You must haveCREATEROLEprivilege or be a database superuser to use this command.\nNote that roles are defined at the database cluster level, and so are valid in all databases in the cluster.\nDuring role creation it is possible to immediately assign the newly created role to be a member of an existing role, and also assign existing roles to be members of the newly created role. The rules for which initial role membership options are enabled are described below in theIN ROLE,ROLE, andADMINclauses. TheGRANTcommand has fine-grained option control during membership creation, and the ability to modify these options after the new role is created.",
    "metadata": {
      "doc_name": "sql-createrole",
      "section_title": "Description",
      "url": "https://www.postgresql.org/docs/16/sql-createrole.html"
    }
  },
  {
    "chunk_id": 3,
    "text": "The name of the new role.\nThese clauses determine whether the new role is a“superuser”, who can override all access restrictions within the database. Superuser status is dangerous and should be used only when really needed. You must yourself be a superuser to create a new superuser. If not specified,NOSUPERUSERis the default.\nThese clauses define a role's ability to create databases. IfCREATEDBis specified, the role being defined will be allowed to create new databases. SpecifyingNOCREATEDBwill deny a role the ability to create databases. If not specified,NOCREATEDBis the default. Only superuser roles or roles withCREATEDBcan specifyCREATEDB.\nThese clauses determine whether a role will be permitted to create, alter, drop, comment on, and change the security label for other roles. Seerole creationfor more details about what capabilities are conferred by this privilege. If not specified,NOCREATEROLEis the default.\nThis affects the membership inheritance status when this role is added as a member of another role, both in this and future commands. Specifically, it controls the inheritance status of memberships added with this command using theIN ROLEclause, and in later commands using theROLEclause. It is also used as the default inheritance status when adding this role as a member using theGRANTcommand. If not specified,INHERITis the default.\nInPostgreSQLversions before 16, inheritance was a role-level attribute that controlled all runtime membership checks for that role.\nThese clauses determine whether a role is allowed to log in; that is, whether the role can be given as the initial session authorization name during client connection. A role having theLOGINattribute can be thought of as a user. Roles without this attribute are useful for managing database privileges, but are not users in the usual sense of the word. If not specified,NOLOGINis the default, except whenCREATE ROLEis invoked through its alternative spellingCREATE USER.\nThese clauses determine whether a role is a replication role. A role must have this attribute (or be a superuser) in order to be able to connect to the server in replication mode (physical or logical replication) and in order to be able to create or drop replication slots. A role having theREPLICATIONattribute is a very highly privileged role, and should only be used on roles actually used for replication. If not specified,NOREPLICATIONis the default. Only superuser roles or roles withREPLICATION",
    "metadata": {
      "doc_name": "sql-createrole",
      "section_title": "Parameters",
      "url": "https://www.postgresql.org/docs/16/sql-createrole.html"
    }
  },
  {
    "chunk_id": 4,
    "text": "clauses determine whether a role is a replication role. A role must have this attribute (or be a superuser) in order to be able to connect to the server in replication mode (physical or logical replication) and in order to be able to create or drop replication slots. A role having theREPLICATIONattribute is a very highly privileged role, and should only be used on roles actually used for replication. If not specified,NOREPLICATIONis the default. Only superuser roles or roles withREPLICATIONcan specifyREPLICATION.\nThese clauses determine whether a role bypasses every row-level security (RLS) policy.NOBYPASSRLSis the default. Only superuser roles or roles withBYPASSRLScan specifyBYPASSRLS.\nNote that pg_dump will setrow_securitytoOFFby default, to ensure all contents of a table are dumped out. If the user running pg_dump does not have appropriate permissions, an error will be returned. However, superusers and the owner of the table being dumped always bypass RLS.\nIf role can log in, this specifies how many concurrent connections the role can make. -1 (the default) means no limit. Note that only normal connections are counted towards this limit. Neither prepared transactions nor background worker connections are counted towards this limit.\nSets the role's password. (A password is only of use for roles having theLOGINattribute, but you can nonetheless define one for roles without it.) If you do not plan to use password authentication you can omit this option. If no password is specified, the password will be set to null and password authentication will always fail for that user. A null password can optionally be written explicitly asPASSWORD NULL.",
    "metadata": {
      "doc_name": "sql-createrole",
      "section_title": "Parameters",
      "url": "https://www.postgresql.org/docs/16/sql-createrole.html"
    }
  },
  {
    "chunk_id": 5,
    "text": "Specifying an empty string will also set the password to null, but that was not the case beforePostgreSQLversion 10. In earlier versions, an empty string could be used, or not, depending on the authentication method and the exact version, and libpq would refuse to use it in any case. To avoid the ambiguity, specifying an empty string should be avoided.\nThe password is always stored encrypted in the system catalogs. TheENCRYPTEDkeyword has no effect, but is accepted for backwards compatibility. The method of encryption is determined by the configuration parameterpassword_encryption. If the presented password string is already in MD5-encrypted or SCRAM-encrypted format, then it is stored as-is regardless ofpassword_encryption(since the system cannot decrypt the specified encrypted password string, to encrypt it in a different format). This allows reloading of encrypted passwords during dump/restore.\nTheVALID UNTILclause sets a date and time after which the role's password is no longer valid. If this clause is omitted the password will be valid for all time.\nTheIN ROLEclause causes the new role to be automatically added as a member of the specified existing roles. The new membership will have theSEToption enabled and theADMINoption disabled. TheINHERIToption will be enabled unless theNOINHERIToption is specified.\nIN GROUPis an obsolete spelling ofIN ROLE.\nTheROLEclause causes one or more specified existing roles to be automatically added as members, with theSEToption enabled. This in effect makes the new role a“group”. Roles named in this clause with the role-levelINHERITattribute will have theINHERIToption enabled in the new membership. New memberships will have theADMINoption disabled.\nTheADMINclause has the same effect asROLE, but the named roles are added as members of the new role withADMINenabled, giving them the right to grant membership in the new role to others.\nTheUSERclause is an obsolete spelling of theROLEclause.\nTheSYSIDclause is ignored, but is accepted for backwards compatibility.",
    "metadata": {
      "doc_name": "sql-createrole",
      "section_title": "Note",
      "url": "https://www.postgresql.org/docs/16/sql-createrole.html"
    }
  },
  {
    "chunk_id": 6,
    "text": "UseALTER ROLEto change the attributes of a role, andDROP ROLEto remove a role. All the attributes specified byCREATE ROLEcan be modified by laterALTER ROLEcommands.\nThe preferred way to add and remove members of roles that are being used as groups is to useGRANTandREVOKE.\nTheVALID UNTILclause defines an expiration time for a password only, not for the role per se. In particular, the expiration time is not enforced when logging in using a non-password-based authentication method.\nThe role attributes defined here are non-inheritable, i.e., being a member of a role with, e.g.,CREATEDBwill not allow the member to create new databases even if the membership grant has theINHERIToption. Of course, if the membership grant has theSEToption the member role would be able toSET ROLEto the createdb role and then create a new database.\nThe membership grants created by theIN ROLE,ROLE, andADMINclauses have the role executing this command as the grantor.\nTheINHERITattribute is the default for reasons of backwards compatibility: in prior releases ofPostgreSQL, users always had access to all privileges of groups they were members of. However,NOINHERITprovides a closer match to the semantics specified in the SQL standard.\nPostgreSQLincludes a programcreateuserthat has the same functionality asCREATE ROLE(in fact, it calls this command) but can be run from the command shell.\nTheCONNECTION LIMIToption is only enforced approximately; if two new sessions start at about the same time when just one connection“slot”remains for the role, it is possible that both will fail. Also, the limit is never enforced for superusers.\nCaution must be exercised when specifying an unencrypted password with this command. The password will be transmitted to the server in cleartext, and it might also be logged in the client's command history or the server log. The commandcreateuser, however, transmits the password encrypted. Also,psqlcontains a command\\passwordthat can be used to safely change the password later.",
    "metadata": {
      "doc_name": "sql-createrole",
      "section_title": "Notes",
      "url": "https://www.postgresql.org/docs/16/sql-createrole.html"
    }
  },
  {
    "chunk_id": 7,
    "text": "Create a role that can log in, but don't give it a password:\n\n\nCODE:\n\nCREATE ROLE jonathan LOGIN;\n\nCreate a role with a password:\n\n\nCODE:\n\nCREATE USER davide WITH PASSWORD 'jw8s0F4';\n\n(CREATE USERis the same asCREATE ROLEexcept that it impliesLOGIN.)\nCreate a role with a password that is valid until the end of 2004. After one second has ticked in 2005, the password is no longer valid.\n\n\nCODE:\n\nCREATE ROLE miriam WITH LOGIN PASSWORD 'jw8s0F4' VALID UNTIL '2005-01-01';\n\nCreate a role that can create databases and manage roles:\n\n\nCODE:\n\nCREATE ROLE admin WITH CREATEDB CREATEROLE;",
    "metadata": {
      "doc_name": "sql-createrole",
      "section_title": "Examples",
      "url": "https://www.postgresql.org/docs/16/sql-createrole.html"
    }
  },
  {
    "chunk_id": 8,
    "text": "TheCREATE ROLEstatement is in the SQL standard, but the standard only requires the syntax\n\n\nCODE:\n\nCREATE ROLE name [ WITH ADMIN role_name ]\n\nMultiple initial administrators, and all the other options ofCREATE ROLE, arePostgreSQLextensions.\nThe SQL standard defines the concepts of users and roles, but it regards them as distinct concepts and leaves all commands defining users to be specified by each database implementation. InPostgreSQLwe have chosen to unify users and roles into a single kind of entity. Roles therefore have many more optional attributes than they do in the standard.\nThe behavior specified by the SQL standard is most closely approximated creating SQL-standard users asPostgreSQLroles with theNOINHERIToption, and SQL-standard roles asPostgreSQLroles with theINHERIToption.",
    "metadata": {
      "doc_name": "sql-createrole",
      "section_title": "Compatibility",
      "url": "https://www.postgresql.org/docs/16/sql-createrole.html"
    }
  },
  {
    "chunk_id": 0,
    "text": "CREATE TABLE — define a new table",
    "metadata": {
      "doc_name": "sql-createtable",
      "section_title": "CREATE TABLE",
      "url": "https://www.postgresql.org/docs/16/sql-createtable.html"
    }
  },
  {
    "chunk_id": 1,
    "text": "CODE:\n\nCREATE [ [ GLOBAL | LOCAL ] { TEMPORARY | TEMP } | UNLOGGED ] TABLE [ IF NOT EXISTS ] table_name ( [\n  { column_name data_type [ STORAGE { PLAIN | EXTERNAL | EXTENDED | MAIN | DEFAULT } ] [ COMPRESSION compression_method ] [ COLLATE collation ] [ column_constraint [ ... ] ]\n    | table_constraint\n    | LIKE source_table [ like_option ... ] }\n    [, ... ]\n] )\n[ INHERITS ( parent_table [, ... ] ) ]\n[ PARTITION BY { RANGE | LIST | HASH } ( { column_name | ( expression ) } [ COLLATE collation ] [ opclass ] [, ... ] ) ]\n[ USING method ]\n[ WITH ( storage_parameter [= value] [, ... ] ) | WITHOUT OIDS ]\n[ ON COMMIT { PRESERVE ROWS | DELETE ROWS | DROP } ]\n[ TABLESPACE tablespace_name ]\n\nCREATE [ [ GLOBAL | LOCAL ] { TEMPORARY | TEMP } | UNLOGGED ] TABLE [ IF NOT EXISTS ] table_name\n    OF type_name [ (\n  { column_name [ WITH OPTIONS ] [ column_constraint [ ... ] ]\n    | table_constraint }\n    [, ... ]\n) ]\n[ PARTITION BY { RANGE | LIST | HASH } ( { column_name | ( expression ) } [ COLLATE collation ] [ opclass ] [, ... ] ) ]\n[ USING method ]\n[ WITH ( storage_parameter [= value] [, ... ] ) | WITHOUT OIDS ]\n[ ON COMMIT { PRESERVE ROWS | DELETE ROWS | DROP } ]\n[ TABLESPACE tablespace_name ]\n\nCREATE [ [ GLOBAL | LOCAL ] { TEMPORARY | TEMP } | UNLOGGED ] TABLE [ IF NOT EXISTS ] table_name\n    PARTITION OF parent_table [ (\n  { column_name [ WITH OPTIONS ] [ column_constraint [ ... ] ]\n    | table_constraint }\n    [, ... ]\n) ] { FOR VALUES partition_bound_spec | DEFAULT }\n[ PARTITION BY { RANGE | LIST | HASH } ( { column_name | ( expression ) } [ COLLATE collation ] [ opclass ] [, ... ] ) ]\n[ USING method ]\n[ WITH ( storage_parameter [= value] [, ... ] ) | WITHOUT OIDS ]\n[ ON COMMIT { PRESERVE ROWS | DELETE ROWS | DROP } ]\n[ TABLESPACE tablespace_name ]\n\nwhere column_constraint is:\n\n[ CONSTRAINT constraint_name ]\n{ NOT NULL |\n  NULL |\n  CHECK ( expression ) [ NO IN",
    "metadata": {
      "doc_name": "sql-createtable",
      "section_title": "Synopsis",
      "url": "https://www.postgresql.org/docs/16/sql-createtable.html"
    }
  },
  {
    "chunk_id": 2,
    "text": "{ RANGE | LIST | HASH } ( { column_name | ( expression ) } [ COLLATE collation ] [ opclass ] [, ... ] ) ]\n[ USING method ]\n[ WITH ( storage_parameter [= value] [, ... ] ) | WITHOUT OIDS ]\n[ ON COMMIT { PRESERVE ROWS | DELETE ROWS | DROP } ]\n[ TABLESPACE tablespace_name ]\n\nwhere column_constraint is:\n\n[ CONSTRAINT constraint_name ]\n{ NOT NULL |\n  NULL |\n  CHECK ( expression ) [ NO INHERIT ] |\n  DEFAULT default_expr |\n  GENERATED ALWAYS AS ( generation_expr ) STORED |\n  GENERATED { ALWAYS | BY DEFAULT } AS IDENTITY [ ( sequence_options ) ] |\n  UNIQUE [ NULLS [ NOT ] DISTINCT ] index_parameters |\n  PRIMARY KEY index_parameters |\n  REFERENCES reftable [ ( refcolumn ) ] [ MATCH FULL | MATCH PARTIAL | MATCH SIMPLE ]\n    [ ON DELETE referential_action ] [ ON UPDATE referential_action ] }\n[ DEFERRABLE | NOT DEFERRABLE ] [ INITIALLY DEFERRED | INITIALLY IMMEDIATE ]\n\nand table_constraint is:\n\n[ CONSTRAINT constraint_name ]\n{ CHECK ( expression ) [ NO INHERIT ] |\n  UNIQUE [ NULLS [ NOT ] DISTINCT ] ( column_name [, ... ] ) index_parameters |\n  PRIMARY KEY ( column_name [, ... ] ) index_parameters |\n  EXCLUDE [ USING index_method ] ( exclude_element WITH operator [, ... ] ) index_parameters [ WHERE ( predicate ) ] |\n  FOREIGN KEY ( column_name [, ... ] ) REFERENCES reftable [ ( refcolumn [, ... ] ) ]\n    [ MATCH FULL | MATCH PARTIAL | MATCH SIMPLE ] [ ON DELETE referential_action ] [ ON UPDATE referential_action ] }\n[ DEFERRABLE | NOT DEFERRABLE ] [ INITIALLY DEFERRED | INITIALLY IMMEDIATE ]\n\nand like_option is:\n\n{ INCLUDING | EXCLUDING } { COMMENTS | COMPRESSION | CONSTRAINTS | DEFAULTS | GENERATED | IDENTITY | INDEXES | STATISTICS | STORAGE | ALL }\n\nand partition_bound_spec is:\n\nIN ( partition_bound_expr [, ...] ) |\nFROM ( { partition_bound_expr | MINVALUE | MAXVALUE } [, ...] )\n  TO ( { partition_bound_expr | MINVALUE | MAXVALUE } [, ...] ) |\nWITH ( MODULUS numeric_literal, REMAINDER numeric_literal )\n\nindex_parameters in UNIQUE, PRIMARY KEY, and EXCLUDE constraints are:\n\n[ INCLUDE ( column_name [, ... ]",
    "metadata": {
      "doc_name": "sql-createtable",
      "section_title": "Synopsis",
      "url": "https://www.postgresql.org/docs/16/sql-createtable.html"
    }
  },
  {
    "chunk_id": 3,
    "text": "ENTITY | INDEXES | STATISTICS | STORAGE | ALL }\n\nand partition_bound_spec is:\n\nIN ( partition_bound_expr [, ...] ) |\nFROM ( { partition_bound_expr | MINVALUE | MAXVALUE } [, ...] )\n  TO ( { partition_bound_expr | MINVALUE | MAXVALUE } [, ...] ) |\nWITH ( MODULUS numeric_literal, REMAINDER numeric_literal )\n\nindex_parameters in UNIQUE, PRIMARY KEY, and EXCLUDE constraints are:\n\n[ INCLUDE ( column_name [, ... ] ) ]\n[ WITH ( storage_parameter [= value] [, ... ] ) ]\n[ USING INDEX TABLESPACE tablespace_name ]\n\nexclude_element in an EXCLUDE constraint is:\n\n{ column_name | ( expression ) } [ COLLATE collation ] [ opclass [ ( opclass_parameter = value [, ... ] ) ] ] [ ASC | DESC ] [ NULLS { FIRST | LAST } ]\n\nreferential_action in a FOREIGN KEY/REFERENCES constraint is:\n\n{ NO ACTION | RESTRICT | CASCADE | SET NULL [ ( column_name [, ... ] ) ] | SET DEFAULT [ ( column_name [, ... ] ) ] }",
    "metadata": {
      "doc_name": "sql-createtable",
      "section_title": "Synopsis",
      "url": "https://www.postgresql.org/docs/16/sql-createtable.html"
    }
  },
  {
    "chunk_id": 4,
    "text": "CREATE TABLEwill create a new, initially empty table in the current database. The table will be owned by the user issuing the command.\nIf a schema name is given (for example,CREATE TABLE myschema.mytable ...) then the table is created in the specified schema. Otherwise it is created in the current schema. Temporary tables exist in a special schema, so a schema name cannot be given when creating a temporary table. The name of the table must be distinct from the name of any other relation (table, sequence, index, view, materialized view, or foreign table) in the same schema.\nCREATE TABLEalso automatically creates a data type that represents the composite type corresponding to one row of the table. Therefore, tables cannot have the same name as any existing data type in the same schema.\nThe optional constraint clauses specify constraints (tests) that new or updated rows must satisfy for an insert or update operation to succeed. A constraint is an SQL object that helps define the set of valid values in the table in various ways.\nThere are two ways to define constraints: table constraints and column constraints. A column constraint is defined as part of a column definition. A table constraint definition is not tied to a particular column, and it can encompass more than one column. Every column constraint can also be written as a table constraint; a column constraint is only a notational convenience for use when the constraint only affects one column.\nTo be able to create a table, you must haveUSAGEprivilege on all column types or the type in theOFclause, respectively.",
    "metadata": {
      "doc_name": "sql-createtable",
      "section_title": "Description",
      "url": "https://www.postgresql.org/docs/16/sql-createtable.html"
    }
  },
  {
    "chunk_id": 5,
    "text": "If specified, the table is created as a temporary table. Temporary tables are automatically dropped at the end of a session, or optionally at the end of the current transaction (seeON COMMITbelow). The default search_path includes the temporary schema first and so identically named existing permanent tables are not chosen for new plans while the temporary table exists, unless they are referenced with schema-qualified names. Any indexes created on a temporary table are automatically temporary as well.\nTheautovacuum daemoncannot access and therefore cannot vacuum or analyze temporary tables. For this reason, appropriate vacuum and analyze operations should be performed via session SQL commands. For example, if a temporary table is going to be used in complex queries, it is wise to runANALYZEon the temporary table after it is populated.\nOptionally,GLOBALorLOCALcan be written beforeTEMPORARYorTEMP. This presently makes no difference inPostgreSQLand is deprecated; seeCompatibilitybelow.\nIf specified, the table is created as an unlogged table. Data written to unlogged tables is not written to the write-ahead log (seeChapter 30), which makes them considerably faster than ordinary tables. However, they are not crash-safe: an unlogged table is automatically truncated after a crash or unclean shutdown. The contents of an unlogged table are also not replicated to standby servers. Any indexes created on an unlogged table are automatically unlogged as well.\nIf this is specified, any sequences created together with the unlogged table (for identity or serial columns) are also created as unlogged.\nDo not throw an error if a relation with the same name already exists. A notice is issued in this case. Note that there is no guarantee that the existing relation is anything like the one that would have been created.\nThe name (optionally schema-qualified) of the table to be created.\nCreates atyped table, which takes its structure from the specified composite type (name optionally schema-qualified). A typed table is tied to its type; for example the table will be dropped if the type is dropped (withDROP TYPE ... CASCADE).\nWhen a typed table is created, then the data types of the columns are determined by the underlying composite type and are not specified by theCREATE TABLEcommand. But theCREATE TABLEcommand can add defaults and constraints to the table and can specify storage parameters.\nThe name of a column to be created in the new table.\nThe data type of the column. This can include array specifiers.",
    "metadata": {
      "doc_name": "sql-createtable",
      "section_title": "Parameters",
      "url": "https://www.postgresql.org/docs/16/sql-createtable.html"
    }
  },
  {
    "chunk_id": 6,
    "text": "to its type; for example the table will be dropped if the type is dropped (withDROP TYPE ... CASCADE).\nWhen a typed table is created, then the data types of the columns are determined by the underlying composite type and are not specified by theCREATE TABLEcommand. But theCREATE TABLEcommand can add defaults and constraints to the table and can specify storage parameters.\nThe name of a column to be created in the new table.\nThe data type of the column. This can include array specifiers. For more information on the data types supported byPostgreSQL, refer toChapter 8.\nTheCOLLATEclause assigns a collation to the column (which must be of a collatable data type). If not specified, the column data type's default collation is used.\nThis form sets the storage mode for the column. This controls whether this column is held inline or in a secondaryTOASTtable, and whether the data should be compressed or not.PLAINmust be used for fixed-length values such asintegerand is inline, uncompressed.MAINis for inline, compressible data.EXTERNALis for external, uncompressed data, andEXTENDEDis for external, compressed data. WritingDEFAULTsets the storage mode to the default mode for the column's data type.EXTENDEDis the default for most data types that support non-PLAINstorage. Use ofEXTERNALwill make substring operations on very largetextandbyteavalues run faster, at the penalty of increased storage space. SeeSection 73.2for more information.\nTheCOMPRESSIONclause sets the compression method for the column. Compression is supported only for variable-width data types, and is used only when the column's storage mode ismainorextended. (SeeALTER TABLEfor information on column storage modes.) Setting this property for a partitioned table has no direct effect, because such tables have no storage of their own, but the configured value will be inherited by newly-created partitions. The supported compression methods arepglzandlz4. (lz4is available only if--with-lz4was used when buildingPostgreSQL.) In addition,compression_methodcan bedefaultto explicitly specify the default behavior, which is to consult thedefault_toast_compressionsetting at the time of data insertion to determine the method to use.\nThe optionalINHERITSclause specifies a list of tables from which the new table automatically inherits all columns. Parent tables can be plain tables or foreign tables.\nUse ofINHERITScreates a persistent relationship",
    "metadata": {
      "doc_name": "sql-createtable",
      "section_title": "Parameters",
      "url": "https://www.postgresql.org/docs/16/sql-createtable.html"
    }
  },
  {
    "chunk_id": 7,
    "text": ". (lz4is available only if--with-lz4was used when buildingPostgreSQL.) In addition,compression_methodcan bedefaultto explicitly specify the default behavior, which is to consult thedefault_toast_compressionsetting at the time of data insertion to determine the method to use.\nThe optionalINHERITSclause specifies a list of tables from which the new table automatically inherits all columns. Parent tables can be plain tables or foreign tables.\nUse ofINHERITScreates a persistent relationship between the new child table and its parent table(s). Schema modifications to the parent(s) normally propagate to children as well, and by default the data of the child table is included in scans of the parent(s).\nIf the same column name exists in more than one parent table, an error is reported unless the data types of the columns match in each of the parent tables. If there is no conflict, then the duplicate columns are merged to form a single column in the new table. If the column name list of the new table contains a column name that is also inherited, the data type must likewise match the inherited column(s), and the column definitions are merged into one. If the new table explicitly specifies a default value for the column, this default overrides any defaults from inherited declarations of the column. Otherwise, any parents that specify default values for the column must all specify the same default, or an error will be reported.\nCHECKconstraints are merged in essentially the same way as columns: if multiple parent tables and/or the new table definition contain identically-namedCHECKconstraints, these constraints must all have the same check expression, or an error will be reported. Constraints having the same name and expression will be merged into one copy. A constraint markedNO INHERITin a parent will not be considered. Notice that an unnamedCHECKconstraint in the new table will never be merged, since a unique name will always be chosen for it.\nColumnSTORAGEsettings are also copied from parent tables.\nIf a column in the parent table is an identity column, that property is not inherited. A column in the child table can be declared identity column if desired.\nThe optionalPARTITION BYclause specifies a strategy of partitioning the table. The table thus created is called apartitionedtable. The parenthesized list of columns or expressions forms thepartition keyfor the table. When using range or hash partitioning, the partition key can include multiple columns or expressions (up to 32, but this limit can be",
    "metadata": {
      "doc_name": "sql-createtable",
      "section_title": "Parameters",
      "url": "https://www.postgresql.org/docs/16/sql-createtable.html"
    }
  },
  {
    "chunk_id": 8,
    "text": "column in the parent table is an identity column, that property is not inherited. A column in the child table can be declared identity column if desired.\nThe optionalPARTITION BYclause specifies a strategy of partitioning the table. The table thus created is called apartitionedtable. The parenthesized list of columns or expressions forms thepartition keyfor the table. When using range or hash partitioning, the partition key can include multiple columns or expressions (up to 32, but this limit can be altered when buildingPostgreSQL), but for list partitioning, the partition key must consist of a single column or expression.\nRange and list partitioning require a btree operator class, while hash partitioning requires a hash operator class. If no operator class is specified explicitly, the default operator class of the appropriate type will be used; if no default operator class exists, an error will be raised. When hash partitioning is used, the operator class used must implement support function 2 (seeSection 38.16.3for details).\nA partitioned table is divided into sub-tables (called partitions), which are created using separateCREATE TABLEcommands. The partitioned table is itself empty. A data row inserted into the table is routed to a partition based on the value of columns or expressions in the partition key. If no existing partition matches the values in the new row, an error will be reported.\nPartitioned tables do not supportEXCLUDEconstraints; however, you can define these constraints on individual partitions.\nSeeSection 5.11for more discussion on table partitioning.\nCreates the table as apartitionof the specified parent table. The table can be created either as a partition for specific values usingFOR VALUESor as a default partition usingDEFAULT. Any indexes, constraints and user-defined row-level triggers that exist in the parent table are cloned on the new partition.\nThepartition_bound_specmust correspond to the partitioning method and partition key of the parent table, and must not overlap with any existing partition of that parent. The form withINis used for list partitioning, the form withFROMandTOis used for range partitioning, and the form withWITHis used for hash partitioning.\npartition_bound_expris any variable-free expression (subqueries, window functions, aggregate functions, and set-returning functions are not allowed). Its data type must match the data type of the corresponding partition key column. The expression is evaluated once at table creation time, so it can even contain volatile",
    "metadata": {
      "doc_name": "sql-createtable",
      "section_title": "Parameters",
      "url": "https://www.postgresql.org/docs/16/sql-createtable.html"
    }
  },
  {
    "chunk_id": 9,
    "text": "existing partition of that parent. The form withINis used for list partitioning, the form withFROMandTOis used for range partitioning, and the form withWITHis used for hash partitioning.\npartition_bound_expris any variable-free expression (subqueries, window functions, aggregate functions, and set-returning functions are not allowed). Its data type must match the data type of the corresponding partition key column. The expression is evaluated once at table creation time, so it can even contain volatile expressions such asCURRENT_TIMESTAMP.\nWhen creating a list partition,NULLcan be specified to signify that the partition allows the partition key column to be null. However, there cannot be more than one such list partition for a given parent table.NULLcannot be specified for range partitions.\nWhen creating a range partition, the lower bound specified withFROMis an inclusive bound, whereas the upper bound specified withTOis an exclusive bound. That is, the values specified in theFROMlist are valid values of the corresponding partition key columns for this partition, whereas those in theTOlist are not. Note that this statement must be understood according to the rules of row-wise comparison (Section 9.24.5). For example, givenPARTITION BY RANGE (x,y), a partition boundFROM (1, 2) TO (3, 4)allowsx=1with anyy>=2,x=2with any non-nully, andx=3with anyy<4.\nThe special valuesMINVALUEandMAXVALUEmay be used when creating a range partition to indicate that there is no lower or upper bound on the column's value. For example, a partition defined usingFROM (MINVALUE) TO (10)allows any values less than 10, and a partition defined usingFROM (10) TO (MAXVALUE)allows any values greater than or equal to 10.\nWhen creating a range partition involving more than one column, it can also make sense to useMAXVALUEas part of the lower bound, andMINVALUEas part of the upper bound. For example, a partition defined usingFROM (0, MAXVALUE) TO (10, MAXVALUE)allows any rows where the first partition key column is greater than 0 and less than or equal to 10. Similarly, a partition defined usingFROM ('a', MINVALUE) TO ('b', MINVALUE)allows any rows where the first partition key column starts with \"a\".\nNote that ifMINVALUEorMAXVALUEis",
    "metadata": {
      "doc_name": "sql-createtable",
      "section_title": "Parameters",
      "url": "https://www.postgresql.org/docs/16/sql-createtable.html"
    }
  },
  {
    "chunk_id": 10,
    "text": "lower bound, andMINVALUEas part of the upper bound. For example, a partition defined usingFROM (0, MAXVALUE) TO (10, MAXVALUE)allows any rows where the first partition key column is greater than 0 and less than or equal to 10. Similarly, a partition defined usingFROM ('a', MINVALUE) TO ('b', MINVALUE)allows any rows where the first partition key column starts with \"a\".\nNote that ifMINVALUEorMAXVALUEis used for one column of a partitioning bound, the same value must be used for all subsequent columns. For example,(10, MINVALUE, 0)is not a valid bound; you should write(10, MINVALUE, MINVALUE).\nAlso note that some element types, such astimestamp, have a notion of \"infinity\", which is just another value that can be stored. This is different fromMINVALUEandMAXVALUE, which are not real values that can be stored, but rather they are ways of saying that the value is unbounded.MAXVALUEcan be thought of as being greater than any other value, including \"infinity\" andMINVALUEas being less than any other value, including \"minus infinity\". Thus the rangeFROM ('infinity') TO (MAXVALUE)is not an empty range; it allows precisely one value to be stored — \"infinity\".\nIfDEFAULTis specified, the table will be created as the default partition of the parent table. This option is not available for hash-partitioned tables. A partition key value not fitting into any other partition of the given parent will be routed to the default partition.\nWhen a table has an existingDEFAULTpartition and a new partition is added to it, the default partition must be scanned to verify that it does not contain any rows which properly belong in the new partition. If the default partition contains a large number of rows, this may be slow. The scan will be skipped if the default partition is a foreign table or if it has a constraint which proves that it cannot contain rows which should be placed in the new partition.\nWhen creating a hash partition, a modulus and remainder must be specified. The modulus must be a positive integer, and the remainder must be a non-negative integer less than the modulus. Typically, when initially setting up a hash-partitioned table, you should choose a modulus equal to the number of partitions and assign every table the same modulus and a different remainder (see examples, below). However, it is",
    "metadata": {
      "doc_name": "sql-createtable",
      "section_title": "Parameters",
      "url": "https://www.postgresql.org/docs/16/sql-createtable.html"
    }
  },
  {
    "chunk_id": 11,
    "text": "has a constraint which proves that it cannot contain rows which should be placed in the new partition.\nWhen creating a hash partition, a modulus and remainder must be specified. The modulus must be a positive integer, and the remainder must be a non-negative integer less than the modulus. Typically, when initially setting up a hash-partitioned table, you should choose a modulus equal to the number of partitions and assign every table the same modulus and a different remainder (see examples, below). However, it is not required that every partition have the same modulus, only that every modulus which occurs among the partitions of a hash-partitioned table is a factor of the next larger modulus. This allows the number of partitions to be increased incrementally without needing to move all the data at once. For example, suppose you have a hash-partitioned table with 8 partitions, each of which has modulus 8, but find it necessary to increase the number of partitions to 16. You can detach one of the modulus-8 partitions, create two new modulus-16 partitions covering the same portion of the key space (one with a remainder equal to the remainder of the detached partition, and the other with a remainder equal to that value plus 8), and repopulate them with data. You can then repeat this -- perhaps at a later time -- for each modulus-8 partition until none remain. While this may still involve a large amount of data movement at each step, it is still better than having to create a whole new table and move all the data at once.\nA partition must have the same column names and types as the partitioned table to which it belongs. Modifications to the column names or types of a partitioned table will automatically propagate to all partitions.CHECKconstraints will be inherited automatically by every partition, but an individual partition may specify additionalCHECKconstraints; additional constraints with the same name and condition as in the parent will be merged with the parent constraint. Defaults may be specified separately for each partition. But note that a partition's default value is not applied when inserting a tuple through a partitioned table.\nRows inserted into a partitioned table will be automatically routed to the correct partition. If no suitable partition exists, an error will occur.\nOperations such asTRUNCATEwhich normally affect a table and all of its inheritance children will cascade to all partitions, but may also be performed on an individual partition.\nNote that creating a partition usingPARTITION OFrequires taking anACCESS EXCLUSIVElock on",
    "metadata": {
      "doc_name": "sql-createtable",
      "section_title": "Parameters",
      "url": "https://www.postgresql.org/docs/16/sql-createtable.html"
    }
  },
  {
    "chunk_id": 12,
    "text": "partition. But note that a partition's default value is not applied when inserting a tuple through a partitioned table.\nRows inserted into a partitioned table will be automatically routed to the correct partition. If no suitable partition exists, an error will occur.\nOperations such asTRUNCATEwhich normally affect a table and all of its inheritance children will cascade to all partitions, but may also be performed on an individual partition.\nNote that creating a partition usingPARTITION OFrequires taking anACCESS EXCLUSIVElock on the parent partitioned table. Likewise, dropping a partition withDROP TABLErequires taking anACCESS EXCLUSIVElock on the parent table. It is possible to useALTER TABLE ATTACH/DETACH PARTITIONto perform these operations with a weaker lock, thus reducing interference with concurrent operations on the partitioned table.\nTheLIKEclause specifies a table from which the new table automatically copies all column names, their data types, and their not-null constraints.\nUnlikeINHERITS, the new table and original table are completely decoupled after creation is complete. Changes to the original table will not be applied to the new table, and it is not possible to include data of the new table in scans of the original table.\nAlso unlikeINHERITS, columns and constraints copied byLIKEare not merged with similarly named columns and constraints. If the same name is specified explicitly or in anotherLIKEclause, an error is signaled.\nThe optionallike_optionclauses specify which additional properties of the original table to copy. SpecifyingINCLUDINGcopies the property, specifyingEXCLUDINGomits the property.EXCLUDINGis the default. If multiple specifications are made for the same kind of object, the last one is used. The available options are:\nComments for the copied columns, constraints, and indexes will be copied. The default behavior is to exclude comments, resulting in the copied columns and constraints in the new table having no comments.\nCompression method of the columns will be copied. The default behavior is to exclude compression methods, resulting in columns having the default compression method.\nCHECKconstraints will be copied. No distinction is made between column constraints and table constraints. Not-null constraints are always copied to the new table.\nDefault expressions for the copied column definitions will be copied. Otherwise, default expressions are not copied, resulting in the copied columns in the new table having null defaults. Note that copying defaults that call database-modification functions, such asnextval, may create a functional linkage between the original and new tables.\nAny generation expressions of copied",
    "metadata": {
      "doc_name": "sql-createtable",
      "section_title": "Parameters",
      "url": "https://www.postgresql.org/docs/16/sql-createtable.html"
    }
  },
  {
    "chunk_id": 13,
    "text": "columns having the default compression method.\nCHECKconstraints will be copied. No distinction is made between column constraints and table constraints. Not-null constraints are always copied to the new table.\nDefault expressions for the copied column definitions will be copied. Otherwise, default expressions are not copied, resulting in the copied columns in the new table having null defaults. Note that copying defaults that call database-modification functions, such asnextval, may create a functional linkage between the original and new tables.\nAny generation expressions of copied column definitions will be copied. By default, new columns will be regular base columns.\nAny identity specifications of copied column definitions will be copied. A new sequence is created for each identity column of the new table, separate from the sequences associated with the old table.\nIndexes,PRIMARY KEY,UNIQUE, andEXCLUDEconstraints on the original table will be created on the new table. Names for the new indexes and constraints are chosen according to the default rules, regardless of how the originals were named. (This behavior avoids possible duplicate-name failures for the new indexes.)\nExtended statistics are copied to the new table.\nSTORAGEsettings for the copied column definitions will be copied. The default behavior is to excludeSTORAGEsettings, resulting in the copied columns in the new table having type-specific default settings. For more onSTORAGEsettings, seeSection 73.2.\nINCLUDING ALLis an abbreviated form selecting all the available individual options. (It could be useful to write individualEXCLUDINGclauses afterINCLUDING ALLto select all but some specific options.)\nTheLIKEclause can also be used to copy column definitions from views, foreign tables, or composite types. Inapplicable options (e.g.,INCLUDING INDEXESfrom a view) are ignored.\nAn optional name for a column or table constraint. If the constraint is violated, the constraint name is present in error messages, so constraint names likecol must be positivecan be used to communicate helpful constraint information to client applications. (Double-quotes are needed to specify constraint names that contain spaces.) If a constraint name is not specified, the system generates a name.\nThe column is not allowed to contain null values.\nThe column is allowed to contain null values. This is the default.\nThis clause is only provided for compatibility with non-standard SQL databases. Its use is discouraged in new applications.\nTheCHECKclause specifies an expression producing a Boolean result which new or updated rows must satisfy for an insert or update operation to succeed. Expressions evaluating to TRUE or UNKNOWN succeed.",
    "metadata": {
      "doc_name": "sql-createtable",
      "section_title": "Parameters",
      "url": "https://www.postgresql.org/docs/16/sql-createtable.html"
    }
  },
  {
    "chunk_id": 14,
    "text": "constraint names that contain spaces.) If a constraint name is not specified, the system generates a name.\nThe column is not allowed to contain null values.\nThe column is allowed to contain null values. This is the default.\nThis clause is only provided for compatibility with non-standard SQL databases. Its use is discouraged in new applications.\nTheCHECKclause specifies an expression producing a Boolean result which new or updated rows must satisfy for an insert or update operation to succeed. Expressions evaluating to TRUE or UNKNOWN succeed. Should any row of an insert or update operation produce a FALSE result, an error exception is raised and the insert or update does not alter the database. A check constraint specified as a column constraint should reference that column's value only, while an expression appearing in a table constraint can reference multiple columns.\nCurrently,CHECKexpressions cannot contain subqueries nor refer to variables other than columns of the current row (seeSection 5.4.1). The system columntableoidmay be referenced, but not any other system column.\nA constraint marked withNO INHERITwill not propagate to child tables.\nWhen a table has multipleCHECKconstraints, they will be tested for each row in alphabetical order by name, after checkingNOT NULLconstraints. (PostgreSQLversions before 9.5 did not honor any particular firing order forCHECKconstraints.)\nTheDEFAULTclause assigns a default data value for the column whose column definition it appears within. The value is any variable-free expression (in particular, cross-references to other columns in the current table are not allowed). Subqueries are not allowed either. The data type of the default expression must match the data type of the column.\nThe default expression will be used in any insert operation that does not specify a value for the column. If there is no default for a column, then the default is null.\nThis clause creates the column as agenerated column. The column cannot be written to, and when read the result of the specified expression will be returned.\nThe keywordSTOREDis required to signify that the column will be computed on write and will be stored on disk.\nThe generation expression can refer to other columns in the table, but not other generated columns. Any functions and operators used must be immutable. References to other tables are not allowed.\nThis clause creates the column as anidentity column. It will have an implicit sequence attached to it and in newly-inserted rows the column will automatically have values from the sequence assigned to it. Such a column is implicitlyNOT",
    "metadata": {
      "doc_name": "sql-createtable",
      "section_title": "Parameters",
      "url": "https://www.postgresql.org/docs/16/sql-createtable.html"
    }
  },
  {
    "chunk_id": 15,
    "text": "keywordSTOREDis required to signify that the column will be computed on write and will be stored on disk.\nThe generation expression can refer to other columns in the table, but not other generated columns. Any functions and operators used must be immutable. References to other tables are not allowed.\nThis clause creates the column as anidentity column. It will have an implicit sequence attached to it and in newly-inserted rows the column will automatically have values from the sequence assigned to it. Such a column is implicitlyNOT NULL.\nThe clausesALWAYSandBY DEFAULTdetermine how explicitly user-specified values are handled inINSERTandUPDATEcommands.\nIn anINSERTcommand, ifALWAYSis selected, a user-specified value is only accepted if theINSERTstatement specifiesOVERRIDING SYSTEM VALUE. IfBY DEFAULTis selected, then the user-specified value takes precedence. SeeINSERTfor details. (In theCOPYcommand, user-specified values are always used regardless of this setting.)\nIn anUPDATEcommand, ifALWAYSis selected, any update of the column to any value other thanDEFAULTwill be rejected. IfBY DEFAULTis selected, the column can be updated normally. (There is noOVERRIDINGclause for theUPDATEcommand.)\nThe optionalsequence_optionsclause can be used to override the parameters of the sequence. The available options include those shown forCREATE SEQUENCE, plusSEQUENCE NAMEname,LOGGED, andUNLOGGED, which allow selection of the name and persistence level of the sequence. WithoutSEQUENCE NAME, the system chooses an unused name for the sequence. WithoutLOGGEDorUNLOGGED, the sequence will have the same persistence level as the table.\nTheUNIQUEconstraint specifies that a group of one or more columns of a table can contain only unique values. The behavior of a unique table constraint is the same as that of a unique column constraint, with the additional capability to span multiple columns. The constraint therefore enforces that any two rows must differ in at least one of these columns.\nFor the purpose of a unique constraint, null values are not considered equal, unlessNULLS NOT DISTINCTis specified.\nEach unique constraint should name a set of columns that is different from the set of columns named by any other unique or primary key constraint defined for the table. (Otherwise, redundant unique constraints will be discarded.)\nWhen establishing a unique constraint for a multi-level partition hierarchy, all the columns in the partition key of the target partitioned table, as well as those of",
    "metadata": {
      "doc_name": "sql-createtable",
      "section_title": "Parameters",
      "url": "https://www.postgresql.org/docs/16/sql-createtable.html"
    }
  },
  {
    "chunk_id": 16,
    "text": "one of these columns.\nFor the purpose of a unique constraint, null values are not considered equal, unlessNULLS NOT DISTINCTis specified.\nEach unique constraint should name a set of columns that is different from the set of columns named by any other unique or primary key constraint defined for the table. (Otherwise, redundant unique constraints will be discarded.)\nWhen establishing a unique constraint for a multi-level partition hierarchy, all the columns in the partition key of the target partitioned table, as well as those of all its descendant partitioned tables, must be included in the constraint definition.\nAdding a unique constraint will automatically create a unique btree index on the column or group of columns used in the constraint.\nThe optionalINCLUDEclause adds to that index one or more columns that are simply“payload”: uniqueness is not enforced on them, and the index cannot be searched on the basis of those columns. However they can be retrieved by an index-only scan. Note that although the constraint is not enforced on included columns, it still depends on them. Consequently, some operations on such columns (e.g.,DROP COLUMN) can cause cascaded constraint and index deletion.\nThePRIMARY KEYconstraint specifies that a column or columns of a table can contain only unique (non-duplicate), nonnull values. Only one primary key can be specified for a table, whether as a column constraint or a table constraint.\nThe primary key constraint should name a set of columns that is different from the set of columns named by any unique constraint defined for the same table. (Otherwise, the unique constraint is redundant and will be discarded.)\nPRIMARY KEYenforces the same data constraints as a combination ofUNIQUEandNOT NULL. However, identifying a set of columns as the primary key also provides metadata about the design of the schema, since a primary key implies that other tables can rely on this set of columns as a unique identifier for rows.\nWhen placed on a partitioned table,PRIMARY KEYconstraints share the restrictions previously described forUNIQUEconstraints.\nAdding aPRIMARY KEYconstraint will automatically create a unique btree index on the column or group of columns used in the constraint.\nThe optionalINCLUDEclause adds to that index one or more columns that are simply“payload”: uniqueness is not enforced on them, and the index cannot be searched on the basis of those columns. However they can be retrieved by an index-only scan. Note that although the constraint is not enforced on included columns, it still depends on them. Consequently, some operations on such columns (",
    "metadata": {
      "doc_name": "sql-createtable",
      "section_title": "Parameters",
      "url": "https://www.postgresql.org/docs/16/sql-createtable.html"
    }
  },
  {
    "chunk_id": 17,
    "text": "Adding aPRIMARY KEYconstraint will automatically create a unique btree index on the column or group of columns used in the constraint.\nThe optionalINCLUDEclause adds to that index one or more columns that are simply“payload”: uniqueness is not enforced on them, and the index cannot be searched on the basis of those columns. However they can be retrieved by an index-only scan. Note that although the constraint is not enforced on included columns, it still depends on them. Consequently, some operations on such columns (e.g.,DROP COLUMN) can cause cascaded constraint and index deletion.\nTheEXCLUDEclause defines an exclusion constraint, which guarantees that if any two rows are compared on the specified column(s) or expression(s) using the specified operator(s), not all of these comparisons will returnTRUE. If all of the specified operators test for equality, this is equivalent to aUNIQUEconstraint, although an ordinary unique constraint will be faster. However, exclusion constraints can specify constraints that are more general than simple equality. For example, you can specify a constraint that no two rows in the table contain overlapping circles (seeSection 8.8) by using the&&operator. The operator(s) are required to be commutative.\nExclusion constraints are implemented using an index, so each specified operator must be associated with an appropriate operator class (seeSection 11.10) for the index access methodindex_method. Eachexclude_elementdefines a column of the index, so it can optionally specify a collation, an operator class, operator class parameters, and/or ordering options; these are described fully underCREATE INDEX.\nThe access method must supportamgettuple(seeChapter 64); at present this meansGINcannot be used. Although it's allowed, there is little point in using B-tree or hash indexes with an exclusion constraint, because this does nothing that an ordinary unique constraint doesn't do better. So in practice the access method will always beGiSTorSP-GiST.\nThepredicateallows you to specify an exclusion constraint on a subset of the table; internally this creates a partial index. Note that parentheses are required around the predicate.\nThese clauses specify a foreign key constraint, which requires that a group of one or more columns of the new table must only contain values that match values in the referenced column(s) of some row of the referenced table. If therefcolumnlist is omitted, the primary key of thereftableis used. Otherwise, therefcolumnlist must refer to the",
    "metadata": {
      "doc_name": "sql-createtable",
      "section_title": "Parameters",
      "url": "https://www.postgresql.org/docs/16/sql-createtable.html"
    }
  },
  {
    "chunk_id": 18,
    "text": "you to specify an exclusion constraint on a subset of the table; internally this creates a partial index. Note that parentheses are required around the predicate.\nThese clauses specify a foreign key constraint, which requires that a group of one or more columns of the new table must only contain values that match values in the referenced column(s) of some row of the referenced table. If therefcolumnlist is omitted, the primary key of thereftableis used. Otherwise, therefcolumnlist must refer to the columns of a non-deferrable unique or primary key constraint or be the columns of a non-partial unique index. The user must haveREFERENCESpermission on the referenced table (either the whole table, or the specific referenced columns). The addition of a foreign key constraint requires aSHARE ROW EXCLUSIVElock on the referenced table. Note that foreign key constraints cannot be defined between temporary tables and permanent tables.\nA value inserted into the referencing column(s) is matched against the values of the referenced table and referenced columns using the given match type. There are three match types:MATCH FULL,MATCH PARTIAL, andMATCH SIMPLE(which is the default).MATCH FULLwill not allow one column of a multicolumn foreign key to be null unless all foreign key columns are null; if they are all null, the row is not required to have a match in the referenced table.MATCH SIMPLEallows any of the foreign key columns to be null; if any of them are null, the row is not required to have a match in the referenced table.MATCH PARTIALis not yet implemented. (Of course,NOT NULLconstraints can be applied to the referencing column(s) to prevent these cases from arising.)\nIn addition, when the data in the referenced columns is changed, certain actions are performed on the data in this table's columns. TheON DELETEclause specifies the action to perform when a referenced row in the referenced table is being deleted. Likewise, theON UPDATEclause specifies the action to perform when a referenced column in the referenced table is being updated to a new value. If the row is updated, but the referenced column is not actually changed, no action is done. Referential actions other than theNO ACTIONcheck cannot be deferred, even if the constraint is declared deferrable. There are the following possible actions for each clause:\nProduce an error indicating that the deletion or update would create a foreign key constraint violation. If the constraint is deferred, this error will be produced at constraint check time if there still exist any",
    "metadata": {
      "doc_name": "sql-createtable",
      "section_title": "Parameters",
      "url": "https://www.postgresql.org/docs/16/sql-createtable.html"
    }
  },
  {
    "chunk_id": 19,
    "text": "table is being updated to a new value. If the row is updated, but the referenced column is not actually changed, no action is done. Referential actions other than theNO ACTIONcheck cannot be deferred, even if the constraint is declared deferrable. There are the following possible actions for each clause:\nProduce an error indicating that the deletion or update would create a foreign key constraint violation. If the constraint is deferred, this error will be produced at constraint check time if there still exist any referencing rows. This is the default action.\nProduce an error indicating that the deletion or update would create a foreign key constraint violation. This is the same asNO ACTIONexcept that the check is not deferrable.\nDelete any rows referencing the deleted row, or update the values of the referencing column(s) to the new values of the referenced columns, respectively.\nSet all of the referencing columns, or a specified subset of the referencing columns, to null. A subset of columns can only be specified forON DELETEactions.\nSet all of the referencing columns, or a specified subset of the referencing columns, to their default values. A subset of columns can only be specified forON DELETEactions. (There must be a row in the referenced table matching the default values, if they are not null, or the operation will fail.)\nIf the referenced column(s) are changed frequently, it might be wise to add an index to the referencing column(s) so that referential actions associated with the foreign key constraint can be performed more efficiently.\nThis controls whether the constraint can be deferred. A constraint that is not deferrable will be checked immediately after every command. Checking of constraints that are deferrable can be postponed until the end of the transaction (using theSET CONSTRAINTScommand).NOT DEFERRABLEis the default. Currently, onlyUNIQUE,PRIMARY KEY,EXCLUDE, andREFERENCES(foreign key) constraints accept this clause.NOT NULLandCHECKconstraints are not deferrable. Note that deferrable constraints cannot be used as conflict arbitrators in anINSERTstatement that includes anON CONFLICT DO UPDATEclause.\nIf a constraint is deferrable, this clause specifies the default time to check the constraint. If the constraint isINITIALLY IMMEDIATE, it is checked after each statement. This is the default. If the constraint isINITIALLY DEFERRED, it is checked only at the end of the transaction. The constraint check time can be altered with theSET CONSTRAINT",
    "metadata": {
      "doc_name": "sql-createtable",
      "section_title": "Parameters",
      "url": "https://www.postgresql.org/docs/16/sql-createtable.html"
    }
  },
  {
    "chunk_id": 20,
    "text": "that deferrable constraints cannot be used as conflict arbitrators in anINSERTstatement that includes anON CONFLICT DO UPDATEclause.\nIf a constraint is deferrable, this clause specifies the default time to check the constraint. If the constraint isINITIALLY IMMEDIATE, it is checked after each statement. This is the default. If the constraint isINITIALLY DEFERRED, it is checked only at the end of the transaction. The constraint check time can be altered with theSET CONSTRAINTScommand.\nThis optional clause specifies the table access method to use to store the contents for the new table; the method needs be an access method of typeTABLE. SeeChapter 63for more information. If this option is not specified, the default table access method is chosen for the new table. Seedefault_table_access_methodfor more information.\nThis clause specifies optional storage parameters for a table or index; seeStorage Parametersbelow for more information. For backward-compatibility theWITHclause for a table can also includeOIDS=FALSEto specify that rows of the new table should not contain OIDs (object identifiers),OIDS=TRUEis not supported anymore.\nThis is backward-compatible syntax for declaring a tableWITHOUT OIDS, creating a tableWITH OIDSis not supported anymore.\nThe behavior of temporary tables at the end of a transaction block can be controlled usingON COMMIT. The three options are:\nNo special action is taken at the ends of transactions. This is the default behavior.\nAll rows in the temporary table will be deleted at the end of each transaction block. Essentially, an automaticTRUNCATEis done at each commit. When used on a partitioned table, this is not cascaded to its partitions.\nThe temporary table will be dropped at the end of the current transaction block. When used on a partitioned table, this action drops its partitions and when used on tables with inheritance children, it drops the dependent children.\nThetablespace_nameis the name of the tablespace in which the new table is to be created. If not specified,default_tablespaceis consulted, ortemp_tablespacesif the table is temporary. For partitioned tables, since no storage is required for the table itself, the tablespace specified overridesdefault_tablespaceas the default tablespace to use for any newly created partitions when no other tablespace is explicitly specified.\nThis clause allows selection of the tablespace in which the index associated with aUNIQUE,PRIMARY KEY, orEXCLUDEconstraint will be",
    "metadata": {
      "doc_name": "sql-createtable",
      "section_title": "Parameters",
      "url": "https://www.postgresql.org/docs/16/sql-createtable.html"
    }
  },
  {
    "chunk_id": 21,
    "text": "in which the new table is to be created. If not specified,default_tablespaceis consulted, ortemp_tablespacesif the table is temporary. For partitioned tables, since no storage is required for the table itself, the tablespace specified overridesdefault_tablespaceas the default tablespace to use for any newly created partitions when no other tablespace is explicitly specified.\nThis clause allows selection of the tablespace in which the index associated with aUNIQUE,PRIMARY KEY, orEXCLUDEconstraint will be created. If not specified,default_tablespaceis consulted, ortemp_tablespacesif the table is temporary.",
    "metadata": {
      "doc_name": "sql-createtable",
      "section_title": "Parameters",
      "url": "https://www.postgresql.org/docs/16/sql-createtable.html"
    }
  },
  {
    "chunk_id": 22,
    "text": "TheWITHclause can specifystorage parametersfor tables, and for indexes associated with aUNIQUE,PRIMARY KEY, orEXCLUDEconstraint. Storage parameters for indexes are documented inCREATE INDEX. The storage parameters currently available for tables are listed below. For many of these parameters, as shown, there is an additional parameter with the same name prefixed withtoast., which controls the behavior of the table's secondaryTOASTtable, if any (seeSection 73.2for more information about TOAST). If a table parameter value is set and the equivalenttoast.parameter is not, the TOAST table will use the table's parameter value. Specifying these parameters for partitioned tables is not supported, but you may specify them for individual leaf partitions.\nThe fillfactor for a table is a percentage between 10 and 100. 100 (complete packing) is the default. When a smaller fillfactor is specified,INSERToperations pack table pages only to the indicated percentage; the remaining space on each page is reserved for updating rows on that page. This givesUPDATEa chance to place the updated copy of a row on the same page as the original, which is more efficient than placing it on a different page, and makesheap-only tuple updatesmore likely. For a table whose entries are never updated, complete packing is the best choice, but in heavily updated tables smaller fillfactors are appropriate. This parameter cannot be set for TOAST tables.\nThe toast_tuple_target specifies the minimum tuple length required before we try to compress and/or move long column values into TOAST tables, and is also the target length we try to reduce the length below once toasting begins. This affects columns marked as External (for move), Main (for compression), or Extended (for both) and applies only to new tuples. There is no effect on existing rows. By default this parameter is set to allow at least 4 tuples per block, which with the default block size will be 2040 bytes. Valid values are between 128 bytes and the (block size - header), by default 8160 bytes. Changing this value may not be useful for very short or very long rows. Note that the default setting is often close to optimal, and it is possible that setting this parameter could have negative effects in some cases. This parameter cannot be set for TOAST tables.\nThis sets the number of workers that should be used to assist a parallel scan of this table. If not set, the system will determine",
    "metadata": {
      "doc_name": "sql-createtable",
      "section_title": "Storage Parameters",
      "url": "https://www.postgresql.org/docs/16/sql-createtable.html"
    }
  },
  {
    "chunk_id": 23,
    "text": "values are between 128 bytes and the (block size - header), by default 8160 bytes. Changing this value may not be useful for very short or very long rows. Note that the default setting is often close to optimal, and it is possible that setting this parameter could have negative effects in some cases. This parameter cannot be set for TOAST tables.\nThis sets the number of workers that should be used to assist a parallel scan of this table. If not set, the system will determine a value based on the relation size. The actual number of workers chosen by the planner or by utility statements that use parallel scans may be less, for example due to the setting ofmax_worker_processes.\nEnables or disables the autovacuum daemon for a particular table. If true, the autovacuum daemon will perform automaticVACUUMand/orANALYZEoperations on this table following the rules discussed inSection 25.1.6. If false, this table will not be autovacuumed, except to prevent transaction ID wraparound. SeeSection 25.1.5for more about wraparound prevention. Note that the autovacuum daemon does not run at all (except to prevent transaction ID wraparound) if theautovacuumparameter is false; setting individual tables' storage parameters does not override that. Therefore there is seldom much point in explicitly setting this storage parameter totrue, only tofalse.\nForces or disables index cleanup whenVACUUMis run on this table. The default value isAUTO. WithOFF, index cleanup is disabled, withONit is enabled, and withAUTOa decision is made dynamically, each timeVACUUMruns. The dynamic behavior allowsVACUUMto avoid needlessly scanning indexes to remove very few dead tuples. Forcibly disabling all index cleanup can speed upVACUUMvery significantly, but may also lead to severely bloated indexes if table modifications are frequent. TheINDEX_CLEANUPparameter ofVACUUM, if specified, overrides the value of this option.\nEnables or disables vacuum to try to truncate off any empty pages at the end of this table. The default value istrue. Iftrue,VACUUMand autovacuum do the truncation and the disk space for the truncated pages is returned to the operating system. Note that the truncation requiresACCESS EXCLUSIVElock on the table. TheTRUNCATEparameter ofVAC",
    "metadata": {
      "doc_name": "sql-createtable",
      "section_title": "Storage Parameters",
      "url": "https://www.postgresql.org/docs/16/sql-createtable.html"
    }
  },
  {
    "chunk_id": 24,
    "text": "TheINDEX_CLEANUPparameter ofVACUUM, if specified, overrides the value of this option.\nEnables or disables vacuum to try to truncate off any empty pages at the end of this table. The default value istrue. Iftrue,VACUUMand autovacuum do the truncation and the disk space for the truncated pages is returned to the operating system. Note that the truncation requiresACCESS EXCLUSIVElock on the table. TheTRUNCATEparameter ofVACUUM, if specified, overrides the value of this option.\nPer-table value forautovacuum_vacuum_thresholdparameter.\nPer-table value forautovacuum_vacuum_scale_factorparameter.\nPer-table value forautovacuum_vacuum_insert_thresholdparameter. The special value of -1 may be used to disable insert vacuums on the table.\nPer-table value forautovacuum_vacuum_insert_scale_factorparameter.\nPer-table value forautovacuum_analyze_thresholdparameter.\nPer-table value forautovacuum_analyze_scale_factorparameter.\nPer-table value forautovacuum_vacuum_cost_delayparameter.\nPer-table value forautovacuum_vacuum_cost_limitparameter.\nPer-table value forvacuum_freeze_min_ageparameter. Note that autovacuum will ignore per-tableautovacuum_freeze_min_ageparameters that are larger than half the system-wideautovacuum_freeze_max_agesetting.\nPer-table value forautovacuum_freeze_max_ageparameter. Note that autovacuum will ignore per-tableautovacuum_freeze_max_ageparameters that are larger than the system-wide setting (it can only be set smaller).\nPer-table value forvacuum_freeze_table_ageparameter.\nPer-table value forvacuum_multixact_freeze_min_ageparameter. Note that autovacuum will ignore per-tableautovacuum_multixact_freeze_min_ageparameters that are larger than half the system-wideautovacuum_multixact_freeze_max_agesetting.\nPer-table value forautovacuum_multixact_freeze_max_ageparameter. Note that autovacuum will ignore per-tableautovacuum_multixact_freeze_max_ageparameters that are larger than the system-wide setting (it can only be set smaller).\nPer-table value forvacuum_multixact_freeze_table_ageparameter.\nPer-table value forlog_autovacuum_min_duration",
    "metadata": {
      "doc_name": "sql-createtable",
      "section_title": "Storage Parameters",
      "url": "https://www.postgresql.org/docs/16/sql-createtable.html"
    }
  },
  {
    "chunk_id": 25,
    "text": "than half the system-wideautovacuum_multixact_freeze_max_agesetting.\nPer-table value forautovacuum_multixact_freeze_max_ageparameter. Note that autovacuum will ignore per-tableautovacuum_multixact_freeze_max_ageparameters that are larger than the system-wide setting (it can only be set smaller).\nPer-table value forvacuum_multixact_freeze_table_ageparameter.\nPer-table value forlog_autovacuum_min_durationparameter.\nDeclare the table as an additional catalog table for purposes of logical replication. SeeSection 49.6.2for details. This parameter cannot be set for TOAST tables.",
    "metadata": {
      "doc_name": "sql-createtable",
      "section_title": "Storage Parameters",
      "url": "https://www.postgresql.org/docs/16/sql-createtable.html"
    }
  },
  {
    "chunk_id": 26,
    "text": "PostgreSQLautomatically creates an index for each unique constraint and primary key constraint to enforce uniqueness. Thus, it is not necessary to create an index explicitly for primary key columns. (SeeCREATE INDEXfor more information.)\nUnique constraints and primary keys are not inherited in the current implementation. This makes the combination of inheritance and unique constraints rather dysfunctional.\nA table cannot have more than 1600 columns. (In practice, the effective limit is usually lower because of tuple-length constraints.)",
    "metadata": {
      "doc_name": "sql-createtable",
      "section_title": "Notes",
      "url": "https://www.postgresql.org/docs/16/sql-createtable.html"
    }
  },
  {
    "chunk_id": 27,
    "text": "Create tablefilmsand tabledistributors:\n\n\nCODE:\n\nCREATE TABLE films (\n    code        char(5) CONSTRAINT firstkey PRIMARY KEY,\n    title       varchar(40) NOT NULL,\n    did         integer NOT NULL,\n    date_prod   date,\n    kind        varchar(10),\n    len         interval hour to minute\n);\n\nCREATE TABLE distributors (\n     did    integer PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,\n     name   varchar(40) NOT NULL CHECK (name <> '')\n);\n\nCreate a table with a 2-dimensional array:\n\n\nCODE:\n\nCREATE TABLE array_int (\n    vector  int[][]\n);\n\nDefine a unique table constraint for the tablefilms. Unique table constraints can be defined on one or more columns of the table:\n\n\nCODE:\n\nCREATE TABLE films (\n    code        char(5),\n    title       varchar(40),\n    did         integer,\n    date_prod   date,\n    kind        varchar(10),\n    len         interval hour to minute,\n    CONSTRAINT production UNIQUE(date_prod)\n);\n\nDefine a check column constraint:\n\n\nCODE:\n\nCREATE TABLE distributors (\n    did     integer CHECK (did > 100),\n    name    varchar(40)\n);\n\nDefine a check table constraint:\n\n\nCODE:\n\nCREATE TABLE distributors (\n    did     integer,\n    name    varchar(40),\n    CONSTRAINT con1 CHECK (did > 100 AND name <> '')\n);\n\nDefine a primary key table constraint for the tablefilms:\n\n\nCODE:\n\nCREATE TABLE films (\n    code        char(5),\n    title       varchar(40),\n    did         integer,\n    date_prod   date,\n    kind        varchar(10),\n    len         interval hour to minute,\n    CONSTRAINT code_title PRIMARY KEY(code,title)\n);\n\nDefine a primary key constraint for tabledistributors. The following two examples are equivalent, the first using the table constraint syntax, the second the column constraint syntax:\n\n\nCODE:\n\nCREATE TABLE distributors (\n    did     integer,\n    name    varchar(40),\n    PRIMARY KEY(did)\n);\n\nCREATE TABLE distributors (\n    did     integer PRIMARY KEY,\n    name    varchar(40)\n);\n\nAssign a literal constant default value for the columnname, arrange for the default value of columndidto be generated by selecting the next value of a sequence object, and make the default value ofmodtimebe the time at which the row is inserted:\n\n\nCODE:\n\nCREATE TABLE distributors (\n    name      varchar(40) DEFAULT 'Luso Films',\n    did       integer DEFAULT nextval('distributors_serial'),",
    "metadata": {
      "doc_name": "sql-createtable",
      "section_title": "Examples",
      "url": "https://www.postgresql.org/docs/16/sql-createtable.html"
    }
  },
  {
    "chunk_id": 28,
    "text": "(\n    did     integer PRIMARY KEY,\n    name    varchar(40)\n);\n\nAssign a literal constant default value for the columnname, arrange for the default value of columndidto be generated by selecting the next value of a sequence object, and make the default value ofmodtimebe the time at which the row is inserted:\n\n\nCODE:\n\nCREATE TABLE distributors (\n    name      varchar(40) DEFAULT 'Luso Films',\n    did       integer DEFAULT nextval('distributors_serial'),\n    modtime   timestamp DEFAULT current_timestamp\n);\n\nDefine twoNOT NULLcolumn constraints on the tabledistributors, one of which is explicitly given a name:\n\n\nCODE:\n\nCREATE TABLE distributors (\n    did     integer CONSTRAINT no_null NOT NULL,\n    name    varchar(40) NOT NULL\n);\n\nDefine a unique constraint for thenamecolumn:\n\n\nCODE:\n\nCREATE TABLE distributors (\n    did     integer,\n    name    varchar(40) UNIQUE\n);\n\nThe same, specified as a table constraint:\n\n\nCODE:\n\nCREATE TABLE distributors (\n    did     integer,\n    name    varchar(40),\n    UNIQUE(name)\n);\n\nCreate the same table, specifying 70% fill factor for both the table and its unique index:\n\n\nCODE:\n\nCREATE TABLE distributors (\n    did     integer,\n    name    varchar(40),\n    UNIQUE(name) WITH (fillfactor=70)\n)\nWITH (fillfactor=70);\n\nCreate tablecircleswith an exclusion constraint that prevents any two circles from overlapping:\n\n\nCODE:\n\nCREATE TABLE circles (\n    c circle,\n    EXCLUDE USING gist (c WITH &&)\n);\n\nCreate tablecinemasin tablespacediskvol1:\n\n\nCODE:\n\nCREATE TABLE cinemas (\n        id serial,\n        name text,\n        location text\n) TABLESPACE diskvol1;\n\nCreate a composite type and a typed table:\n\n\nCODE:\n\nCREATE TYPE employee_type AS (name text, salary numeric);\n\nCREATE TABLE employees OF employee_type (\n    PRIMARY KEY (name),\n    salary WITH OPTIONS DEFAULT 1000\n);\n\nCreate a range partitioned table:\n\n\nCODE:\n\nCREATE TABLE measurement (\n    logdate         date not null,\n    peaktemp        int,\n    unitsales       int\n) PARTITION BY RANGE (logdate);\n\nCreate a range partitioned table with multiple columns in the partition key:\n\n\nCODE:\n\nCREATE TABLE measurement_year_month (\n    logdate         date not null,\n    peaktemp        int,\n    unitsales       int\n) PARTITION BY RANGE (EXTRACT(YEAR FROM logdate), EXTRACT(MONTH FROM",
    "metadata": {
      "doc_name": "sql-createtable",
      "section_title": "Examples",
      "url": "https://www.postgresql.org/docs/16/sql-createtable.html"
    }
  },
  {
    "chunk_id": 29,
    "text": "ed table:\n\n\nCODE:\n\nCREATE TABLE measurement (\n    logdate         date not null,\n    peaktemp        int,\n    unitsales       int\n) PARTITION BY RANGE (logdate);\n\nCreate a range partitioned table with multiple columns in the partition key:\n\n\nCODE:\n\nCREATE TABLE measurement_year_month (\n    logdate         date not null,\n    peaktemp        int,\n    unitsales       int\n) PARTITION BY RANGE (EXTRACT(YEAR FROM logdate), EXTRACT(MONTH FROM logdate));\n\nCreate a list partitioned table:\n\n\nCODE:\n\nCREATE TABLE cities (\n    city_id      bigserial not null,\n    name         text not null,\n    population   bigint\n) PARTITION BY LIST (left(lower(name), 1));\n\nCreate a hash partitioned table:\n\n\nCODE:\n\nCREATE TABLE orders (\n    order_id     bigint not null,\n    cust_id      bigint not null,\n    status       text\n) PARTITION BY HASH (order_id);\n\nCreate partition of a range partitioned table:\n\n\nCODE:\n\nCREATE TABLE measurement_y2016m07\n    PARTITION OF measurement (\n    unitsales DEFAULT 0\n) FOR VALUES FROM ('2016-07-01') TO ('2016-08-01');\n\nCreate a few partitions of a range partitioned table with multiple columns in the partition key:\n\n\nCODE:\n\nCREATE TABLE measurement_ym_older\n    PARTITION OF measurement_year_month\n    FOR VALUES FROM (MINVALUE, MINVALUE) TO (2016, 11);\n\nCREATE TABLE measurement_ym_y2016m11\n    PARTITION OF measurement_year_month\n    FOR VALUES FROM (2016, 11) TO (2016, 12);\n\nCREATE TABLE measurement_ym_y2016m12\n    PARTITION OF measurement_year_month\n    FOR VALUES FROM (2016, 12) TO (2017, 01);\n\nCREATE TABLE measurement_ym_y2017m01\n    PARTITION OF measurement_year_month\n    FOR VALUES FROM (2017, 01) TO (2017, 02);\n\nCreate partition of a list partitioned table:\n\n\nCODE:\n\nCREATE TABLE cities_ab\n    PARTITION OF cities (\n    CONSTRAINT city_id_nonzero CHECK (city_id != 0)\n) FOR VALUES IN ('a', 'b');\n\nCreate partition of a list partitioned table that is itself further partitioned and then add a partition to it:\n\n\nCODE:\n\nCREATE TABLE cities_ab\n    PARTITION OF cities (\n    CONSTRAINT city",
    "metadata": {
      "doc_name": "sql-createtable",
      "section_title": "Examples",
      "url": "https://www.postgresql.org/docs/16/sql-createtable.html"
    }
  },
  {
    "chunk_id": 30,
    "text": "FROM (2017, 01) TO (2017, 02);\n\nCreate partition of a list partitioned table:\n\n\nCODE:\n\nCREATE TABLE cities_ab\n    PARTITION OF cities (\n    CONSTRAINT city_id_nonzero CHECK (city_id != 0)\n) FOR VALUES IN ('a', 'b');\n\nCreate partition of a list partitioned table that is itself further partitioned and then add a partition to it:\n\n\nCODE:\n\nCREATE TABLE cities_ab\n    PARTITION OF cities (\n    CONSTRAINT city_id_nonzero CHECK (city_id != 0)\n) FOR VALUES IN ('a', 'b') PARTITION BY RANGE (population);\n\nCREATE TABLE cities_ab_10000_to_100000\n    PARTITION OF cities_ab FOR VALUES FROM (10000) TO (100000);\n\nCreate partitions of a hash partitioned table:\n\n\nCODE:\n\nCREATE TABLE orders_p1 PARTITION OF orders\n    FOR VALUES WITH (MODULUS 4, REMAINDER 0);\nCREATE TABLE orders_p2 PARTITION OF orders\n    FOR VALUES WITH (MODULUS 4, REMAINDER 1);\nCREATE TABLE orders_p3 PARTITION OF orders\n    FOR VALUES WITH (MODULUS 4, REMAINDER 2);\nCREATE TABLE orders_p4 PARTITION OF orders\n    FOR VALUES WITH (MODULUS 4, REMAINDER 3);\n\nCreate a default partition:\n\n\nCODE:\n\nCREATE TABLE cities_partdef\n    PARTITION OF cities DEFAULT;",
    "metadata": {
      "doc_name": "sql-createtable",
      "section_title": "Examples",
      "url": "https://www.postgresql.org/docs/16/sql-createtable.html"
    }
  },
  {
    "chunk_id": 31,
    "text": "TheCREATE TABLEcommand conforms to theSQLstandard, with exceptions listed below.",
    "metadata": {
      "doc_name": "sql-createtable",
      "section_title": "Compatibility",
      "url": "https://www.postgresql.org/docs/16/sql-createtable.html"
    }
  },
  {
    "chunk_id": 32,
    "text": "Although the syntax ofCREATE TEMPORARY TABLEresembles that of the SQL standard, the effect is not the same. In the standard, temporary tables are defined just once and automatically exist (starting with empty contents) in every session that needs them.PostgreSQLinstead requires each session to issue its ownCREATE TEMPORARY TABLEcommand for each temporary table to be used. This allows different sessions to use the same temporary table name for different purposes, whereas the standard's approach constrains all instances of a given temporary table name to have the same table structure.\nThe standard's definition of the behavior of temporary tables is widely ignored.PostgreSQL's behavior on this point is similar to that of several other SQL databases.\nThe SQL standard also distinguishes between global and local temporary tables, where a local temporary table has a separate set of contents for each SQL module within each session, though its definition is still shared across sessions. SincePostgreSQLdoes not support SQL modules, this distinction is not relevant inPostgreSQL.\nFor compatibility's sake,PostgreSQLwill accept theGLOBALandLOCALkeywords in a temporary table declaration, but they currently have no effect. Use of these keywords is discouraged, since future versions ofPostgreSQLmight adopt a more standard-compliant interpretation of their meaning.\nTheON COMMITclause for temporary tables also resembles the SQL standard, but has some differences. If theON COMMITclause is omitted, SQL specifies that the default behavior isON COMMIT DELETE ROWS. However, the default behavior inPostgreSQLisON COMMIT PRESERVE ROWS. TheON COMMIT DROPoption does not exist in SQL.",
    "metadata": {
      "doc_name": "sql-createtable",
      "section_title": "Temporary Tables",
      "url": "https://www.postgresql.org/docs/16/sql-createtable.html"
    }
  },
  {
    "chunk_id": 33,
    "text": "When aUNIQUEorPRIMARY KEYconstraint is not deferrable,PostgreSQLchecks for uniqueness immediately whenever a row is inserted or modified. The SQL standard says that uniqueness should be enforced only at the end of the statement; this makes a difference when, for example, a single command updates multiple key values. To obtain standard-compliant behavior, declare the constraint asDEFERRABLEbut not deferred (i.e.,INITIALLY IMMEDIATE). Be aware that this can be significantly slower than immediate uniqueness checking.",
    "metadata": {
      "doc_name": "sql-createtable",
      "section_title": "Non-Deferred Uniqueness Constraints",
      "url": "https://www.postgresql.org/docs/16/sql-createtable.html"
    }
  },
  {
    "chunk_id": 34,
    "text": "The SQL standard says thatCHECKcolumn constraints can only refer to the column they apply to; onlyCHECKtable constraints can refer to multiple columns.PostgreSQLdoes not enforce this restriction; it treats column and table check constraints alike.",
    "metadata": {
      "doc_name": "sql-createtable",
      "section_title": "Column Check Constraints",
      "url": "https://www.postgresql.org/docs/16/sql-createtable.html"
    }
  },
  {
    "chunk_id": 35,
    "text": "TheEXCLUDEconstraint type is aPostgreSQLextension.",
    "metadata": {
      "doc_name": "sql-createtable",
      "section_title": "EXCLUDEConstraint",
      "url": "https://www.postgresql.org/docs/16/sql-createtable.html"
    }
  },
  {
    "chunk_id": 36,
    "text": "The ability to specify column lists in the foreign key actionsSET DEFAULTandSET NULLis aPostgreSQLextension.\nIt is aPostgreSQLextension that a foreign key constraint may reference columns of a unique index instead of columns of a primary key or unique constraint.",
    "metadata": {
      "doc_name": "sql-createtable",
      "section_title": "Foreign Key Constraints",
      "url": "https://www.postgresql.org/docs/16/sql-createtable.html"
    }
  },
  {
    "chunk_id": 37,
    "text": "TheNULL“constraint”(actually a non-constraint) is aPostgreSQLextension to the SQL standard that is included for compatibility with some other database systems (and for symmetry with theNOT NULLconstraint). Since it is the default for any column, its presence is simply noise.",
    "metadata": {
      "doc_name": "sql-createtable",
      "section_title": "NULL“Constraint”",
      "url": "https://www.postgresql.org/docs/16/sql-createtable.html"
    }
  },
  {
    "chunk_id": 38,
    "text": "The SQL standard says that table and domain constraints must have names that are unique across the schema containing the table or domain.PostgreSQLis laxer: it only requires constraint names to be unique across the constraints attached to a particular table or domain. However, this extra freedom does not exist for index-based constraints (UNIQUE,PRIMARY KEY, andEXCLUDEconstraints), because the associated index is named the same as the constraint, and index names must be unique across all relations within the same schema.\nCurrently,PostgreSQLdoes not record names forNOT NULLconstraints at all, so they are not subject to the uniqueness restriction. This might change in a future release.",
    "metadata": {
      "doc_name": "sql-createtable",
      "section_title": "Constraint Naming",
      "url": "https://www.postgresql.org/docs/16/sql-createtable.html"
    }
  },
  {
    "chunk_id": 39,
    "text": "Multiple inheritance via theINHERITSclause is aPostgreSQLlanguage extension. SQL:1999 and later define single inheritance using a different syntax and different semantics. SQL:1999-style inheritance is not yet supported byPostgreSQL.",
    "metadata": {
      "doc_name": "sql-createtable",
      "section_title": "Inheritance",
      "url": "https://www.postgresql.org/docs/16/sql-createtable.html"
    }
  },
  {
    "chunk_id": 40,
    "text": "PostgreSQLallows a table of no columns to be created (for example,CREATE TABLE foo();). This is an extension from the SQL standard, which does not allow zero-column tables. Zero-column tables are not in themselves very useful, but disallowing them creates odd special cases forALTER TABLE DROP COLUMN, so it seems cleaner to ignore this spec restriction.",
    "metadata": {
      "doc_name": "sql-createtable",
      "section_title": "Zero-Column Tables",
      "url": "https://www.postgresql.org/docs/16/sql-createtable.html"
    }
  },
  {
    "chunk_id": 41,
    "text": "PostgreSQLallows a table to have more than one identity column. The standard specifies that a table can have at most one identity column. This is relaxed mainly to give more flexibility for doing schema changes or migrations. Note that theINSERTcommand supports only one override clause that applies to the entire statement, so having multiple identity columns with different behaviors is not well supported.",
    "metadata": {
      "doc_name": "sql-createtable",
      "section_title": "Multiple Identity Columns",
      "url": "https://www.postgresql.org/docs/16/sql-createtable.html"
    }
  },
  {
    "chunk_id": 42,
    "text": "The optionSTOREDis not standard but is also used by other SQL implementations. The SQL standard does not specify the storage of generated columns.",
    "metadata": {
      "doc_name": "sql-createtable",
      "section_title": "Generated Columns",
      "url": "https://www.postgresql.org/docs/16/sql-createtable.html"
    }
  },
  {
    "chunk_id": 43,
    "text": "While aLIKEclause exists in the SQL standard, many of the options thatPostgreSQLaccepts for it are not in the standard, and some of the standard's options are not implemented byPostgreSQL.",
    "metadata": {
      "doc_name": "sql-createtable",
      "section_title": "LIKEClause",
      "url": "https://www.postgresql.org/docs/16/sql-createtable.html"
    }
  },
  {
    "chunk_id": 44,
    "text": "TheWITHclause is aPostgreSQLextension; storage parameters are not in the standard.",
    "metadata": {
      "doc_name": "sql-createtable",
      "section_title": "WITHClause",
      "url": "https://www.postgresql.org/docs/16/sql-createtable.html"
    }
  },
  {
    "chunk_id": 45,
    "text": "ThePostgreSQLconcept of tablespaces is not part of the standard. Hence, the clausesTABLESPACEandUSING INDEX TABLESPACEare extensions.",
    "metadata": {
      "doc_name": "sql-createtable",
      "section_title": "Tablespaces",
      "url": "https://www.postgresql.org/docs/16/sql-createtable.html"
    }
  },
  {
    "chunk_id": 46,
    "text": "Typed tables implement a subset of the SQL standard. According to the standard, a typed table has columns corresponding to the underlying composite type as well as one other column that is the“self-referencing column”.PostgreSQLdoes not support self-referencing columns explicitly.",
    "metadata": {
      "doc_name": "sql-createtable",
      "section_title": "Typed Tables",
      "url": "https://www.postgresql.org/docs/16/sql-createtable.html"
    }
  },
  {
    "chunk_id": 47,
    "text": "ThePARTITION BYclause is aPostgreSQLextension.",
    "metadata": {
      "doc_name": "sql-createtable",
      "section_title": "PARTITION BYClause",
      "url": "https://www.postgresql.org/docs/16/sql-createtable.html"
    }
  },
  {
    "chunk_id": 48,
    "text": "ThePARTITION OFclause is aPostgreSQLextension.",
    "metadata": {
      "doc_name": "sql-createtable",
      "section_title": "PARTITION OFClause",
      "url": "https://www.postgresql.org/docs/16/sql-createtable.html"
    }
  },
  {
    "chunk_id": 0,
    "text": "CREATE VIEW — define a new view",
    "metadata": {
      "doc_name": "sql-createview",
      "section_title": "CREATE VIEW",
      "url": "https://www.postgresql.org/docs/16/sql-createview.html"
    }
  },
  {
    "chunk_id": 1,
    "text": "CODE:\n\nCREATE [ OR REPLACE ] [ TEMP | TEMPORARY ] [ RECURSIVE ] VIEW name [ ( column_name [, ...] ) ]\n    [ WITH ( view_option_name [= view_option_value] [, ... ] ) ]\n    AS query\n    [ WITH [ CASCADED | LOCAL ] CHECK OPTION ]",
    "metadata": {
      "doc_name": "sql-createview",
      "section_title": "Synopsis",
      "url": "https://www.postgresql.org/docs/16/sql-createview.html"
    }
  },
  {
    "chunk_id": 2,
    "text": "CREATE VIEWdefines a view of a query. The view is not physically materialized. Instead, the query is run every time the view is referenced in a query.\nCREATE OR REPLACE VIEWis similar, but if a view of the same name already exists, it is replaced. The new query must generate the same columns that were generated by the existing view query (that is, the same column names in the same order and with the same data types), but it may add additional columns to the end of the list. The calculations giving rise to the output columns may be completely different.\nIf a schema name is given (for example,CREATE VIEW myschema.myview ...) then the view is created in the specified schema. Otherwise it is created in the current schema. Temporary views exist in a special schema, so a schema name cannot be given when creating a temporary view. The name of the view must be distinct from the name of any other relation (table, sequence, index, view, materialized view, or foreign table) in the same schema.",
    "metadata": {
      "doc_name": "sql-createview",
      "section_title": "Description",
      "url": "https://www.postgresql.org/docs/16/sql-createview.html"
    }
  },
  {
    "chunk_id": 3,
    "text": "If specified, the view is created as a temporary view. Temporary views are automatically dropped at the end of the current session. Existing permanent relations with the same name are not visible to the current session while the temporary view exists, unless they are referenced with schema-qualified names.\nIf any of the tables referenced by the view are temporary, the view is created as a temporary view (whetherTEMPORARYis specified or not).\nCreates a recursive view. The syntax\n\n\nCODE:\n\nCREATE RECURSIVE VIEW [ schema . ] view_name (column_names) AS SELECT ...;\n\nis equivalent to\n\n\nCODE:\n\nCREATE VIEW [ schema . ] view_name AS WITH RECURSIVE view_name (column_names) AS (SELECT ...) SELECT column_names FROM view_name;\n\nA view column name list must be specified for a recursive view.\nThe name (optionally schema-qualified) of a view to be created.\nAn optional list of names to be used for columns of the view. If not given, the column names are deduced from the query.\nThis clause specifies optional parameters for a view; the following parameters are supported:\nThis parameter may be eitherlocalorcascaded, and is equivalent to specifyingWITH [ CASCADED | LOCAL ] CHECK OPTION(see below).\nThis should be used if the view is intended to provide row-level security. SeeSection 41.5for full details.\nThis option causes the underlying base relations to be checked against the privileges of the user of the view rather than the view owner. See the notes below for full details.\nAll of the above options can be changed on existing views usingALTER VIEW.\nASELECTorVALUEScommand which will provide the columns and rows of the view.\nThis option controls the behavior of automatically updatable views. When this option is specified,INSERTandUPDATEcommands on the view will be checked to ensure that new rows satisfy the view-defining condition (that is, the new rows are checked to ensure that they are visible through the view). If they are not, the update will be rejected. If theCHECK OPTIONis not specified,INSERTandUPDATEcommands on the view are allowed to create rows that are not visible through the view. The following check options are supported:\nNew rows are only checked against the conditions defined directly in the view itself. Any conditions defined on underlying base views are not checked (unless they also specify theCHECK OPTION).\nNew rows are checked against the conditions of the view and all underlying base views. If theCHECK OPTIONis",
    "metadata": {
      "doc_name": "sql-createview",
      "section_title": "Parameters",
      "url": "https://www.postgresql.org/docs/16/sql-createview.html"
    }
  },
  {
    "chunk_id": 4,
    "text": "they are not, the update will be rejected. If theCHECK OPTIONis not specified,INSERTandUPDATEcommands on the view are allowed to create rows that are not visible through the view. The following check options are supported:\nNew rows are only checked against the conditions defined directly in the view itself. Any conditions defined on underlying base views are not checked (unless they also specify theCHECK OPTION).\nNew rows are checked against the conditions of the view and all underlying base views. If theCHECK OPTIONis specified, and neitherLOCALnorCASCADEDis specified, thenCASCADEDis assumed.\nTheCHECK OPTIONmay not be used withRECURSIVEviews.\nNote that theCHECK OPTIONis only supported on views that are automatically updatable, and do not haveINSTEAD OFtriggers orINSTEADrules. If an automatically updatable view is defined on top of a base view that hasINSTEAD OFtriggers, then theLOCAL CHECK OPTIONmay be used to check the conditions on the automatically updatable view, but the conditions on the base view withINSTEAD OFtriggers will not be checked (a cascaded check option will not cascade down to a trigger-updatable view, and any check options defined directly on a trigger-updatable view will be ignored). If the view or any of its base relations has anINSTEADrule that causes theINSERTorUPDATEcommand to be rewritten, then all check options will be ignored in the rewritten query, including any checks from automatically updatable views defined on top of the relation with theINSTEADrule.",
    "metadata": {
      "doc_name": "sql-createview",
      "section_title": "Parameters",
      "url": "https://www.postgresql.org/docs/16/sql-createview.html"
    }
  },
  {
    "chunk_id": 5,
    "text": "Use theDROP VIEWstatement to drop views.\nBe careful that the names and types of the view's columns will be assigned the way you want. For example:\n\n\nCODE:\n\nCREATE VIEW vista AS SELECT 'Hello World';\n\nis bad form because the column name defaults to?column?; also, the column data type defaults totext, which might not be what you wanted. Better style for a string literal in a view's result is something like:\n\n\nCODE:\n\nCREATE VIEW vista AS SELECT text 'Hello World' AS hello;\n\nBy default, access to the underlying base relations referenced in the view is determined by the permissions of the view owner. In some cases, this can be used to provide secure but restricted access to the underlying tables. However, not all views are secure against tampering; seeSection 41.5for details.\nIf the view has thesecurity_invokerproperty set totrue, access to the underlying base relations is determined by the permissions of the user executing the query, rather than the view owner. Thus, the user of a security invoker view must have the relevant permissions on the view and its underlying base relations.\nIf any of the underlying base relations is a security invoker view, it will be treated as if it had been accessed directly from the original query. Thus, a security invoker view will always check its underlying base relations using the permissions of the current user, even if it is accessed from a view without thesecurity_invokerproperty.\nIf any of the underlying base relations hasrow-level securityenabled, then by default, the row-level security policies of the view owner are applied, and access to any additional relations referred to by those policies is determined by the permissions of the view owner. However, if the view hassecurity_invokerset totrue, then the policies and permissions of the invoking user are used instead, as if the base relations had been referenced directly from the query using the view.\nFunctions called in the view are treated the same as if they had been called directly from the query using the view. Therefore, the user of a view must have permissions to call all functions used by the view. Functions in the view are executed with the privileges of the user executing the query or the function owner, depending on whether the functions are defined asSECURITY INVOKERorSECURITY DEFINER. Thus, for example, callingCURRENT_USERdirectly in a view will always return the invoking user, not the view owner. This is not affected by the view's",
    "metadata": {
      "doc_name": "sql-createview",
      "section_title": "Notes",
      "url": "https://www.postgresql.org/docs/16/sql-createview.html"
    }
  },
  {
    "chunk_id": 6,
    "text": "called directly from the query using the view. Therefore, the user of a view must have permissions to call all functions used by the view. Functions in the view are executed with the privileges of the user executing the query or the function owner, depending on whether the functions are defined asSECURITY INVOKERorSECURITY DEFINER. Thus, for example, callingCURRENT_USERdirectly in a view will always return the invoking user, not the view owner. This is not affected by the view'ssecurity_invokersetting, and so a view withsecurity_invokerset tofalseisnotequivalent to aSECURITY DEFINERfunction and those concepts should not be confused.\nThe user creating or replacing a view must haveUSAGEprivileges on any schemas referred to in the view query, in order to look up the referenced objects in those schemas. Note, however, that this lookup only happens when the view is created or replaced. Therefore, the user of the view only requires theUSAGEprivilege on the schema containing the view, not on the schemas referred to in the view query, even for a security invoker view.\nWhenCREATE OR REPLACE VIEWis used on an existing view, only the view's defining SELECT rule, plus anyWITH ( ... )parameters and itsCHECK OPTIONare changed. Other view properties, including ownership, permissions, and non-SELECT rules, remain unchanged. You must own the view to replace it (this includes being a member of the owning role).",
    "metadata": {
      "doc_name": "sql-createview",
      "section_title": "Notes",
      "url": "https://www.postgresql.org/docs/16/sql-createview.html"
    }
  },
  {
    "chunk_id": 7,
    "text": "Simple views are automatically updatable: the system will allowINSERT,UPDATEandDELETEstatements to be used on the view in the same way as on a regular table. A view is automatically updatable if it satisfies all of the following conditions:\nThe view must have exactly one entry in itsFROMlist, which must be a table or another updatable view.\nThe view definition must not containWITH,DISTINCT,GROUP BY,HAVING,LIMIT, orOFFSETclauses at the top level.\nThe view definition must not contain set operations (UNION,INTERSECTorEXCEPT) at the top level.\nThe view's select list must not contain any aggregates, window functions or set-returning functions.\nAn automatically updatable view may contain a mix of updatable and non-updatable columns. A column is updatable if it is a simple reference to an updatable column of the underlying base relation; otherwise the column is read-only, and an error will be raised if anINSERTorUPDATEstatement attempts to assign a value to it.\nIf the view is automatically updatable the system will convert anyINSERT,UPDATEorDELETEstatement on the view into the corresponding statement on the underlying base relation.INSERTstatements that have anON CONFLICT UPDATEclause are fully supported.\nIf an automatically updatable view contains aWHEREcondition, the condition restricts which rows of the base relation are available to be modified byUPDATEandDELETEstatements on the view. However, anUPDATEis allowed to change a row so that it no longer satisfies theWHEREcondition, and thus is no longer visible through the view. Similarly, anINSERTcommand can potentially insert base-relation rows that do not satisfy theWHEREcondition and thus are not visible through the view (ON CONFLICT UPDATEmay similarly affect an existing row not visible through the view). TheCHECK OPTIONmay be used to preventINSERTandUPDATEcommands from creating such rows that are not visible through the view.\nIf an automatically updatable view is marked with thesecurity_barrierproperty then all the view'sWHEREconditions (and any conditions using operators which are marked asLEAKPROOF) will always be evaluated before any conditions that a user of the view has added. SeeSection 41.5for full details. Note that, due to this, rows which are not ultimately returned (because they do not pass the user'sWHEREconditions) may still end up being locked.EXPLAINcan be used to see which conditions are applied at the relation level (and therefore do not",
    "metadata": {
      "doc_name": "sql-createview",
      "section_title": "Updatable Views",
      "url": "https://www.postgresql.org/docs/16/sql-createview.html"
    }
  },
  {
    "chunk_id": 8,
    "text": "property then all the view'sWHEREconditions (and any conditions using operators which are marked asLEAKPROOF) will always be evaluated before any conditions that a user of the view has added. SeeSection 41.5for full details. Note that, due to this, rows which are not ultimately returned (because they do not pass the user'sWHEREconditions) may still end up being locked.EXPLAINcan be used to see which conditions are applied at the relation level (and therefore do not lock rows) and which are not.\nA more complex view that does not satisfy all these conditions is read-only by default: the system will not allow an insert, update, or delete on the view. You can get the effect of an updatable view by creatingINSTEAD OFtriggers on the view, which must convert attempted inserts, etc. on the view into appropriate actions on other tables. For more information seeCREATE TRIGGER. Another possibility is to create rules (seeCREATE RULE), but in practice triggers are easier to understand and use correctly.\nNote that the user performing the insert, update or delete on the view must have the corresponding insert, update or delete privilege on the view. In addition, by default, the view's owner must have the relevant privileges on the underlying base relations, whereas the user performing the update does not need any permissions on the underlying base relations (seeSection 41.5). However, if the view hassecurity_invokerset totrue, the user performing the update, rather than the view owner, must have the relevant privileges on the underlying base relations.",
    "metadata": {
      "doc_name": "sql-createview",
      "section_title": "Updatable Views",
      "url": "https://www.postgresql.org/docs/16/sql-createview.html"
    }
  },
  {
    "chunk_id": 9,
    "text": "Create a view consisting of all comedy films:\n\n\nCODE:\n\nCREATE VIEW comedies AS\n    SELECT *\n    FROM films\n    WHERE kind = 'Comedy';\n\nThis will create a view containing the columns that are in thefilmtable at the time of view creation. Though*was used to create the view, columns added later to the table will not be part of the view.\nCreate a view withLOCAL CHECK OPTION:\n\n\nCODE:\n\nCREATE VIEW universal_comedies AS\n    SELECT *\n    FROM comedies\n    WHERE classification = 'U'\n    WITH LOCAL CHECK OPTION;\n\nThis will create a view based on thecomediesview, showing only films withkind = 'Comedy'andclassification = 'U'. Any attempt toINSERTorUPDATEa row in the view will be rejected if the new row doesn't haveclassification = 'U', but the filmkindwill not be checked.\nCreate a view withCASCADED CHECK OPTION:\n\n\nCODE:\n\nCREATE VIEW pg_comedies AS\n    SELECT *\n    FROM comedies\n    WHERE classification = 'PG'\n    WITH CASCADED CHECK OPTION;\n\nThis will create a view that checks both thekindandclassificationof new rows.\nCreate a view with a mix of updatable and non-updatable columns:\n\n\nCODE:\n\nCREATE VIEW comedies AS\n    SELECT f.*,\n           country_code_to_name(f.country_code) AS country,\n           (SELECT avg(r.rating)\n            FROM user_ratings r\n            WHERE r.film_id = f.id) AS avg_rating\n    FROM films f\n    WHERE f.kind = 'Comedy';\n\nThis view will supportINSERT,UPDATEandDELETE. All the columns from thefilmstable will be updatable, whereas the computed columnscountryandavg_ratingwill be read-only.\nCreate a recursive view consisting of the numbers from 1 to 100:\n\n\nCODE:\n\nCREATE RECURSIVE VIEW public.nums_1_100 (n) AS\n    VALUES (1)\nUNION ALL\n    SELECT n+1 FROM nums_1_100 WHERE n < 100;\n\nNotice that although the recursive view's name is schema-qualified in thisCREATE, its internal self-reference is not schema-qualified. This is because the implicitly-created CTE's name cannot be schema-qualified.",
    "metadata": {
      "doc_name": "sql-createview",
      "section_title": "Examples",
      "url": "https://www.postgresql.org/docs/16/sql-createview.html"
    }
  },
  {
    "chunk_id": 10,
    "text": "CREATE OR REPLACE VIEWis aPostgreSQLlanguage extension. So is the concept of a temporary view. TheWITH ( ... )clause is an extension as well, as are security barrier views and security invoker views.",
    "metadata": {
      "doc_name": "sql-createview",
      "section_title": "Compatibility",
      "url": "https://www.postgresql.org/docs/16/sql-createview.html"
    }
  },
  {
    "chunk_id": 0,
    "text": "DELETE — delete rows of a table",
    "metadata": {
      "doc_name": "sql-delete",
      "section_title": "DELETE",
      "url": "https://www.postgresql.org/docs/16/sql-delete.html"
    }
  },
  {
    "chunk_id": 1,
    "text": "CODE:\n\n[ WITH [ RECURSIVE ] with_query [, ...] ]\nDELETE FROM [ ONLY ] table_name [ * ] [ [ AS ] alias ]\n    [ USING from_item [, ...] ]\n    [ WHERE condition | WHERE CURRENT OF cursor_name ]\n    [ RETURNING { * | output_expression [ [ AS ] output_name ] } [, ...] ]",
    "metadata": {
      "doc_name": "sql-delete",
      "section_title": "Synopsis",
      "url": "https://www.postgresql.org/docs/16/sql-delete.html"
    }
  },
  {
    "chunk_id": 2,
    "text": "DELETEdeletes rows that satisfy theWHEREclause from the specified table. If theWHEREclause is absent, the effect is to delete all rows in the table. The result is a valid, but empty table.",
    "metadata": {
      "doc_name": "sql-delete",
      "section_title": "Description",
      "url": "https://www.postgresql.org/docs/16/sql-delete.html"
    }
  },
  {
    "chunk_id": 3,
    "text": "TRUNCATEprovides a faster mechanism to remove all rows from a table.\nThere are two ways to delete rows in a table using information contained in other tables in the database: using sub-selects, or specifying additional tables in theUSINGclause. Which technique is more appropriate depends on the specific circumstances.\nThe optionalRETURNINGclause causesDELETEto compute and return value(s) based on each row actually deleted. Any expression using the table's columns, and/or columns of other tables mentioned inUSING, can be computed. The syntax of theRETURNINGlist is identical to that of the output list ofSELECT.\nYou must have theDELETEprivilege on the table to delete from it, as well as theSELECTprivilege for any table in theUSINGclause or whose values are read in thecondition.",
    "metadata": {
      "doc_name": "sql-delete",
      "section_title": "Tip",
      "url": "https://www.postgresql.org/docs/16/sql-delete.html"
    }
  },
  {
    "chunk_id": 4,
    "text": "TheWITHclause allows you to specify one or more subqueries that can be referenced by name in theDELETEquery. SeeSection 7.8andSELECTfor details.\nThe name (optionally schema-qualified) of the table to delete rows from. IfONLYis specified before the table name, matching rows are deleted from the named table only. IfONLYis not specified, matching rows are also deleted from any tables inheriting from the named table. Optionally,*can be specified after the table name to explicitly indicate that descendant tables are included.\nA substitute name for the target table. When an alias is provided, it completely hides the actual name of the table. For example, givenDELETE FROM foo AS f, the remainder of theDELETEstatement must refer to this table asfnotfoo.\nA table expression allowing columns from other tables to appear in theWHEREcondition. This uses the same syntax as theFROMclause of aSELECTstatement; for example, an alias for the table name can be specified. Do not repeat the target table as afrom_itemunless you wish to set up a self-join (in which case it must appear with an alias in thefrom_item).\nAn expression that returns a value of typeboolean. Only rows for which this expression returnstruewill be deleted.\nThe name of the cursor to use in aWHERE CURRENT OFcondition. The row to be deleted is the one most recently fetched from this cursor. The cursor must be a non-grouping query on theDELETE's target table. Note thatWHERE CURRENT OFcannot be specified together with a Boolean condition. SeeDECLAREfor more information about using cursors withWHERE CURRENT OF.\nAn expression to be computed and returned by theDELETEcommand after each row is deleted. The expression can use any column names of the table named bytable_nameor table(s) listed inUSING. Write*to return all columns.\nA name to use for a returned column.",
    "metadata": {
      "doc_name": "sql-delete",
      "section_title": "Parameters",
      "url": "https://www.postgresql.org/docs/16/sql-delete.html"
    }
  },
  {
    "chunk_id": 5,
    "text": "On successful completion, aDELETEcommand returns a command tag of the form\n\n\nCODE:\n\nDELETE count\n\nThecountis the number of rows deleted. Note that the number may be less than the number of rows that matched theconditionwhen deletes were suppressed by aBEFORE DELETEtrigger. Ifcountis 0, no rows were deleted by the query (this is not considered an error).\nIf theDELETEcommand contains aRETURNINGclause, the result will be similar to that of aSELECTstatement containing the columns and values defined in theRETURNINGlist, computed over the row(s) deleted by the command.",
    "metadata": {
      "doc_name": "sql-delete",
      "section_title": "Outputs",
      "url": "https://www.postgresql.org/docs/16/sql-delete.html"
    }
  },
  {
    "chunk_id": 6,
    "text": "PostgreSQLlets you reference columns of other tables in theWHEREcondition by specifying the other tables in theUSINGclause. For example, to delete all films produced by a given producer, one can do:\n\n\nCODE:\n\nDELETE FROM films USING producers\n  WHERE producer_id = producers.id AND producers.name = 'foo';\n\nWhat is essentially happening here is a join betweenfilmsandproducers, with all successfully joinedfilmsrows being marked for deletion. This syntax is not standard. A more standard way to do it is:\n\n\nCODE:\n\nDELETE FROM films\n  WHERE producer_id IN (SELECT id FROM producers WHERE name = 'foo');\n\nIn some cases the join style is easier to write or faster to execute than the sub-select style.",
    "metadata": {
      "doc_name": "sql-delete",
      "section_title": "Notes",
      "url": "https://www.postgresql.org/docs/16/sql-delete.html"
    }
  },
  {
    "chunk_id": 7,
    "text": "Delete all films but musicals:\n\n\nCODE:\n\nDELETE FROM films WHERE kind <> 'Musical';\n\nClear the tablefilms:\n\n\nCODE:\n\nDELETE FROM films;\n\nDelete completed tasks, returning full details of the deleted rows:\n\n\nCODE:\n\nDELETE FROM tasks WHERE status = 'DONE' RETURNING *;\n\nDelete the row oftaskson which the cursorc_tasksis currently positioned:\n\n\nCODE:\n\nDELETE FROM tasks WHERE CURRENT OF c_tasks;",
    "metadata": {
      "doc_name": "sql-delete",
      "section_title": "Examples",
      "url": "https://www.postgresql.org/docs/16/sql-delete.html"
    }
  },
  {
    "chunk_id": 8,
    "text": "This command conforms to theSQLstandard, except that theUSINGandRETURNINGclauses arePostgreSQLextensions, as is the ability to useWITHwithDELETE.",
    "metadata": {
      "doc_name": "sql-delete",
      "section_title": "Compatibility",
      "url": "https://www.postgresql.org/docs/16/sql-delete.html"
    }
  },
  {
    "chunk_id": 0,
    "text": "DROP DATABASE — remove a database",
    "metadata": {
      "doc_name": "sql-dropdatabase",
      "section_title": "DROP DATABASE",
      "url": "https://www.postgresql.org/docs/16/sql-dropdatabase.html"
    }
  },
  {
    "chunk_id": 1,
    "text": "CODE:\n\nDROP DATABASE [ IF EXISTS ] name [ [ WITH ] ( option [, ...] ) ]\n\nwhere option can be:\n\n    FORCE",
    "metadata": {
      "doc_name": "sql-dropdatabase",
      "section_title": "Synopsis",
      "url": "https://www.postgresql.org/docs/16/sql-dropdatabase.html"
    }
  },
  {
    "chunk_id": 2,
    "text": "DROP DATABASEdrops a database. It removes the catalog entries for the database and deletes the directory containing the data. It can only be executed by the database owner. It cannot be executed while you are connected to the target database. (Connect topostgresor any other database to issue this command.) Also, if anyone else is connected to the target database, this command will fail unless you use theFORCEoption described below.\nDROP DATABASEcannot be undone. Use it with care!",
    "metadata": {
      "doc_name": "sql-dropdatabase",
      "section_title": "Description",
      "url": "https://www.postgresql.org/docs/16/sql-dropdatabase.html"
    }
  },
  {
    "chunk_id": 3,
    "text": "Do not throw an error if the database does not exist. A notice is issued in this case.\nThe name of the database to remove.\nAttempt to terminate all existing connections to the target database. It doesn't terminate if prepared transactions, active logical replication slots or subscriptions are present in the target database.\nThis terminates background worker connections and connections that the current user has permission to terminate withpg_terminate_backend, described inSection 9.27.2. If connections would remain, this command will fail.",
    "metadata": {
      "doc_name": "sql-dropdatabase",
      "section_title": "Parameters",
      "url": "https://www.postgresql.org/docs/16/sql-dropdatabase.html"
    }
  },
  {
    "chunk_id": 4,
    "text": "DROP DATABASEcannot be executed inside a transaction block.\nThis command cannot be executed while connected to the target database. Thus, it might be more convenient to use the programdropdbinstead, which is a wrapper around this command.",
    "metadata": {
      "doc_name": "sql-dropdatabase",
      "section_title": "Notes",
      "url": "https://www.postgresql.org/docs/16/sql-dropdatabase.html"
    }
  },
  {
    "chunk_id": 5,
    "text": "There is noDROP DATABASEstatement in the SQL standard.",
    "metadata": {
      "doc_name": "sql-dropdatabase",
      "section_title": "Compatibility",
      "url": "https://www.postgresql.org/docs/16/sql-dropdatabase.html"
    }
  },
  {
    "chunk_id": 0,
    "text": "DROP INDEX — remove an index",
    "metadata": {
      "doc_name": "sql-dropindex",
      "section_title": "DROP INDEX",
      "url": "https://www.postgresql.org/docs/16/sql-dropindex.html"
    }
  },
  {
    "chunk_id": 1,
    "text": "CODE:\n\nDROP INDEX [ CONCURRENTLY ] [ IF EXISTS ] name [, ...] [ CASCADE | RESTRICT ]",
    "metadata": {
      "doc_name": "sql-dropindex",
      "section_title": "Synopsis",
      "url": "https://www.postgresql.org/docs/16/sql-dropindex.html"
    }
  },
  {
    "chunk_id": 2,
    "text": "DROP INDEXdrops an existing index from the database system. To execute this command you must be the owner of the index.",
    "metadata": {
      "doc_name": "sql-dropindex",
      "section_title": "Description",
      "url": "https://www.postgresql.org/docs/16/sql-dropindex.html"
    }
  },
  {
    "chunk_id": 3,
    "text": "Drop the index without locking out concurrent selects, inserts, updates, and deletes on the index's table. A normalDROP INDEXacquires anACCESS EXCLUSIVElock on the table, blocking other accesses until the index drop can be completed. With this option, the command instead waits until conflicting transactions have completed.\nThere are several caveats to be aware of when using this option. Only one index name can be specified, and theCASCADEoption is not supported. (Thus, an index that supports aUNIQUEorPRIMARY KEYconstraint cannot be dropped this way.) Also, regularDROP INDEXcommands can be performed within a transaction block, butDROP INDEX CONCURRENTLYcannot. Lastly, indexes on partitioned tables cannot be dropped using this option.\nFor temporary tables,DROP INDEXis always non-concurrent, as no other session can access them, and non-concurrent index drop is cheaper.\nDo not throw an error if the index does not exist. A notice is issued in this case.\nThe name (optionally schema-qualified) of an index to remove.\nAutomatically drop objects that depend on the index, and in turn all objects that depend on those objects (seeSection 5.14).\nRefuse to drop the index if any objects depend on it. This is the default.",
    "metadata": {
      "doc_name": "sql-dropindex",
      "section_title": "Parameters",
      "url": "https://www.postgresql.org/docs/16/sql-dropindex.html"
    }
  },
  {
    "chunk_id": 4,
    "text": "This command will remove the indextitle_idx:\n\n\nCODE:\n\nDROP INDEX title_idx;",
    "metadata": {
      "doc_name": "sql-dropindex",
      "section_title": "Examples",
      "url": "https://www.postgresql.org/docs/16/sql-dropindex.html"
    }
  },
  {
    "chunk_id": 5,
    "text": "DROP INDEXis aPostgreSQLlanguage extension. There are no provisions for indexes in the SQL standard.",
    "metadata": {
      "doc_name": "sql-dropindex",
      "section_title": "Compatibility",
      "url": "https://www.postgresql.org/docs/16/sql-dropindex.html"
    }
  },
  {
    "chunk_id": 0,
    "text": "DROP TABLE — remove a table",
    "metadata": {
      "doc_name": "sql-droptable",
      "section_title": "DROP TABLE",
      "url": "https://www.postgresql.org/docs/16/sql-droptable.html"
    }
  },
  {
    "chunk_id": 1,
    "text": "CODE:\n\nDROP TABLE [ IF EXISTS ] name [, ...] [ CASCADE | RESTRICT ]",
    "metadata": {
      "doc_name": "sql-droptable",
      "section_title": "Synopsis",
      "url": "https://www.postgresql.org/docs/16/sql-droptable.html"
    }
  },
  {
    "chunk_id": 2,
    "text": "DROP TABLEremoves tables from the database. Only the table owner, the schema owner, and superuser can drop a table. To empty a table of rows without destroying the table, useDELETEorTRUNCATE.\nDROP TABLEalways removes any indexes, rules, triggers, and constraints that exist for the target table. However, to drop a table that is referenced by a view or a foreign-key constraint of another table,CASCADEmust be specified. (CASCADEwill remove a dependent view entirely, but in the foreign-key case it will only remove the foreign-key constraint, not the other table entirely.)",
    "metadata": {
      "doc_name": "sql-droptable",
      "section_title": "Description",
      "url": "https://www.postgresql.org/docs/16/sql-droptable.html"
    }
  },
  {
    "chunk_id": 3,
    "text": "Do not throw an error if the table does not exist. A notice is issued in this case.\nThe name (optionally schema-qualified) of the table to drop.\nAutomatically drop objects that depend on the table (such as views), and in turn all objects that depend on those objects (seeSection 5.14).\nRefuse to drop the table if any objects depend on it. This is the default.",
    "metadata": {
      "doc_name": "sql-droptable",
      "section_title": "Parameters",
      "url": "https://www.postgresql.org/docs/16/sql-droptable.html"
    }
  },
  {
    "chunk_id": 4,
    "text": "To destroy two tables,filmsanddistributors:\n\n\nCODE:\n\nDROP TABLE films, distributors;",
    "metadata": {
      "doc_name": "sql-droptable",
      "section_title": "Examples",
      "url": "https://www.postgresql.org/docs/16/sql-droptable.html"
    }
  },
  {
    "chunk_id": 5,
    "text": "This command conforms to the SQL standard, except that the standard only allows one table to be dropped per command, and apart from theIF EXISTSoption, which is aPostgreSQLextension.",
    "metadata": {
      "doc_name": "sql-droptable",
      "section_title": "Compatibility",
      "url": "https://www.postgresql.org/docs/16/sql-droptable.html"
    }
  },
  {
    "chunk_id": 0,
    "text": "EXPLAIN — show the execution plan of a statement",
    "metadata": {
      "doc_name": "sql-explain",
      "section_title": "EXPLAIN",
      "url": "https://www.postgresql.org/docs/16/sql-explain.html"
    }
  },
  {
    "chunk_id": 1,
    "text": "CODE:\n\nEXPLAIN [ ( option [, ...] ) ] statement\nEXPLAIN [ ANALYZE ] [ VERBOSE ] statement\n\nwhere option can be one of:\n\n    ANALYZE [ boolean ]\n    VERBOSE [ boolean ]\n    COSTS [ boolean ]\n    SETTINGS [ boolean ]\n    GENERIC_PLAN [ boolean ]\n    BUFFERS [ boolean ]\n    WAL [ boolean ]\n    TIMING [ boolean ]\n    SUMMARY [ boolean ]\n    FORMAT { TEXT | XML | JSON | YAML }",
    "metadata": {
      "doc_name": "sql-explain",
      "section_title": "Synopsis",
      "url": "https://www.postgresql.org/docs/16/sql-explain.html"
    }
  },
  {
    "chunk_id": 2,
    "text": "This command displays the execution plan that thePostgreSQLplanner generates for the supplied statement. The execution plan shows how the table(s) referenced by the statement will be scanned — by plain sequential scan, index scan, etc. — and if multiple tables are referenced, what join algorithms will be used to bring together the required rows from each input table.\nThe most critical part of the display is the estimated statement execution cost, which is the planner's guess at how long it will take to run the statement (measured in cost units that are arbitrary, but conventionally mean disk page fetches). Actually two numbers are shown: the start-up cost before the first row can be returned, and the total cost to return all the rows. For most queries the total cost is what matters, but in contexts such as a subquery inEXISTS, the planner will choose the smallest start-up cost instead of the smallest total cost (since the executor will stop after getting one row, anyway). Also, if you limit the number of rows to return with aLIMITclause, the planner makes an appropriate interpolation between the endpoint costs to estimate which plan is really the cheapest.\nTheANALYZEoption causes the statement to be actually executed, not only planned. Then actual run time statistics are added to the display, including the total elapsed time expended within each plan node (in milliseconds) and the total number of rows it actually returned. This is useful for seeing whether the planner's estimates are close to reality.",
    "metadata": {
      "doc_name": "sql-explain",
      "section_title": "Description",
      "url": "https://www.postgresql.org/docs/16/sql-explain.html"
    }
  },
  {
    "chunk_id": 3,
    "text": "Keep in mind that the statement is actually executed when theANALYZEoption is used. AlthoughEXPLAINwill discard any output that aSELECTwould return, other side effects of the statement will happen as usual. If you wish to useEXPLAIN ANALYZEon anINSERT,UPDATE,DELETE,MERGE,CREATE TABLE AS, orEXECUTEstatement without letting the command affect your data, use this approach:\n\n\nCODE:\n\nBEGIN;\nEXPLAIN ANALYZE ...;\nROLLBACK;\n\nOnly theANALYZEandVERBOSEoptions can be specified, and only in that order, without surrounding the option list in parentheses. Prior toPostgreSQL9.0, the unparenthesized syntax was the only one supported. It is expected that all new options will be supported only in the parenthesized syntax.",
    "metadata": {
      "doc_name": "sql-explain",
      "section_title": "Important",
      "url": "https://www.postgresql.org/docs/16/sql-explain.html"
    }
  },
  {
    "chunk_id": 4,
    "text": "Carry out the command and show actual run times and other statistics. This parameter defaults toFALSE.\nDisplay additional information regarding the plan. Specifically, include the output column list for each node in the plan tree, schema-qualify table and function names, always label variables in expressions with their range table alias, and always print the name of each trigger for which statistics are displayed. The query identifier will also be displayed if one has been computed, seecompute_query_idfor more details. This parameter defaults toFALSE.\nInclude information on the estimated startup and total cost of each plan node, as well as the estimated number of rows and the estimated width of each row. This parameter defaults toTRUE.\nInclude information on configuration parameters. Specifically, include options affecting query planning with value different from the built-in default value. This parameter defaults toFALSE.\nAllow the statement to contain parameter placeholders like$1, and generate a generic plan that does not depend on the values of those parameters. SeePREPAREfor details about generic plans and the types of statement that support parameters. This parameter cannot be used together withANALYZE. It defaults toFALSE.\nInclude information on buffer usage. Specifically, include the number of shared blocks hit, read, dirtied, and written, the number of local blocks hit, read, dirtied, and written, the number of temp blocks read and written, and the time spent reading and writing data file blocks and temporary file blocks (in milliseconds) iftrack_io_timingis enabled. Ahitmeans that a read was avoided because the block was found already in cache when needed. Shared blocks contain data from regular tables and indexes; local blocks contain data from temporary tables and indexes; while temporary blocks contain short-term working data used in sorts, hashes, Materialize plan nodes, and similar cases. The number of blocksdirtiedindicates the number of previously unmodified blocks that were changed by this query; while the number of blockswrittenindicates the number of previously-dirtied blocks evicted from cache by this backend during query processing. The number of blocks shown for an upper-level node includes those used by all its child nodes. In text format, only non-zero values are printed. This parameter defaults toFALSE.\nInclude information on WAL record generation. Specifically, include the number of records, number of full page images (fpi) and the amount of WAL generated in bytes. In text format, only non-zero values are printed. This parameter may",
    "metadata": {
      "doc_name": "sql-explain",
      "section_title": "Parameters",
      "url": "https://www.postgresql.org/docs/16/sql-explain.html"
    }
  },
  {
    "chunk_id": 5,
    "text": "of previously-dirtied blocks evicted from cache by this backend during query processing. The number of blocks shown for an upper-level node includes those used by all its child nodes. In text format, only non-zero values are printed. This parameter defaults toFALSE.\nInclude information on WAL record generation. Specifically, include the number of records, number of full page images (fpi) and the amount of WAL generated in bytes. In text format, only non-zero values are printed. This parameter may only be used whenANALYZEis also enabled. It defaults toFALSE.\nInclude actual startup time and time spent in each node in the output. The overhead of repeatedly reading the system clock can slow down the query significantly on some systems, so it may be useful to set this parameter toFALSEwhen only actual row counts, and not exact times, are needed. Run time of the entire statement is always measured, even when node-level timing is turned off with this option. This parameter may only be used whenANALYZEis also enabled. It defaults toTRUE.\nInclude summary information (e.g., totaled timing information) after the query plan. Summary information is included by default whenANALYZEis used but otherwise is not included by default, but can be enabled using this option. Planning time inEXPLAIN EXECUTEincludes the time required to fetch the plan from the cache and the time required for re-planning, if necessary.\nSpecify the output format, which can be TEXT, XML, JSON, or YAML. Non-text output contains the same information as the text output format, but is easier for programs to parse. This parameter defaults toTEXT.\nSpecifies whether the selected option should be turned on or off. You can writeTRUE,ON, or1to enable the option, andFALSE,OFF, or0to disable it. Thebooleanvalue can also be omitted, in which caseTRUEis assumed.\nAnySELECT,INSERT,UPDATE,DELETE,MERGE,VALUES,EXECUTE,DECLARE,CREATE TABLE AS, orCREATE MATERIALIZED VIEW ASstatement, whose execution plan you wish to see.",
    "metadata": {
      "doc_name": "sql-explain",
      "section_title": "Parameters",
      "url": "https://www.postgresql.org/docs/16/sql-explain.html"
    }
  },
  {
    "chunk_id": 6,
    "text": "The command's result is a textual description of the plan selected for thestatement, optionally annotated with execution statistics.Section 14.1describes the information provided.",
    "metadata": {
      "doc_name": "sql-explain",
      "section_title": "Outputs",
      "url": "https://www.postgresql.org/docs/16/sql-explain.html"
    }
  },
  {
    "chunk_id": 7,
    "text": "In order to allow thePostgreSQLquery planner to make reasonably informed decisions when optimizing queries, thepg_statisticdata should be up-to-date for all tables used in the query. Normally theautovacuum daemonwill take care of that automatically. But if a table has recently had substantial changes in its contents, you might need to do a manualANALYZErather than wait for autovacuum to catch up with the changes.\nIn order to measure the run-time cost of each node in the execution plan, the current implementation ofEXPLAIN ANALYZEadds profiling overhead to query execution. As a result, runningEXPLAIN ANALYZEon a query can sometimes take significantly longer than executing the query normally. The amount of overhead depends on the nature of the query, as well as the platform being used. The worst case occurs for plan nodes that in themselves require very little time per execution, and on machines that have relatively slow operating system calls for obtaining the time of day.",
    "metadata": {
      "doc_name": "sql-explain",
      "section_title": "Notes",
      "url": "https://www.postgresql.org/docs/16/sql-explain.html"
    }
  },
  {
    "chunk_id": 8,
    "text": "To show the plan for a simple query on a table with a singleintegercolumn and 10000 rows:\n\n\nCODE:\n\nEXPLAIN SELECT * FROM foo;\n\n                       QUERY PLAN\n---------------------------------------------------------\n Seq Scan on foo  (cost=0.00..155.00 rows=10000 width=4)\n(1 row)\n\nHere is the same query, with JSON output formatting:\n\n\nCODE:\n\nEXPLAIN (FORMAT JSON) SELECT * FROM foo;\n           QUERY PLAN\n--------------------------------\n [                             +\n   {                           +\n     \"Plan\": {                 +\n       \"Node Type\": \"Seq Scan\",+\n       \"Relation Name\": \"foo\", +\n       \"Alias\": \"foo\",         +\n       \"Startup Cost\": 0.00,   +\n       \"Total Cost\": 155.00,   +\n       \"Plan Rows\": 10000,     +\n       \"Plan Width\": 4         +\n     }                         +\n   }                           +\n ]\n(1 row)\n\nIf there is an index and we use a query with an indexableWHEREcondition,EXPLAINmight show a different plan:\n\n\nCODE:\n\nEXPLAIN SELECT * FROM foo WHERE i = 4;\n\n                         QUERY PLAN\n--------------------------------------------------------------\n Index Scan using fi on foo  (cost=0.00..5.98 rows=1 width=4)\n   Index Cond: (i = 4)\n(2 rows)\n\nHere is the same query, but in YAML format:\n\n\nCODE:\n\nEXPLAIN (FORMAT YAML) SELECT * FROM foo WHERE i='4';\n          QUERY PLAN\n-------------------------------\n - Plan:                      +\n     Node Type: \"Index Scan\"  +\n     Scan Direction: \"Forward\"+\n     Index Name: \"fi\"         +\n     Relation Name: \"foo\"     +\n     Alias: \"foo\"             +\n     Startup Cost: 0.00       +\n     Total Cost: 5.98         +\n     Plan Rows: 1             +\n     Plan Width: 4            +\n     Index Cond: \"(i = 4)\"\n(1 row)\n\nXML format is left as an exercise for the reader.\nHere is the same plan with cost estimates suppressed:\n\n\nCODE:\n\nEXPLAIN (COSTS FALSE) SELECT * FROM foo WHERE i = 4;\n\n        QUERY PLAN\n----------------------------\n Index Scan using fi on foo\n   Index Cond: (i = 4)\n(2 rows)\n\nHere is an example of a query plan for a query using an aggregate function:\n\n\nCODE:\n\nEXPLAIN SELECT sum(i)",
    "metadata": {
      "doc_name": "sql-explain",
      "section_title": "Examples",
      "url": "https://www.postgresql.org/docs/16/sql-explain.html"
    }
  },
  {
    "chunk_id": 9,
    "text": "= 4)\"\n(1 row)\n\nXML format is left as an exercise for the reader.\nHere is the same plan with cost estimates suppressed:\n\n\nCODE:\n\nEXPLAIN (COSTS FALSE) SELECT * FROM foo WHERE i = 4;\n\n        QUERY PLAN\n----------------------------\n Index Scan using fi on foo\n   Index Cond: (i = 4)\n(2 rows)\n\nHere is an example of a query plan for a query using an aggregate function:\n\n\nCODE:\n\nEXPLAIN SELECT sum(i) FROM foo WHERE i < 10;\n\n                             QUERY PLAN\n-------------------------------------------------------------------​--\n Aggregate  (cost=23.93..23.93 rows=1 width=4)\n   ->  Index Scan using fi on foo  (cost=0.00..23.92 rows=6 width=4)\n         Index Cond: (i < 10)\n(3 rows)\n\nHere is an example of usingEXPLAIN EXECUTEto display the execution plan for a prepared query:\n\n\nCODE:\n\nPREPARE query(int, int) AS SELECT sum(bar) FROM test\n    WHERE id > $1 AND id < $2\n    GROUP BY foo;\n\nEXPLAIN ANALYZE EXECUTE query(100, 200);\n\n                                                       QUERY PLAN\n-------------------------------------------------------------------​------------------------------------------------------\n HashAggregate  (cost=10.77..10.87 rows=10 width=12) (actual time=0.043..0.044 rows=10 loops=1)\n   Group Key: foo\n   Batches: 1  Memory Usage: 24kB\n   ->  Index Scan using test_pkey on test  (cost=0.29..10.27 rows=99 width=8) (actual time=0.009..0.025 rows=99 loops=1)\n         Index Cond: ((id > 100) AND (id < 200))\n Planning Time: 0.244 ms\n Execution Time: 0.073 ms\n(7 rows)\n\nOf course, the specific numbers shown here depend on the actual contents of the tables involved. Also note that the numbers, and even the selected query strategy, might vary betweenPostgreSQLreleases due to planner improvements. In addition, theANALYZEcommand uses random sampling to estimate data statistics; therefore, it is possible for cost estimates to change after a fresh run ofANALYZE, even if the actual distribution of data in the table has not changed.\nNotice that the previous example showed a“",
    "metadata": {
      "doc_name": "sql-explain",
      "section_title": "Examples",
      "url": "https://www.postgresql.org/docs/16/sql-explain.html"
    }
  },
  {
    "chunk_id": 10,
    "text": ", the specific numbers shown here depend on the actual contents of the tables involved. Also note that the numbers, and even the selected query strategy, might vary betweenPostgreSQLreleases due to planner improvements. In addition, theANALYZEcommand uses random sampling to estimate data statistics; therefore, it is possible for cost estimates to change after a fresh run ofANALYZE, even if the actual distribution of data in the table has not changed.\nNotice that the previous example showed a“custom”plan for the specific parameter values given inEXECUTE. We might also wish to see the generic plan for a parameterized query, which can be done withGENERIC_PLAN:\n\n\nCODE:\n\nEXPLAIN (GENERIC_PLAN)\n  SELECT sum(bar) FROM test\n    WHERE id > $1 AND id < $2\n    GROUP BY foo;\n\n                                  QUERY PLAN\n-------------------------------------------------------------------​------------\n HashAggregate  (cost=26.79..26.89 rows=10 width=12)\n   Group Key: foo\n   ->  Index Scan using test_pkey on test  (cost=0.29..24.29 rows=500 width=8)\n         Index Cond: ((id > $1) AND (id < $2))\n(4 rows)\n\nIn this case the parser correctly inferred that$1and$2should have the same data type asid, so the lack of parameter type information fromPREPAREwas not a problem. In other cases it might be necessary to explicitly specify types for the parameter symbols, which can be done by casting them, for example:\n\n\nCODE:\n\nEXPLAIN (GENERIC_PLAN)\n  SELECT sum(bar) FROM test\n    WHERE id > $1::integer AND id < $2::integer\n    GROUP BY foo;",
    "metadata": {
      "doc_name": "sql-explain",
      "section_title": "Examples",
      "url": "https://www.postgresql.org/docs/16/sql-explain.html"
    }
  },
  {
    "chunk_id": 11,
    "text": "There is noEXPLAINstatement defined in the SQL standard.",
    "metadata": {
      "doc_name": "sql-explain",
      "section_title": "Compatibility",
      "url": "https://www.postgresql.org/docs/16/sql-explain.html"
    }
  },
  {
    "chunk_id": 0,
    "text": "GRANT — define access privileges",
    "metadata": {
      "doc_name": "sql-grant",
      "section_title": "GRANT",
      "url": "https://www.postgresql.org/docs/16/sql-grant.html"
    }
  },
  {
    "chunk_id": 1,
    "text": "CODE:\n\nGRANT { { SELECT | INSERT | UPDATE | DELETE | TRUNCATE | REFERENCES | TRIGGER }\n    [, ...] | ALL [ PRIVILEGES ] }\n    ON { [ TABLE ] table_name [, ...]\n         | ALL TABLES IN SCHEMA schema_name [, ...] }\n    TO role_specification [, ...] [ WITH GRANT OPTION ]\n    [ GRANTED BY role_specification ]\n\nGRANT { { SELECT | INSERT | UPDATE | REFERENCES } ( column_name [, ...] )\n    [, ...] | ALL [ PRIVILEGES ] ( column_name [, ...] ) }\n    ON [ TABLE ] table_name [, ...]\n    TO role_specification [, ...] [ WITH GRANT OPTION ]\n    [ GRANTED BY role_specification ]\n\nGRANT { { USAGE | SELECT | UPDATE }\n    [, ...] | ALL [ PRIVILEGES ] }\n    ON { SEQUENCE sequence_name [, ...]\n         | ALL SEQUENCES IN SCHEMA schema_name [, ...] }\n    TO role_specification [, ...] [ WITH GRANT OPTION ]\n    [ GRANTED BY role_specification ]\n\nGRANT { { CREATE | CONNECT | TEMPORARY | TEMP } [, ...] | ALL [ PRIVILEGES ] }\n    ON DATABASE database_name [, ...]\n    TO role_specification [, ...] [ WITH GRANT OPTION ]\n    [ GRANTED BY role_specification ]\n\nGRANT { USAGE | ALL [ PRIVILEGES ] }\n    ON DOMAIN domain_name [, ...]\n    TO role_specification [, ...] [ WITH GRANT OPTION ]\n    [ GRANTED BY role_specification ]\n\nGRANT { USAGE | ALL [ PRIVILEGES ] }\n    ON FOREIGN DATA WRAPPER fdw_name [, ...]\n    TO role_specification [, ...] [ WITH GRANT OPTION ]\n    [ GRANTED BY role_specification ]\n\nGRANT { USAGE | ALL [ PRIVILEGES ] }\n    ON FOREIGN SERVER server_name [, ...]\n    TO role_specification [, ...] [ WITH GRANT OPTION ]\n    [ GRANTED BY role_specification ]\n\nGRANT { EXECUTE | ALL [ PRIVILEGES ] }\n    ON { { FUNCTION | PROCEDURE | ROUTINE } routine_name [ ( [ [ argmode ] [ arg_name ] arg_type [, ...] ] ) ] [, ...]\n         | ALL { FUNCTIONS | PROCEDURES | ROUTINES } IN SCHEMA schema_name [, ...] }\n    TO role_specification [, ...] [ WITH GRANT OPTION ]",
    "metadata": {
      "doc_name": "sql-grant",
      "section_title": "Synopsis",
      "url": "https://www.postgresql.org/docs/16/sql-grant.html"
    }
  },
  {
    "chunk_id": 2,
    "text": "WITH GRANT OPTION ]\n    [ GRANTED BY role_specification ]\n\nGRANT { EXECUTE | ALL [ PRIVILEGES ] }\n    ON { { FUNCTION | PROCEDURE | ROUTINE } routine_name [ ( [ [ argmode ] [ arg_name ] arg_type [, ...] ] ) ] [, ...]\n         | ALL { FUNCTIONS | PROCEDURES | ROUTINES } IN SCHEMA schema_name [, ...] }\n    TO role_specification [, ...] [ WITH GRANT OPTION ]\n    [ GRANTED BY role_specification ]\n\nGRANT { USAGE | ALL [ PRIVILEGES ] }\n    ON LANGUAGE lang_name [, ...]\n    TO role_specification [, ...] [ WITH GRANT OPTION ]\n    [ GRANTED BY role_specification ]\n\nGRANT { { SELECT | UPDATE } [, ...] | ALL [ PRIVILEGES ] }\n    ON LARGE OBJECT loid [, ...]\n    TO role_specification [, ...] [ WITH GRANT OPTION ]\n    [ GRANTED BY role_specification ]\n\nGRANT { { SET | ALTER SYSTEM } [, ... ] | ALL [ PRIVILEGES ] }\n    ON PARAMETER configuration_parameter [, ...]\n    TO role_specification [, ...] [ WITH GRANT OPTION ]\n    [ GRANTED BY role_specification ]\n\nGRANT { { CREATE | USAGE } [, ...] | ALL [ PRIVILEGES ] }\n    ON SCHEMA schema_name [, ...]\n    TO role_specification [, ...] [ WITH GRANT OPTION ]\n    [ GRANTED BY role_specification ]\n\nGRANT { CREATE | ALL [ PRIVILEGES ] }\n    ON TABLESPACE tablespace_name [, ...]\n    TO role_specification [, ...] [ WITH GRANT OPTION ]\n    [ GRANTED BY role_specification ]\n\nGRANT { USAGE | ALL [ PRIVILEGES ] }\n    ON TYPE type_name [, ...]\n    TO role_specification [, ...] [ WITH GRANT OPTION ]\n    [ GRANTED BY role_specification ]\n\nGRANT role_name [, ...] TO role_specification [, ...]\n    [ WITH { ADMIN | INHERIT | SET } { OPTION | TRUE | FALSE } ]\n    [ GRANTED BY role_specification ]\n\nwhere role_specification can be:\n\n    [ GROUP ] role_name\n  | PUBLIC\n  | CURRENT_ROLE\n  | CURRENT_USER\n  | SESSION_USER",
    "metadata": {
      "doc_name": "sql-grant",
      "section_title": "Synopsis",
      "url": "https://www.postgresql.org/docs/16/sql-grant.html"
    }
  },
  {
    "chunk_id": 3,
    "text": "TheGRANTcommand has two basic variants: one that grants privileges on a database object (table, column, view, foreign table, sequence, database, foreign-data wrapper, foreign server, function, procedure, procedural language, large object, configuration parameter, schema, tablespace, or type), and one that grants membership in a role. These variants are similar in many ways, but they are different enough to be described separately.",
    "metadata": {
      "doc_name": "sql-grant",
      "section_title": "Description",
      "url": "https://www.postgresql.org/docs/16/sql-grant.html"
    }
  },
  {
    "chunk_id": 4,
    "text": "This variant of theGRANTcommand gives specific privileges on a database object to one or more roles. These privileges are added to those already granted, if any.\nThe key wordPUBLICindicates that the privileges are to be granted to all roles, including those that might be created later.PUBLICcan be thought of as an implicitly defined group that always includes all roles. Any particular role will have the sum of privileges granted directly to it, privileges granted to any role it is presently a member of, and privileges granted toPUBLIC.\nIfWITH GRANT OPTIONis specified, the recipient of the privilege can in turn grant it to others. Without a grant option, the recipient cannot do that. Grant options cannot be granted toPUBLIC.\nIfGRANTED BYis specified, the specified grantor must be the current user. This clause is currently present in this form only for SQL compatibility.\nThere is no need to grant privileges to the owner of an object (usually the user that created it), as the owner has all privileges by default. (The owner could, however, choose to revoke some of their own privileges for safety.)\nThe right to drop an object, or to alter its definition in any way, is not treated as a grantable privilege; it is inherent in the owner, and cannot be granted or revoked. (However, a similar effect can be obtained by granting or revoking membership in the role that owns the object; see below.) The owner implicitly has all grant options for the object, too.\nThe possible privileges are:\nSpecific types of privileges, as defined inSection 5.7.\nAlternative spelling forTEMPORARY.\nGrant all of the privileges available for the object's type. ThePRIVILEGESkey word is optional inPostgreSQL, though it is required by strict SQL.\nTheFUNCTIONsyntax works for plain functions, aggregate functions, and window functions, but not for procedures; usePROCEDUREfor those. Alternatively, useROUTINEto refer to a function, aggregate function, window function, or procedure regardless of its precise type.\nThere is also an option to grant privileges on all objects of the same type within one or more schemas. This functionality is currently supported only for tables, sequences, functions, and procedures.ALL TABLESalso affects views and foreign tables, just like the specific-objectGRANTcommand.ALL FUNCTIONSalso affects aggregate and window functions, but not procedures, again just like the specific-objectGRANTcommand. UseALL ROUTINESto include procedures.",
    "metadata": {
      "doc_name": "sql-grant",
      "section_title": "GRANT on Database Objects",
      "url": "https://www.postgresql.org/docs/16/sql-grant.html"
    }
  },
  {
    "chunk_id": 5,
    "text": "This variant of theGRANTcommand grants membership in a role to one or more other roles, and the modification of membership optionsSET,INHERIT, andADMIN; seeSection 22.3for details. Membership in a role is significant because it potentially allows access to the privileges granted to a role to each of its members, and potentially also the ability to make changes to the role itself. However, the actual permissions conferred depend on the options associated with the grant. To modify that options of an existing membership, simply specify the membership with updated option values.\nEach of the options described below can be set to eitherTRUEorFALSE. The keywordOPTIONis accepted as a synonym forTRUE, so thatWITH ADMIN OPTIONis a synonym forWITH ADMIN TRUE. When altering an existing membership the omission of an option results in the current value being retained.\nTheADMINoption allows the member to in turn grant membership in the role to others, and revoke membership in the role as well. Without the admin option, ordinary users cannot do that. A role is not considered to holdWITH ADMIN OPTIONon itself. Database superusers can grant or revoke membership in any role to anyone. This option defaults toFALSE.\nTheINHERIToption controls the inheritance status of the new membership; seeSection 22.3for details on inheritance. If it is set toTRUE, it causes the new member to inherit from the granted role. If set toFALSE, the new member does not inherit. If unspecified when creating a new role membership, this defaults to the inheritance attribute of the new member.\nTheSEToption, if it is set toTRUE, allows the member to change to the granted role using theSET ROLEcommand. If a role is an indirect member of another role, it can useSET ROLEto change to that role only if there is a chain of grants each of which hasSET TRUE. This option defaults toTRUE.\nTo create an object owned by another role or give ownership of an existing object to another role, you must have the ability toSET ROLEto that role; otherwise, commands such asALTER ... OWNER TOorCREATE DATABASE ... OWNERwill fail. However, a user who inherits the privileges of a role but does not have the ability toSET ROLEto that role may be able to obtain full access to the role by manipulating existing objects owned by that role (e.g. they could redefine an existing function to act as a Trojan horse). Therefore, if a role's privileges are to",
    "metadata": {
      "doc_name": "sql-grant",
      "section_title": "GRANT on Roles",
      "url": "https://www.postgresql.org/docs/16/sql-grant.html"
    }
  },
  {
    "chunk_id": 6,
    "text": "to another role, you must have the ability toSET ROLEto that role; otherwise, commands such asALTER ... OWNER TOorCREATE DATABASE ... OWNERwill fail. However, a user who inherits the privileges of a role but does not have the ability toSET ROLEto that role may be able to obtain full access to the role by manipulating existing objects owned by that role (e.g. they could redefine an existing function to act as a Trojan horse). Therefore, if a role's privileges are to be inherited but should not be accessible viaSET ROLE, it should not own any SQL objects.\nIfGRANTED BYis specified, the grant is recorded as having been done by the specified role. A user can only attribute a grant to another role if they possess the privileges of that role. The role recorded as the grantor must haveADMIN OPTIONon the target role, unless it is the bootstrap superuser. When a grant is recorded as having a grantor other than the bootstrap superuser, it depends on the grantor continuing to possessADMIN OPTIONon the role; so, ifADMIN OPTIONis revoked, dependent grants must be revoked as well.\nUnlike the case with privileges, membership in a role cannot be granted toPUBLIC. Note also that this form of the command does not allow the noise wordGROUPinrole_specification.",
    "metadata": {
      "doc_name": "sql-grant",
      "section_title": "GRANT on Roles",
      "url": "https://www.postgresql.org/docs/16/sql-grant.html"
    }
  },
  {
    "chunk_id": 7,
    "text": "TheREVOKEcommand is used to revoke access privileges.\nSincePostgreSQL8.1, the concepts of users and groups have been unified into a single kind of entity called a role. It is therefore no longer necessary to use the keywordGROUPto identify whether a grantee is a user or a group.GROUPis still allowed in the command, but it is a noise word.\nA user may performSELECT,INSERT, etc. on a column if they hold that privilege for either the specific column or its whole table. Granting the privilege at the table level and then revoking it for one column will not do what one might wish: the table-level grant is unaffected by a column-level operation.\nWhen a non-owner of an object attempts toGRANTprivileges on the object, the command will fail outright if the user has no privileges whatsoever on the object. As long as some privilege is available, the command will proceed, but it will grant only those privileges for which the user has grant options. TheGRANT ALL PRIVILEGESforms will issue a warning message if no grant options are held, while the other forms will issue a warning if grant options for any of the privileges specifically named in the command are not held. (In principle these statements apply to the object owner as well, but since the owner is always treated as holding all grant options, the cases can never occur.)\nIt should be noted that database superusers can access all objects regardless of object privilege settings. This is comparable to the rights ofrootin a Unix system. As withroot, it's unwise to operate as a superuser except when absolutely necessary.\nIf a superuser chooses to issue aGRANTorREVOKEcommand, the command is performed as though it were issued by the owner of the affected object. In particular, privileges granted via such a command will appear to have been granted by the object owner. (For role membership, the membership appears to have been granted by the bootstrap superuser.)\nGRANTandREVOKEcan also be done by a role that is not the owner of the affected object, but is a member of the role that owns the object, or is a member of a role that holds privilegesWITH GRANT OPTIONon the object. In this case the privileges will be recorded as having been granted by the role that actually owns the object or holds the privilegesWITH GRANT OPTION. For example, if tablet1is owned by roleg1, of which roleu1is a member",
    "metadata": {
      "doc_name": "sql-grant",
      "section_title": "Notes",
      "url": "https://www.postgresql.org/docs/16/sql-grant.html"
    }
  },
  {
    "chunk_id": 8,
    "text": "andREVOKEcan also be done by a role that is not the owner of the affected object, but is a member of the role that owns the object, or is a member of a role that holds privilegesWITH GRANT OPTIONon the object. In this case the privileges will be recorded as having been granted by the role that actually owns the object or holds the privilegesWITH GRANT OPTION. For example, if tablet1is owned by roleg1, of which roleu1is a member, thenu1can grant privileges ont1tou2, but those privileges will appear to have been granted directly byg1. Any other member of roleg1could revoke them later.\nIf the role executingGRANTholds the required privileges indirectly via more than one role membership path, it is unspecified which containing role will be recorded as having done the grant. In such cases it is best practice to useSET ROLEto become the specific role you want to do theGRANTas.\nGranting permission on a table does not automatically extend permissions to any sequences used by the table, including sequences tied toSERIALcolumns. Permissions on sequences must be set separately.\nSeeSection 5.7for more information about specific privilege types, as well as how to inspect objects' privileges.",
    "metadata": {
      "doc_name": "sql-grant",
      "section_title": "Notes",
      "url": "https://www.postgresql.org/docs/16/sql-grant.html"
    }
  },
  {
    "chunk_id": 9,
    "text": "Grant insert privilege to all users on tablefilms:\n\n\nCODE:\n\nGRANT INSERT ON films TO PUBLIC;\n\nGrant all available privileges to usermanuelon viewkinds:\n\n\nCODE:\n\nGRANT ALL PRIVILEGES ON kinds TO manuel;\n\nNote that while the above will indeed grant all privileges if executed by a superuser or the owner ofkinds, when executed by someone else it will only grant those permissions for which the someone else has grant options.\nGrant membership in roleadminsto userjoe:\n\n\nCODE:\n\nGRANT admins TO joe;",
    "metadata": {
      "doc_name": "sql-grant",
      "section_title": "Examples",
      "url": "https://www.postgresql.org/docs/16/sql-grant.html"
    }
  },
  {
    "chunk_id": 10,
    "text": "According to the SQL standard, thePRIVILEGESkey word inALL PRIVILEGESis required. The SQL standard does not support setting the privileges on more than one object per command.\nPostgreSQLallows an object owner to revoke their own ordinary privileges: for example, a table owner can make the table read-only to themselves by revoking their ownINSERT,UPDATE,DELETE, andTRUNCATEprivileges. This is not possible according to the SQL standard. The reason is thatPostgreSQLtreats the owner's privileges as having been granted by the owner to themselves; therefore they can revoke them too. In the SQL standard, the owner's privileges are granted by an assumed entity“_SYSTEM”. Not being“_SYSTEM”, the owner cannot revoke these rights.\nAccording to the SQL standard, grant options can be granted toPUBLIC; PostgreSQL only supports granting grant options to roles.\nThe SQL standard allows theGRANTED BYoption to specify onlyCURRENT_USERorCURRENT_ROLE. The other variants are PostgreSQL extensions.\nThe SQL standard provides for aUSAGEprivilege on other kinds of objects: character sets, collations, translations.\nIn the SQL standard, sequences only have aUSAGEprivilege, which controls the use of theNEXT VALUE FORexpression, which is equivalent to the functionnextvalin PostgreSQL. The sequence privilegesSELECTandUPDATEare PostgreSQL extensions. The application of the sequenceUSAGEprivilege to thecurrvalfunction is also a PostgreSQL extension (as is the function itself).\nPrivileges on databases, tablespaces, schemas, languages, and configuration parameters arePostgreSQLextensions.",
    "metadata": {
      "doc_name": "sql-grant",
      "section_title": "Compatibility",
      "url": "https://www.postgresql.org/docs/16/sql-grant.html"
    }
  },
  {
    "chunk_id": 0,
    "text": "INSERT — create new rows in a table",
    "metadata": {
      "doc_name": "sql-insert",
      "section_title": "INSERT",
      "url": "https://www.postgresql.org/docs/16/sql-insert.html"
    }
  },
  {
    "chunk_id": 1,
    "text": "CODE:\n\n[ WITH [ RECURSIVE ] with_query [, ...] ]\nINSERT INTO table_name [ AS alias ] [ ( column_name [, ...] ) ]\n    [ OVERRIDING { SYSTEM | USER } VALUE ]\n    { DEFAULT VALUES | VALUES ( { expression | DEFAULT } [, ...] ) [, ...] | query }\n    [ ON CONFLICT [ conflict_target ] conflict_action ]\n    [ RETURNING { * | output_expression [ [ AS ] output_name ] } [, ...] ]\n\nwhere conflict_target can be one of:\n\n    ( { index_column_name | ( index_expression ) } [ COLLATE collation ] [ opclass ] [, ...] ) [ WHERE index_predicate ]\n    ON CONSTRAINT constraint_name\n\nand conflict_action is one of:\n\n    DO NOTHING\n    DO UPDATE SET { column_name = { expression | DEFAULT } |\n                    ( column_name [, ...] ) = [ ROW ] ( { expression | DEFAULT } [, ...] ) |\n                    ( column_name [, ...] ) = ( sub-SELECT )\n                  } [, ...]\n              [ WHERE condition ]",
    "metadata": {
      "doc_name": "sql-insert",
      "section_title": "Synopsis",
      "url": "https://www.postgresql.org/docs/16/sql-insert.html"
    }
  },
  {
    "chunk_id": 2,
    "text": "INSERTinserts new rows into a table. One can insert one or more rows specified by value expressions, or zero or more rows resulting from a query.\nThe target column names can be listed in any order. If no list of column names is given at all, the default is all the columns of the table in their declared order; or the firstNcolumn names, if there are onlyNcolumns supplied by theVALUESclause orquery. The values supplied by theVALUESclause orqueryare associated with the explicit or implicit column list left-to-right.\nEach column not present in the explicit or implicit column list will be filled with a default value, either its declared default value or null if there is none.\nIf the expression for any column is not of the correct data type, automatic type conversion will be attempted.\nINSERTinto tables that lack unique indexes will not be blocked by concurrent activity. Tables with unique indexes might block if concurrent sessions perform actions that lock or modify rows matching the unique index values being inserted; the details are covered inSection 64.5.ON CONFLICTcan be used to specify an alternative action to raising a unique constraint or exclusion constraint violation error. (SeeON CONFLICT Clausebelow.)\nThe optionalRETURNINGclause causesINSERTto compute and return value(s) based on each row actually inserted (or updated, if anON CONFLICT DO UPDATEclause was used). This is primarily useful for obtaining values that were supplied by defaults, such as a serial sequence number. However, any expression using the table's columns is allowed. The syntax of theRETURNINGlist is identical to that of the output list ofSELECT. Only rows that were successfully inserted or updated will be returned. For example, if a row was locked but not updated because anON CONFLICT DO UPDATE ... WHEREclauseconditionwas not satisfied, the row will not be returned.\nYou must haveINSERTprivilege on a table in order to insert into it. IfON CONFLICT DO UPDATEis present,UPDATEprivilege on the table is also required.\nIf a column list is specified, you only needINSERTprivilege on the listed columns. Similarly, whenON CONFLICT DO UPDATEis specified, you only needUPDATEprivilege on the column(s) that are listed to be updated. However,ON CONFLICT DO UPDATEalso requiresSELECTprivilege on any column whose values are read in theON CONFLICT DO UPDATEexpressions orcondition.\nUse of theRETURNINGclause requiresSELECTprivilege on all columns mentioned inRETURN",
    "metadata": {
      "doc_name": "sql-insert",
      "section_title": "Description",
      "url": "https://www.postgresql.org/docs/16/sql-insert.html"
    }
  },
  {
    "chunk_id": 3,
    "text": "the table is also required.\nIf a column list is specified, you only needINSERTprivilege on the listed columns. Similarly, whenON CONFLICT DO UPDATEis specified, you only needUPDATEprivilege on the column(s) that are listed to be updated. However,ON CONFLICT DO UPDATEalso requiresSELECTprivilege on any column whose values are read in theON CONFLICT DO UPDATEexpressions orcondition.\nUse of theRETURNINGclause requiresSELECTprivilege on all columns mentioned inRETURNING. If you use thequeryclause to insert rows from a query, you of course need to haveSELECTprivilege on any table or column used in the query.",
    "metadata": {
      "doc_name": "sql-insert",
      "section_title": "Description",
      "url": "https://www.postgresql.org/docs/16/sql-insert.html"
    }
  },
  {
    "chunk_id": 4,
    "text": "This section covers parameters that may be used when only inserting new rows. Parametersexclusivelyused with theON CONFLICTclause are described separately.\nTheWITHclause allows you to specify one or more subqueries that can be referenced by name in theINSERTquery. SeeSection 7.8andSELECTfor details.\nIt is possible for thequery(SELECTstatement) to also contain aWITHclause. In such a case both sets ofwith_querycan be referenced within thequery, but the second one takes precedence since it is more closely nested.\nThe name (optionally schema-qualified) of an existing table.\nA substitute name fortable_name. When an alias is provided, it completely hides the actual name of the table. This is particularly useful whenON CONFLICT DO UPDATEtargets a table namedexcluded, since that will otherwise be taken as the name of the special table representing the row proposed for insertion.\nThe name of a column in the table named bytable_name. The column name can be qualified with a subfield name or array subscript, if needed. (Inserting into only some fields of a composite column leaves the other fields null.) When referencing a column withON CONFLICT DO UPDATE, do not include the table's name in the specification of a target column. For example,INSERT INTO table_name ... ON CONFLICT DO UPDATE SET table_name.col = 1is invalid (this follows the general behavior forUPDATE).\nIf this clause is specified, then any values supplied for identity columns will override the default sequence-generated values.\nFor an identity column defined asGENERATED ALWAYS, it is an error to insert an explicit value (other thanDEFAULT) without specifying eitherOVERRIDING SYSTEM VALUEorOVERRIDING USER VALUE. (For an identity column defined asGENERATED BY DEFAULT,OVERRIDING SYSTEM VALUEis the normal behavior and specifying it does nothing, butPostgreSQLallows it as an extension.)\nIf this clause is specified, then any values supplied for identity columns are ignored and the default sequence-generated values are applied.\nThis clause is useful for example when copying values between tables. WritingINSERT INTO tbl2 OVERRIDING USER VALUE SELECT * FROM tbl1will copy fromtbl1all columns that are not identity columns intbl2while values for the identity columns intbl2will be generated by the sequences associated withtbl2.\nAll columns will be filled with their default values, as ifDEFAULTwere explicitly specified for each column. (AnOVERRIDINGclause is",
    "metadata": {
      "doc_name": "sql-insert",
      "section_title": "Inserting",
      "url": "https://www.postgresql.org/docs/16/sql-insert.html"
    }
  },
  {
    "chunk_id": 5,
    "text": "and the default sequence-generated values are applied.\nThis clause is useful for example when copying values between tables. WritingINSERT INTO tbl2 OVERRIDING USER VALUE SELECT * FROM tbl1will copy fromtbl1all columns that are not identity columns intbl2while values for the identity columns intbl2will be generated by the sequences associated withtbl2.\nAll columns will be filled with their default values, as ifDEFAULTwere explicitly specified for each column. (AnOVERRIDINGclause is not permitted in this form.)\nAn expression or value to assign to the corresponding column.\nThe corresponding column will be filled with its default value. An identity column will be filled with a new value generated by the associated sequence. For a generated column, specifying this is permitted but merely specifies the normal behavior of computing the column from its generation expression.\nA query (SELECTstatement) that supplies the rows to be inserted. Refer to theSELECTstatement for a description of the syntax.\nAn expression to be computed and returned by theINSERTcommand after each row is inserted or updated. The expression can use any column names of the table named bytable_name. Write*to return all columns of the inserted or updated row(s).\nA name to use for a returned column.",
    "metadata": {
      "doc_name": "sql-insert",
      "section_title": "Inserting",
      "url": "https://www.postgresql.org/docs/16/sql-insert.html"
    }
  },
  {
    "chunk_id": 6,
    "text": "The optionalON CONFLICTclause specifies an alternative action to raising a unique violation or exclusion constraint violation error. For each individual row proposed for insertion, either the insertion proceeds, or, if anarbiterconstraint or index specified byconflict_targetis violated, the alternativeconflict_actionis taken.ON CONFLICT DO NOTHINGsimply avoids inserting a row as its alternative action.ON CONFLICT DO UPDATEupdates the existing row that conflicts with the row proposed for insertion as its alternative action.\nconflict_targetcan performunique index inference. When performing inference, it consists of one or moreindex_column_namecolumns and/orindex_expressionexpressions, and an optionalindex_predicate. Alltable_nameunique indexes that, without regard to order, contain exactly theconflict_target-specified columns/expressions are inferred (chosen) as arbiter indexes. If anindex_predicateis specified, it must, as a further requirement for inference, satisfy arbiter indexes. Note that this means a non-partial unique index (a unique index without a predicate) will be inferred (and thus used byON CONFLICT) if such an index satisfying every other criteria is available. If an attempt at inference is unsuccessful, an error is raised.\nON CONFLICT DO UPDATEguarantees an atomicINSERTorUPDATEoutcome; provided there is no independent error, one of those two outcomes is guaranteed, even under high concurrency. This is also known asUPSERT—“UPDATE or INSERT”.\nSpecifies which conflictsON CONFLICTtakes the alternative action on by choosingarbiter indexes. Either performsunique index inference, or names a constraint explicitly. ForON CONFLICT DO NOTHING, it is optional to specify aconflict_target; when omitted, conflicts with all usable constraints (and unique indexes) are handled. ForON CONFLICT DO UPDATE, aconflict_targetmustbe provided.\nconflict_actionspecifies an alternativeON CONFLICTaction. It can be eitherDO NOTHING, or aDO UPDATEclause specifying the exact details of theUPDATEaction to be performed in case of a conflict. TheSETandWHEREclauses inON CONFLICT DO UPDATEhave access to the existing row using the table's name (or an alias), and to the row proposed for insertion using the specialexcludedtable.SELECTprivilege is required on any column in the target table where correspondingexcludedcolumns are read.\nNote that the effects of all per-rowBEFORE INSERTtriggers are reflected inexcludedvalues, since those effects may have contributed to the row being",
    "metadata": {
      "doc_name": "sql-insert",
      "section_title": "ON CONFLICTClause",
      "url": "https://www.postgresql.org/docs/16/sql-insert.html"
    }
  },
  {
    "chunk_id": 7,
    "text": "to be performed in case of a conflict. TheSETandWHEREclauses inON CONFLICT DO UPDATEhave access to the existing row using the table's name (or an alias), and to the row proposed for insertion using the specialexcludedtable.SELECTprivilege is required on any column in the target table where correspondingexcludedcolumns are read.\nNote that the effects of all per-rowBEFORE INSERTtriggers are reflected inexcludedvalues, since those effects may have contributed to the row being excluded from insertion.\nThe name of atable_namecolumn. Used to infer arbiter indexes. FollowsCREATE INDEXformat.SELECTprivilege onindex_column_nameis required.\nSimilar toindex_column_name, but used to infer expressions ontable_namecolumns appearing within index definitions (not simple columns). FollowsCREATE INDEXformat.SELECTprivilege on any column appearing withinindex_expressionis required.\nWhen specified, mandates that correspondingindex_column_nameorindex_expressionuse a particular collation in order to be matched during inference. Typically this is omitted, as collations usually do not affect whether or not a constraint violation occurs. FollowsCREATE INDEXformat.\nWhen specified, mandates that correspondingindex_column_nameorindex_expressionuse particular operator class in order to be matched during inference. Typically this is omitted, as theequalitysemantics are often equivalent across a type's operator classes anyway, or because it's sufficient to trust that the defined unique indexes have the pertinent definition of equality. FollowsCREATE INDEXformat.\nUsed to allow inference of partial unique indexes. Any indexes that satisfy the predicate (which need not actually be partial indexes) can be inferred. FollowsCREATE INDEXformat.SELECTprivilege on any column appearing withinindex_predicateis required.\nExplicitly specifies an arbiterconstraintby name, rather than inferring a constraint or index.\nAn expression that returns a value of typeboolean. Only rows for which this expression returnstruewill be updated, although all rows will be locked when theON CONFLICT DO UPDATEaction is taken. Note thatconditionis evaluated last, after a conflict has been identified as a candidate to update.\nNote that exclusion constraints are not supported as arbiters withON CONFLICT DO UPDATE. In all cases, onlyNOT DEFERRABLEconstraints and unique indexes are supported as arbiters.\nINSERTwith anON CONFLICT DO UPDATEclause is a“deterministic”statement. This means that the command will not be allowed to affect any single existing row more than once; a cardinality violation error will",
    "metadata": {
      "doc_name": "sql-insert",
      "section_title": "ON CONFLICTClause",
      "url": "https://www.postgresql.org/docs/16/sql-insert.html"
    }
  },
  {
    "chunk_id": 8,
    "text": "taken. Note thatconditionis evaluated last, after a conflict has been identified as a candidate to update.\nNote that exclusion constraints are not supported as arbiters withON CONFLICT DO UPDATE. In all cases, onlyNOT DEFERRABLEconstraints and unique indexes are supported as arbiters.\nINSERTwith anON CONFLICT DO UPDATEclause is a“deterministic”statement. This means that the command will not be allowed to affect any single existing row more than once; a cardinality violation error will be raised when this situation arises. Rows proposed for insertion should not duplicate each other in terms of attributes constrained by an arbiter index or constraint.\nNote that it is currently not supported for theON CONFLICT DO UPDATEclause of anINSERTapplied to a partitioned table to update the partition key of a conflicting row such that it requires the row be moved to a new partition.",
    "metadata": {
      "doc_name": "sql-insert",
      "section_title": "ON CONFLICTClause",
      "url": "https://www.postgresql.org/docs/16/sql-insert.html"
    }
  },
  {
    "chunk_id": 9,
    "text": "It is often preferable to use unique index inference rather than naming a constraint directly usingON CONFLICT ON CONSTRAINTconstraint_name. Inference will continue to work correctly when the underlying index is replaced by another more or less equivalent index in an overlapping way, for example when usingCREATE UNIQUE INDEX ... CONCURRENTLYbefore dropping the index being replaced.",
    "metadata": {
      "doc_name": "sql-insert",
      "section_title": "Tip",
      "url": "https://www.postgresql.org/docs/16/sql-insert.html"
    }
  },
  {
    "chunk_id": 10,
    "text": "WhileCREATE INDEX CONCURRENTLYorREINDEX CONCURRENTLYis running on a unique index,INSERT ... ON CONFLICTstatements on the same table may unexpectedly fail with a unique violation.",
    "metadata": {
      "doc_name": "sql-insert",
      "section_title": "Warning",
      "url": "https://www.postgresql.org/docs/16/sql-insert.html"
    }
  },
  {
    "chunk_id": 11,
    "text": "On successful completion, anINSERTcommand returns a command tag of the form\n\n\nCODE:\n\nINSERT oid count\n\nThecountis the number of rows inserted or updated.oidis always 0 (it used to be theOIDassigned to the inserted row ifcountwas exactly one and the target table was declaredWITH OIDSand 0 otherwise, but creating a tableWITH OIDSis not supported anymore).\nIf theINSERTcommand contains aRETURNINGclause, the result will be similar to that of aSELECTstatement containing the columns and values defined in theRETURNINGlist, computed over the row(s) inserted or updated by the command.",
    "metadata": {
      "doc_name": "sql-insert",
      "section_title": "Outputs",
      "url": "https://www.postgresql.org/docs/16/sql-insert.html"
    }
  },
  {
    "chunk_id": 12,
    "text": "If the specified table is a partitioned table, each row is routed to the appropriate partition and inserted into it. If the specified table is a partition, an error will occur if one of the input rows violates the partition constraint.\nYou may also wish to consider usingMERGE, since that allows mixingINSERT,UPDATE, andDELETEwithin a single statement. SeeMERGE.",
    "metadata": {
      "doc_name": "sql-insert",
      "section_title": "Notes",
      "url": "https://www.postgresql.org/docs/16/sql-insert.html"
    }
  },
  {
    "chunk_id": 13,
    "text": "Insert a single row into tablefilms:\n\n\nCODE:\n\nINSERT INTO films VALUES\n    ('UA502', 'Bananas', 105, '1971-07-13', 'Comedy', '82 minutes');\n\nIn this example, thelencolumn is omitted and therefore it will have the default value:\n\n\nCODE:\n\nINSERT INTO films (code, title, did, date_prod, kind)\n    VALUES ('T_601', 'Yojimbo', 106, '1961-06-16', 'Drama');\n\nThis example uses theDEFAULTclause for the date columns rather than specifying a value:\n\n\nCODE:\n\nINSERT INTO films VALUES\n    ('UA502', 'Bananas', 105, DEFAULT, 'Comedy', '82 minutes');\nINSERT INTO films (code, title, did, date_prod, kind)\n    VALUES ('T_601', 'Yojimbo', 106, DEFAULT, 'Drama');\n\nTo insert a row consisting entirely of default values:\n\n\nCODE:\n\nINSERT INTO films DEFAULT VALUES;\n\nTo insert multiple rows using the multirowVALUESsyntax:\n\n\nCODE:\n\nINSERT INTO films (code, title, did, date_prod, kind) VALUES\n    ('B6717', 'Tampopo', 110, '1985-02-10', 'Comedy'),\n    ('HG120', 'The Dinner Game', 140, DEFAULT, 'Comedy');\n\nThis example inserts some rows into tablefilmsfrom a tabletmp_filmswith the same column layout asfilms:\n\n\nCODE:\n\nINSERT INTO films SELECT * FROM tmp_films WHERE date_prod < '2004-05-07';\n\nThis example inserts into array columns:\n\n\nCODE:\n\n-- Create an empty 3x3 gameboard for noughts-and-crosses\nINSERT INTO tictactoe (game, board[1:3][1:3])\n    VALUES (1, '{{\" \",\" \",\" \"},{\" \",\" \",\" \"},{\" \",\" \",\" \"}}');\n-- The subscripts in the above example aren't really needed\nINSERT INTO tictactoe (game, board)\n    VALUES (2, '{{X,\" \",\" \"},{\" \",O,\" \"},{\" \",X,\" \"}}');\n\nInsert a single row into tabledistributors, returning the sequence number generated by theDEFAULTclause:\n\n\nCODE:\n\nINSERT INTO distributors (did, dname) VALUES (DEFAULT, 'XYZ Widgets')\n   RETURNING did;\n\nIncrement the sales count of the salesperson who manages the account for Acme Corporation,",
    "metadata": {
      "doc_name": "sql-insert",
      "section_title": "Examples",
      "url": "https://www.postgresql.org/docs/16/sql-insert.html"
    }
  },
  {
    "chunk_id": 14,
    "text": "example aren't really needed\nINSERT INTO tictactoe (game, board)\n    VALUES (2, '{{X,\" \",\" \"},{\" \",O,\" \"},{\" \",X,\" \"}}');\n\nInsert a single row into tabledistributors, returning the sequence number generated by theDEFAULTclause:\n\n\nCODE:\n\nINSERT INTO distributors (did, dname) VALUES (DEFAULT, 'XYZ Widgets')\n   RETURNING did;\n\nIncrement the sales count of the salesperson who manages the account for Acme Corporation, and record the whole updated row along with current time in a log table:\n\n\nCODE:\n\nWITH upd AS (\n  UPDATE employees SET sales_count = sales_count + 1 WHERE id =\n    (SELECT sales_person FROM accounts WHERE name = 'Acme Corporation')\n    RETURNING *\n)\nINSERT INTO employees_log SELECT *, current_timestamp FROM upd;\n\nInsert or update new distributors as appropriate. Assumes a unique index has been defined that constrains values appearing in thedidcolumn. Note that the specialexcludedtable is used to reference values originally proposed for insertion:\n\n\nCODE:\n\nINSERT INTO distributors (did, dname)\n    VALUES (5, 'Gizmo Transglobal'), (6, 'Associated Computing, Inc')\n    ON CONFLICT (did) DO UPDATE SET dname = EXCLUDED.dname;\n\nInsert a distributor, or do nothing for rows proposed for insertion when an existing, excluded row (a row with a matching constrained column or columns after before row insert triggers fire) exists. Example assumes a unique index has been defined that constrains values appearing in thedidcolumn:\n\n\nCODE:\n\nINSERT INTO distributors (did, dname) VALUES (7, 'Redline GmbH')\n    ON CONFLICT (did) DO NOTHING;\n\nInsert or update new distributors as appropriate. Example assumes a unique index has been defined that constrains values appearing in thedidcolumn.WHEREclause is used to limit the rows actually updated (any existing row not updated will still be locked, though):\n\n\nCODE:\n\n-- Don't update existing distributors based in a certain ZIP code\nINSERT INTO distributors AS d (did, dname) VALUES (8, 'Anvil Distribution')\n    ON CONFLICT (did) DO UPDATE\n    SET dname = EXCLUDED.dname || ' (formerly ' || d.dname || ')'\n    WHERE d.zipcode <> '21201';\n\n-- Name a constraint directly in the statement (uses associated\n-- index to arbitrate taking the DO NOTHING action)\nINSERT INTO distributors (did,",
    "metadata": {
      "doc_name": "sql-insert",
      "section_title": "Examples",
      "url": "https://www.postgresql.org/docs/16/sql-insert.html"
    }
  },
  {
    "chunk_id": 15,
    "text": "update existing distributors based in a certain ZIP code\nINSERT INTO distributors AS d (did, dname) VALUES (8, 'Anvil Distribution')\n    ON CONFLICT (did) DO UPDATE\n    SET dname = EXCLUDED.dname || ' (formerly ' || d.dname || ')'\n    WHERE d.zipcode <> '21201';\n\n-- Name a constraint directly in the statement (uses associated\n-- index to arbitrate taking the DO NOTHING action)\nINSERT INTO distributors (did, dname) VALUES (9, 'Antwerp Design')\n    ON CONFLICT ON CONSTRAINT distributors_pkey DO NOTHING;\n\nInsert new distributor if possible; otherwiseDO NOTHING. Example assumes a unique index has been defined that constrains values appearing in thedidcolumn on a subset of rows where theis_activeBoolean column evaluates totrue:\n\n\nCODE:\n\n-- This statement could infer a partial unique index on \"did\"\n-- with a predicate of \"WHERE is_active\", but it could also\n-- just use a regular unique constraint on \"did\"\nINSERT INTO distributors (did, dname) VALUES (10, 'Conrad International')\n    ON CONFLICT (did) WHERE is_active DO NOTHING;",
    "metadata": {
      "doc_name": "sql-insert",
      "section_title": "Examples",
      "url": "https://www.postgresql.org/docs/16/sql-insert.html"
    }
  },
  {
    "chunk_id": 16,
    "text": "INSERTconforms to the SQL standard, except that theRETURNINGclause is aPostgreSQLextension, as is the ability to useWITHwithINSERT, and the ability to specify an alternative action withON CONFLICT. Also, the case in which a column name list is omitted, but not all the columns are filled from theVALUESclause orquery, is disallowed by the standard. If you prefer a more SQL standard conforming statement thanON CONFLICT, seeMERGE.\nThe SQL standard specifies thatOVERRIDING SYSTEM VALUEcan only be specified if an identity column that is generated always exists. PostgreSQL allows the clause in any case and ignores it if it is not applicable.\nPossible limitations of thequeryclause are documented underSELECT.",
    "metadata": {
      "doc_name": "sql-insert",
      "section_title": "Compatibility",
      "url": "https://www.postgresql.org/docs/16/sql-insert.html"
    }
  },
  {
    "chunk_id": 0,
    "text": "MERGE — conditionally insert, update, or delete rows of a table",
    "metadata": {
      "doc_name": "sql-merge",
      "section_title": "MERGE",
      "url": "https://www.postgresql.org/docs/16/sql-merge.html"
    }
  },
  {
    "chunk_id": 1,
    "text": "CODE:\n\n[ WITH with_query [, ...] ]\nMERGE INTO [ ONLY ] target_table_name [ * ] [ [ AS ] target_alias ]\n    USING data_source ON join_condition\n    when_clause [...]\n\nwhere data_source is:\n\n    { [ ONLY ] source_table_name [ * ] | ( source_query ) } [ [ AS ] source_alias ]\n\nand when_clause is:\n\n    { WHEN MATCHED [ AND condition ] THEN { merge_update | merge_delete | DO NOTHING } |\n      WHEN NOT MATCHED [ AND condition ] THEN { merge_insert | DO NOTHING } }\n\nand merge_insert is:\n\n    INSERT [( column_name [, ...] )]\n        [ OVERRIDING { SYSTEM | USER } VALUE ]\n        { VALUES ( { expression | DEFAULT } [, ...] ) | DEFAULT VALUES }\n\nand merge_update is:\n\n    UPDATE SET { column_name = { expression | DEFAULT } |\n                 ( column_name [, ...] ) = [ ROW ] ( { expression | DEFAULT } [, ...] ) |\n                 ( column_name [, ...] ) = ( sub-SELECT )\n               } [, ...]\n\nand merge_delete is:\n\n    DELETE",
    "metadata": {
      "doc_name": "sql-merge",
      "section_title": "Synopsis",
      "url": "https://www.postgresql.org/docs/16/sql-merge.html"
    }
  },
  {
    "chunk_id": 2,
    "text": "MERGEperforms actions that modify rows in the target table identified astarget_table_name, using thedata_source.MERGEprovides a singleSQLstatement that can conditionallyINSERT,UPDATEorDELETErows, a task that would otherwise require multiple procedural language statements.\nFirst, theMERGEcommand performs a join fromdata_sourceto the target table producing zero or more candidate change rows. For each candidate change row, the status ofMATCHEDorNOT MATCHEDis set just once, after whichWHENclauses are evaluated in the order specified. For each candidate change row, the first clause to evaluate as true is executed. No more than oneWHENclause is executed for any candidate change row.\nMERGEactions have the same effect as regularUPDATE,INSERT, orDELETEcommands of the same names. The syntax of those commands is different, notably that there is noWHEREclause and no table name is specified. All actions refer to the target table, though modifications to other tables may be made using triggers.\nWhenDO NOTHINGis specified, the source row is skipped. Since actions are evaluated in their specified order,DO NOTHINGcan be handy to skip non-interesting source rows before more fine-grained handling.\nThere is no separateMERGEprivilege. If you specify an update action, you must have theUPDATEprivilege on the column(s) of the target table that are referred to in theSETclause. If you specify an insert action, you must have theINSERTprivilege on the target table. If you specify a delete action, you must have theDELETEprivilege on the target table. If you specify aDO NOTHINGaction, you must have theSELECTprivilege on at least one column of the target table. You will also needSELECTprivilege on any column(s) of thedata_sourceand of the target table referred to in anycondition(includingjoin_condition) orexpression. Privileges are tested once at statement start and are checked whether or not particularWHENclauses are executed.\nMERGEis not supported if the target table is a materialized view, foreign table, or if it has any rules defined on it.",
    "metadata": {
      "doc_name": "sql-merge",
      "section_title": "Description",
      "url": "https://www.postgresql.org/docs/16/sql-merge.html"
    }
  },
  {
    "chunk_id": 3,
    "text": "TheWITHclause allows you to specify one or more subqueries that can be referenced by name in theMERGEquery. SeeSection 7.8andSELECTfor details. Note thatWITH RECURSIVEis not supported byMERGE.\nThe name (optionally schema-qualified) of the target table to merge into. IfONLYis specified before the table name, matching rows are updated or deleted in the named table only. IfONLYis not specified, matching rows are also updated or deleted in any tables inheriting from the named table. Optionally,*can be specified after the table name to explicitly indicate that descendant tables are included. TheONLYkeyword and*option do not affect insert actions, which always insert into the named table only.\nA substitute name for the target table. When an alias is provided, it completely hides the actual name of the table. For example, givenMERGE INTO foo AS f, the remainder of theMERGEstatement must refer to this table asfnotfoo.\nThe name (optionally schema-qualified) of the source table, view, or transition table. IfONLYis specified before the table name, matching rows are included from the named table only. IfONLYis not specified, matching rows are also included from any tables inheriting from the named table. Optionally,*can be specified after the table name to explicitly indicate that descendant tables are included.\nA query (SELECTstatement orVALUESstatement) that supplies the rows to be merged into the target table. Refer to theSELECTstatement orVALUESstatement for a description of the syntax.\nA substitute name for the data source. When an alias is provided, it completely hides the actual name of the table or the fact that a query was issued.\njoin_conditionis an expression resulting in a value of typeboolean(similar to aWHEREclause) that specifies which rows in thedata_sourcematch rows in the target table.",
    "metadata": {
      "doc_name": "sql-merge",
      "section_title": "Parameters",
      "url": "https://www.postgresql.org/docs/16/sql-merge.html"
    }
  },
  {
    "chunk_id": 4,
    "text": "Only columns from the target table that attempt to matchdata_sourcerows should appear injoin_condition.join_conditionsubexpressions that only reference the target table's columns can affect which action is taken, often in surprising ways.\nAt least oneWHENclause is required.\nIf theWHENclause specifiesWHEN MATCHEDand the candidate change row matches a row in the target table, theWHENclause is executed if theconditionis absent or it evaluates totrue.\nConversely, if theWHENclause specifiesWHEN NOT MATCHEDand the candidate change row does not match a row in the target table, theWHENclause is executed if theconditionis absent or it evaluates totrue.\nAn expression that returns a value of typeboolean. If this expression for aWHENclause returnstrue, then the action for that clause is executed for that row.\nA condition on aWHEN MATCHEDclause can refer to columns in both the source and the target relations. A condition on aWHEN NOT MATCHEDclause can only refer to columns from the source relation, since by definition there is no matching target row. Only the system attributes from the target table are accessible.\nThe specification of anINSERTaction that inserts one row into the target table. The target column names can be listed in any order. If no list of column names is given at all, the default is all the columns of the table in their declared order.\nEach column not present in the explicit or implicit column list will be filled with a default value, either its declared default value or null if there is none.\nIf the target table is a partitioned table, each row is routed to the appropriate partition and inserted into it. If the target table is a partition, an error will occur if any input row violates the partition constraint.\nColumn names may not be specified more than once.INSERTactions cannot contain sub-selects.\nOnly oneVALUESclause can be specified. TheVALUESclause can only refer to columns from the source relation, since by definition there is no matching target row.\nThe specification of anUPDATEaction that updates the current row of the target table. Column names may not be specified more than once.\nNeither a table name nor aWHEREclause are allowed.\nSpecifies aDELETEaction that deletes the current row of the target table. Do not include the table name or any other clauses, as you would normally do with aDELETEcommand.\nThe name of a column in the target table. The column name can be",
    "metadata": {
      "doc_name": "sql-merge",
      "section_title": "Warning",
      "url": "https://www.postgresql.org/docs/16/sql-merge.html"
    }
  },
  {
    "chunk_id": 5,
    "text": "source relation, since by definition there is no matching target row.\nThe specification of anUPDATEaction that updates the current row of the target table. Column names may not be specified more than once.\nNeither a table name nor aWHEREclause are allowed.\nSpecifies aDELETEaction that deletes the current row of the target table. Do not include the table name or any other clauses, as you would normally do with aDELETEcommand.\nThe name of a column in the target table. The column name can be qualified with a subfield name or array subscript, if needed. (Inserting into only some fields of a composite column leaves the other fields null.) Do not include the table's name in the specification of a target column.\nWithout this clause, it is an error to specify an explicit value (other thanDEFAULT) for an identity column defined asGENERATED ALWAYS. This clause overrides that restriction.\nIf this clause is specified, then any values supplied for identity columns defined asGENERATED BY DEFAULTare ignored and the default sequence-generated values are applied.\nAll columns will be filled with their default values. (AnOVERRIDINGclause is not permitted in this form.)\nAn expression to assign to the column. If used in aWHEN MATCHEDclause, the expression can use values from the original row in the target table, and values from thedata_sourcerow. If used in aWHEN NOT MATCHEDclause, the expression can use values from thedata_sourcerow.\nSet the column to its default value (which will beNULLif no specific default expression has been assigned to it).\nASELECTsub-query that produces as many output columns as are listed in the parenthesized column list preceding it. The sub-query must yield no more than one row when executed. If it yields one row, its column values are assigned to the target columns; if it yields no rows, NULL values are assigned to the target columns. The sub-query can refer to values from the original row in the target table, and values from thedata_sourcerow.",
    "metadata": {
      "doc_name": "sql-merge",
      "section_title": "Warning",
      "url": "https://www.postgresql.org/docs/16/sql-merge.html"
    }
  },
  {
    "chunk_id": 6,
    "text": "On successful completion, aMERGEcommand returns a command tag of the form\n\n\nCODE:\n\nMERGE total_count\n\nThetotal_countis the total number of rows changed (whether inserted, updated, or deleted). Iftotal_countis 0, no rows were changed in any way.",
    "metadata": {
      "doc_name": "sql-merge",
      "section_title": "Outputs",
      "url": "https://www.postgresql.org/docs/16/sql-merge.html"
    }
  },
  {
    "chunk_id": 7,
    "text": "The following steps take place during the execution ofMERGE.\nPerform anyBEFORE STATEMENTtriggers for all actions specified, whether or not theirWHENclauses match.\nPerform a join from source to target table. The resulting query will be optimized normally and will produce a set of candidate change rows. For each candidate change row,\nEvaluate whether each row isMATCHEDorNOT MATCHED.\nTest eachWHENcondition in the order specified until one returns true.\nWhen a condition returns true, perform the following actions:\nPerform anyBEFORE ROWtriggers that fire for the action's event type.\nPerform the specified action, invoking any check constraints on the target table.\nPerform anyAFTER ROWtriggers that fire for the action's event type.\nPerform anyAFTER STATEMENTtriggers for actions specified, whether or not they actually occur. This is similar to the behavior of anUPDATEstatement that modifies no rows.\nIn summary, statement triggers for an event type (say,INSERT) will be fired whenever wespecifyan action of that kind. In contrast, row-level triggers will fire only for the specific event type beingexecuted. So aMERGEcommand might fire statement triggers for bothUPDATEandINSERT, even though onlyUPDATErow triggers were fired.\nYou should ensure that the join produces at most one candidate change row for each target row. In other words, a target row shouldn't join to more than one data source row. If it does, then only one of the candidate change rows will be used to modify the target row; later attempts to modify the row will cause an error. This can also occur if row triggers make changes to the target table and the rows so modified are then subsequently also modified byMERGE. If the repeated action is anINSERT, this will cause a uniqueness violation, while a repeatedUPDATEorDELETEwill cause a cardinality violation; the latter behavior is required by theSQLstandard. This differs from historicalPostgreSQLbehavior of joins inUPDATEandDELETEstatements where second and subsequent attempts to modify the same row are simply ignored.\nIf aWHENclause omits anANDsub-clause, it becomes the final reachable clause of that kind (MATCHEDorNOT MATCHED). If a laterWHENclause of that kind is specified it would be provably unreachable and an error is raised. If no final reachable clause is specified of either kind, it is possible that no action will be taken for a candidate change row.\nThe order in which rows are generated",
    "metadata": {
      "doc_name": "sql-merge",
      "section_title": "Notes",
      "url": "https://www.postgresql.org/docs/16/sql-merge.html"
    }
  },
  {
    "chunk_id": 8,
    "text": "where second and subsequent attempts to modify the same row are simply ignored.\nIf aWHENclause omits anANDsub-clause, it becomes the final reachable clause of that kind (MATCHEDorNOT MATCHED). If a laterWHENclause of that kind is specified it would be provably unreachable and an error is raised. If no final reachable clause is specified of either kind, it is possible that no action will be taken for a candidate change row.\nThe order in which rows are generated from the data source is indeterminate by default. Asource_querycan be used to specify a consistent ordering, if required, which might be needed to avoid deadlocks between concurrent transactions.\nThere is noRETURNINGclause withMERGE. Actions ofINSERT,UPDATEandDELETEcannot containRETURNINGorWITHclauses.\nWhenMERGEis run concurrently with other commands that modify the target table, the usual transaction isolation rules apply; seeSection 13.2for an explanation on the behavior at each isolation level. You may also wish to consider usingINSERT ... ON CONFLICTas an alternative statement which offers the ability to run anUPDATEif a concurrentINSERToccurs. There are a variety of differences and restrictions between the two statement types and they are not interchangeable.",
    "metadata": {
      "doc_name": "sql-merge",
      "section_title": "Notes",
      "url": "https://www.postgresql.org/docs/16/sql-merge.html"
    }
  },
  {
    "chunk_id": 9,
    "text": "Perform maintenance oncustomer_accountsbased upon newrecent_transactions.\n\n\nCODE:\n\nMERGE INTO customer_account ca\nUSING recent_transactions t\nON t.customer_id = ca.customer_id\nWHEN MATCHED THEN\n  UPDATE SET balance = balance + transaction_value\nWHEN NOT MATCHED THEN\n  INSERT (customer_id, balance)\n  VALUES (t.customer_id, t.transaction_value);\n\nNotice that this would be exactly equivalent to the following statement because theMATCHEDresult does not change during execution.\n\n\nCODE:\n\nMERGE INTO customer_account ca\nUSING (SELECT customer_id, transaction_value FROM recent_transactions) AS t\nON t.customer_id = ca.customer_id\nWHEN MATCHED THEN\n  UPDATE SET balance = balance + transaction_value\nWHEN NOT MATCHED THEN\n  INSERT (customer_id, balance)\n  VALUES (t.customer_id, t.transaction_value);\n\nAttempt to insert a new stock item along with the quantity of stock. If the item already exists, instead update the stock count of the existing item. Don't allow entries that have zero stock.\n\n\nCODE:\n\nMERGE INTO wines w\nUSING wine_stock_changes s\nON s.winename = w.winename\nWHEN NOT MATCHED AND s.stock_delta > 0 THEN\n  INSERT VALUES(s.winename, s.stock_delta)\nWHEN MATCHED AND w.stock + s.stock_delta > 0 THEN\n  UPDATE SET stock = w.stock + s.stock_delta\nWHEN MATCHED THEN\n  DELETE;\n\nThewine_stock_changestable might be, for example, a temporary table recently loaded into the database.",
    "metadata": {
      "doc_name": "sql-merge",
      "section_title": "Examples",
      "url": "https://www.postgresql.org/docs/16/sql-merge.html"
    }
  },
  {
    "chunk_id": 10,
    "text": "This command conforms to theSQLstandard.\nTheWITHclause andDO NOTHINGaction are extensions to theSQLstandard.",
    "metadata": {
      "doc_name": "sql-merge",
      "section_title": "Compatibility",
      "url": "https://www.postgresql.org/docs/16/sql-merge.html"
    }
  },
  {
    "chunk_id": 0,
    "text": "REFRESH MATERIALIZED VIEW — replace the contents of a materialized view",
    "metadata": {
      "doc_name": "sql-refreshmaterializedview",
      "section_title": "REFRESH MATERIALIZED VIEW",
      "url": "https://www.postgresql.org/docs/16/sql-refreshmaterializedview.html"
    }
  },
  {
    "chunk_id": 1,
    "text": "CODE:\n\nREFRESH MATERIALIZED VIEW [ CONCURRENTLY ] name\n    [ WITH [ NO ] DATA ]",
    "metadata": {
      "doc_name": "sql-refreshmaterializedview",
      "section_title": "Synopsis",
      "url": "https://www.postgresql.org/docs/16/sql-refreshmaterializedview.html"
    }
  },
  {
    "chunk_id": 2,
    "text": "REFRESH MATERIALIZED VIEWcompletely replaces the contents of a materialized view. To execute this command you must be the owner of the materialized view. The old contents are discarded. IfWITH DATAis specified (or defaults) the backing query is executed to provide the new data, and the materialized view is left in a scannable state. IfWITH NO DATAis specified no new data is generated and the materialized view is left in an unscannable state.\nCONCURRENTLYandWITH NO DATAmay not be specified together.",
    "metadata": {
      "doc_name": "sql-refreshmaterializedview",
      "section_title": "Description",
      "url": "https://www.postgresql.org/docs/16/sql-refreshmaterializedview.html"
    }
  },
  {
    "chunk_id": 3,
    "text": "Refresh the materialized view without locking out concurrent selects on the materialized view. Without this option a refresh which affects a lot of rows will tend to use fewer resources and complete more quickly, but could block other connections which are trying to read from the materialized view. This option may be faster in cases where a small number of rows are affected.\nThis option is only allowed if there is at least oneUNIQUEindex on the materialized view which uses only column names and includes all rows; that is, it must not be an expression index or include aWHEREclause.\nThis option may not be used when the materialized view is not already populated.\nEven with this option only oneREFRESHat a time may run against any one materialized view.\nThe name (optionally schema-qualified) of the materialized view to refresh.",
    "metadata": {
      "doc_name": "sql-refreshmaterializedview",
      "section_title": "Parameters",
      "url": "https://www.postgresql.org/docs/16/sql-refreshmaterializedview.html"
    }
  },
  {
    "chunk_id": 4,
    "text": "If there is anORDER BYclause in the materialized view's defining query, the original contents of the materialized view will be ordered that way; butREFRESH MATERIALIZED VIEWdoes not guarantee to preserve that ordering.",
    "metadata": {
      "doc_name": "sql-refreshmaterializedview",
      "section_title": "Notes",
      "url": "https://www.postgresql.org/docs/16/sql-refreshmaterializedview.html"
    }
  },
  {
    "chunk_id": 5,
    "text": "This command will replace the contents of the materialized view calledorder_summaryusing the query from the materialized view's definition, and leave it in a scannable state:\n\n\nCODE:\n\nREFRESH MATERIALIZED VIEW order_summary;\n\nThis command will free storage associated with the materialized viewannual_statistics_basisand leave it in an unscannable state:\n\n\nCODE:\n\nREFRESH MATERIALIZED VIEW annual_statistics_basis WITH NO DATA;",
    "metadata": {
      "doc_name": "sql-refreshmaterializedview",
      "section_title": "Examples",
      "url": "https://www.postgresql.org/docs/16/sql-refreshmaterializedview.html"
    }
  },
  {
    "chunk_id": 6,
    "text": "REFRESH MATERIALIZED VIEWis aPostgreSQLextension.",
    "metadata": {
      "doc_name": "sql-refreshmaterializedview",
      "section_title": "Compatibility",
      "url": "https://www.postgresql.org/docs/16/sql-refreshmaterializedview.html"
    }
  },
  {
    "chunk_id": 0,
    "text": "REVOKE — remove access privileges",
    "metadata": {
      "doc_name": "sql-revoke",
      "section_title": "REVOKE",
      "url": "https://www.postgresql.org/docs/16/sql-revoke.html"
    }
  },
  {
    "chunk_id": 1,
    "text": "CODE:\n\nREVOKE [ GRANT OPTION FOR ]\n    { { SELECT | INSERT | UPDATE | DELETE | TRUNCATE | REFERENCES | TRIGGER }\n    [, ...] | ALL [ PRIVILEGES ] }\n    ON { [ TABLE ] table_name [, ...]\n         | ALL TABLES IN SCHEMA schema_name [, ...] }\n    FROM role_specification [, ...]\n    [ GRANTED BY role_specification ]\n    [ CASCADE | RESTRICT ]\n\nREVOKE [ GRANT OPTION FOR ]\n    { { SELECT | INSERT | UPDATE | REFERENCES } ( column_name [, ...] )\n    [, ...] | ALL [ PRIVILEGES ] ( column_name [, ...] ) }\n    ON [ TABLE ] table_name [, ...]\n    FROM role_specification [, ...]\n    [ GRANTED BY role_specification ]\n    [ CASCADE | RESTRICT ]\n\nREVOKE [ GRANT OPTION FOR ]\n    { { USAGE | SELECT | UPDATE }\n    [, ...] | ALL [ PRIVILEGES ] }\n    ON { SEQUENCE sequence_name [, ...]\n         | ALL SEQUENCES IN SCHEMA schema_name [, ...] }\n    FROM role_specification [, ...]\n    [ GRANTED BY role_specification ]\n    [ CASCADE | RESTRICT ]\n\nREVOKE [ GRANT OPTION FOR ]\n    { { CREATE | CONNECT | TEMPORARY | TEMP } [, ...] | ALL [ PRIVILEGES ] }\n    ON DATABASE database_name [, ...]\n    FROM role_specification [, ...]\n    [ GRANTED BY role_specification ]\n    [ CASCADE | RESTRICT ]\n\nREVOKE [ GRANT OPTION FOR ]\n    { USAGE | ALL [ PRIVILEGES ] }\n    ON DOMAIN domain_name [, ...]\n    FROM role_specification [, ...]\n    [ GRANTED BY role_specification ]\n    [ CASCADE | RESTRICT ]\n\nREVOKE [ GRANT OPTION FOR ]\n    { USAGE | ALL [ PRIVILEGES ] }\n    ON FOREIGN DATA WRAPPER fdw_name [, ...]\n    FROM role_specification [, ...]\n    [ GRANTED BY role_specification ]\n    [ CASCADE | RESTRICT ]\n\nREVOKE [ GRANT OPTION FOR ]\n    { USAGE | ALL [ PRIVILEGES ] }\n    ON FOREIGN SERVER server_name [, ...]\n    FROM role_specification [, ...]\n    [ GRANTED BY role_specification ]\n    [ CASCADE | RESTRICT ]\n\nREVOKE [ GRANT OPTION FOR ]\n    { EXECUTE | ALL [ PRIVILEGES ] }\n    ON { { FUNCTION | PROCEDURE | ROUT",
    "metadata": {
      "doc_name": "sql-revoke",
      "section_title": "Synopsis",
      "url": "https://www.postgresql.org/docs/16/sql-revoke.html"
    }
  },
  {
    "chunk_id": 2,
    "text": "...]\n    [ GRANTED BY role_specification ]\n    [ CASCADE | RESTRICT ]\n\nREVOKE [ GRANT OPTION FOR ]\n    { USAGE | ALL [ PRIVILEGES ] }\n    ON FOREIGN SERVER server_name [, ...]\n    FROM role_specification [, ...]\n    [ GRANTED BY role_specification ]\n    [ CASCADE | RESTRICT ]\n\nREVOKE [ GRANT OPTION FOR ]\n    { EXECUTE | ALL [ PRIVILEGES ] }\n    ON { { FUNCTION | PROCEDURE | ROUTINE } function_name [ ( [ [ argmode ] [ arg_name ] arg_type [, ...] ] ) ] [, ...]\n         | ALL { FUNCTIONS | PROCEDURES | ROUTINES } IN SCHEMA schema_name [, ...] }\n    FROM role_specification [, ...]\n    [ GRANTED BY role_specification ]\n    [ CASCADE | RESTRICT ]\n\nREVOKE [ GRANT OPTION FOR ]\n    { USAGE | ALL [ PRIVILEGES ] }\n    ON LANGUAGE lang_name [, ...]\n    FROM role_specification [, ...]\n    [ GRANTED BY role_specification ]\n    [ CASCADE | RESTRICT ]\n\nREVOKE [ GRANT OPTION FOR ]\n    { { SELECT | UPDATE } [, ...] | ALL [ PRIVILEGES ] }\n    ON LARGE OBJECT loid [, ...]\n    FROM role_specification [, ...]\n    [ GRANTED BY role_specification ]\n    [ CASCADE | RESTRICT ]\n\nREVOKE [ GRANT OPTION FOR ]\n    { { SET | ALTER SYSTEM } [, ...] | ALL [ PRIVILEGES ] }\n    ON PARAMETER configuration_parameter [, ...]\n    FROM role_specification [, ...]\n    [ GRANTED BY role_specification ]\n    [ CASCADE | RESTRICT ]\n\nREVOKE [ GRANT OPTION FOR ]\n    { { CREATE | USAGE } [, ...] | ALL [ PRIVILEGES ] }\n    ON SCHEMA schema_name [, ...]\n    FROM role_specification [, ...]\n    [ GRANTED BY role_specification ]\n    [ CASCADE | RESTRICT ]\n\nREVOKE [ GRANT OPTION FOR ]\n    { CREATE | ALL [ PRIVILEGES ] }\n    ON TABLESPACE tablespace_name [, ...]\n    FROM role_specification [, ...]\n    [ GRANTED BY role_specification ]\n    [ CASCADE | RESTRICT ]\n\nREVOKE [ GRANT OPTION FOR ]\n    { USAGE | ALL [ PRIVILEGES ] }\n    ON TYPE type_name [, ...]\n    FROM role_specification [, ...]\n    [ GRANTED BY role_specification ]\n    [",
    "metadata": {
      "doc_name": "sql-revoke",
      "section_title": "Synopsis",
      "url": "https://www.postgresql.org/docs/16/sql-revoke.html"
    }
  },
  {
    "chunk_id": 3,
    "text": "]\n\nREVOKE [ GRANT OPTION FOR ]\n    { CREATE | ALL [ PRIVILEGES ] }\n    ON TABLESPACE tablespace_name [, ...]\n    FROM role_specification [, ...]\n    [ GRANTED BY role_specification ]\n    [ CASCADE | RESTRICT ]\n\nREVOKE [ GRANT OPTION FOR ]\n    { USAGE | ALL [ PRIVILEGES ] }\n    ON TYPE type_name [, ...]\n    FROM role_specification [, ...]\n    [ GRANTED BY role_specification ]\n    [ CASCADE | RESTRICT ]\n\nREVOKE [ { ADMIN | INHERIT | SET } OPTION FOR ]\n    role_name [, ...] FROM role_specification [, ...]\n    [ GRANTED BY role_specification ]\n    [ CASCADE | RESTRICT ]\n\nwhere role_specification can be:\n\n    [ GROUP ] role_name\n  | PUBLIC\n  | CURRENT_ROLE\n  | CURRENT_USER\n  | SESSION_USER",
    "metadata": {
      "doc_name": "sql-revoke",
      "section_title": "Synopsis",
      "url": "https://www.postgresql.org/docs/16/sql-revoke.html"
    }
  },
  {
    "chunk_id": 4,
    "text": "TheREVOKEcommand revokes previously granted privileges from one or more roles. The key wordPUBLICrefers to the implicitly defined group of all roles.\nSee the description of theGRANTcommand for the meaning of the privilege types.\nNote that any particular role will have the sum of privileges granted directly to it, privileges granted to any role it is presently a member of, and privileges granted toPUBLIC. Thus, for example, revokingSELECTprivilege fromPUBLICdoes not necessarily mean that all roles have lostSELECTprivilege on the object: those who have it granted directly or via another role will still have it. Similarly, revokingSELECTfrom a user might not prevent that user from usingSELECTifPUBLICor another membership role still hasSELECTrights.\nIfGRANT OPTION FORis specified, only the grant option for the privilege is revoked, not the privilege itself. Otherwise, both the privilege and the grant option are revoked.\nIf a user holds a privilege with grant option and has granted it to other users then the privileges held by those other users are called dependent privileges. If the privilege or the grant option held by the first user is being revoked and dependent privileges exist, those dependent privileges are also revoked ifCASCADEis specified; if it is not, the revoke action will fail. This recursive revocation only affects privileges that were granted through a chain of users that is traceable to the user that is the subject of thisREVOKEcommand. Thus, the affected users might effectively keep the privilege if it was also granted through other users.\nWhen revoking privileges on a table, the corresponding column privileges (if any) are automatically revoked on each column of the table, as well. On the other hand, if a role has been granted privileges on a table, then revoking the same privileges from individual columns will have no effect.\nWhen revoking membership in a role,GRANT OPTIONis instead calledADMIN OPTION, but the behavior is similar. Note that, in releases prior toPostgreSQL16, dependent privileges were not tracked for grants of role membership, and thusCASCADEhad no effect for role membership. This is no longer the case. Note also that this form of the command does not allow the noise wordGROUPinrole_specification.\nJust asADMIN OPTIONcan be removed from an existing role grant, it is also possible to revokeINHERIT OPTIONorSET OPTION. This is equivalent to setting the value of the corresponding option toFALSE.",
    "metadata": {
      "doc_name": "sql-revoke",
      "section_title": "Description",
      "url": "https://www.postgresql.org/docs/16/sql-revoke.html"
    }
  },
  {
    "chunk_id": 5,
    "text": "A user can only revoke privileges that were granted directly by that user. If, for example, user A has granted a privilege with grant option to user B, and user B has in turn granted it to user C, then user A cannot revoke the privilege directly from C. Instead, user A could revoke the grant option from user B and use theCASCADEoption so that the privilege is in turn revoked from user C. For another example, if both A and B have granted the same privilege to C, A can revoke their own grant but not B's grant, so C will still effectively have the privilege.\nWhen a non-owner of an object attempts toREVOKEprivileges on the object, the command will fail outright if the user has no privileges whatsoever on the object. As long as some privilege is available, the command will proceed, but it will revoke only those privileges for which the user has grant options. TheREVOKE ALL PRIVILEGESforms will issue a warning message if no grant options are held, while the other forms will issue a warning if grant options for any of the privileges specifically named in the command are not held. (In principle these statements apply to the object owner as well, but since the owner is always treated as holding all grant options, the cases can never occur.)\nIf a superuser chooses to issue aGRANTorREVOKEcommand, the command is performed as though it were issued by the owner of the affected object. (Since roles do not have owners, in the case of aGRANTof role membership, the command is performed as though it were issued by the bootstrap superuser.) Since all privileges ultimately come from the object owner (possibly indirectly via chains of grant options), it is possible for a superuser to revoke all privileges, but this might require use ofCASCADEas stated above.\nREVOKEcan also be done by a role that is not the owner of the affected object, but is a member of the role that owns the object, or is a member of a role that holds privilegesWITH GRANT OPTIONon the object. In this case the command is performed as though it were issued by the containing role that actually owns the object or holds the privilegesWITH GRANT OPTION. For example, if tablet1is owned by roleg1, of which roleu1is a member, thenu1can revoke privileges ont1that are recorded as being granted byg1. This would include grants made byu1as well as by other members",
    "metadata": {
      "doc_name": "sql-revoke",
      "section_title": "Notes",
      "url": "https://www.postgresql.org/docs/16/sql-revoke.html"
    }
  },
  {
    "chunk_id": 6,
    "text": "a member of a role that holds privilegesWITH GRANT OPTIONon the object. In this case the command is performed as though it were issued by the containing role that actually owns the object or holds the privilegesWITH GRANT OPTION. For example, if tablet1is owned by roleg1, of which roleu1is a member, thenu1can revoke privileges ont1that are recorded as being granted byg1. This would include grants made byu1as well as by other members of roleg1.\nIf the role executingREVOKEholds privileges indirectly via more than one role membership path, it is unspecified which containing role will be used to perform the command. In such cases it is best practice to useSET ROLEto become the specific role you want to do theREVOKEas. Failure to do so might lead to revoking privileges other than the ones you intended, or not revoking anything at all.\nSeeSection 5.7for more information about specific privilege types, as well as how to inspect objects' privileges.",
    "metadata": {
      "doc_name": "sql-revoke",
      "section_title": "Notes",
      "url": "https://www.postgresql.org/docs/16/sql-revoke.html"
    }
  },
  {
    "chunk_id": 7,
    "text": "Revoke insert privilege for the public on tablefilms:\n\n\nCODE:\n\nREVOKE INSERT ON films FROM PUBLIC;\n\nRevoke all privileges from usermanuelon viewkinds:\n\n\nCODE:\n\nREVOKE ALL PRIVILEGES ON kinds FROM manuel;\n\nNote that this actually means“revoke all privileges that I granted”.\nRevoke membership in roleadminsfrom userjoe:\n\n\nCODE:\n\nREVOKE admins FROM joe;",
    "metadata": {
      "doc_name": "sql-revoke",
      "section_title": "Examples",
      "url": "https://www.postgresql.org/docs/16/sql-revoke.html"
    }
  },
  {
    "chunk_id": 8,
    "text": "The compatibility notes of theGRANTcommand apply analogously toREVOKE. The keywordRESTRICTorCASCADEis required according to the standard, butPostgreSQLassumesRESTRICTby default.",
    "metadata": {
      "doc_name": "sql-revoke",
      "section_title": "Compatibility",
      "url": "https://www.postgresql.org/docs/16/sql-revoke.html"
    }
  },
  {
    "chunk_id": 0,
    "text": "ROLLBACK — abort the current transaction",
    "metadata": {
      "doc_name": "sql-rollback",
      "section_title": "ROLLBACK",
      "url": "https://www.postgresql.org/docs/16/sql-rollback.html"
    }
  },
  {
    "chunk_id": 1,
    "text": "CODE:\n\nROLLBACK [ WORK | TRANSACTION ] [ AND [ NO ] CHAIN ]",
    "metadata": {
      "doc_name": "sql-rollback",
      "section_title": "Synopsis",
      "url": "https://www.postgresql.org/docs/16/sql-rollback.html"
    }
  },
  {
    "chunk_id": 2,
    "text": "ROLLBACKrolls back the current transaction and causes all the updates made by the transaction to be discarded.",
    "metadata": {
      "doc_name": "sql-rollback",
      "section_title": "Description",
      "url": "https://www.postgresql.org/docs/16/sql-rollback.html"
    }
  },
  {
    "chunk_id": 3,
    "text": "Optional key words. They have no effect.\nIfAND CHAINis specified, a new (not aborted) transaction is immediately started with the same transaction characteristics (seeSET TRANSACTION) as the just finished one. Otherwise, no new transaction is started.",
    "metadata": {
      "doc_name": "sql-rollback",
      "section_title": "Parameters",
      "url": "https://www.postgresql.org/docs/16/sql-rollback.html"
    }
  },
  {
    "chunk_id": 4,
    "text": "UseCOMMITto successfully terminate a transaction.\nIssuingROLLBACKoutside of a transaction block emits a warning and otherwise has no effect.ROLLBACK AND CHAINoutside of a transaction block is an error.",
    "metadata": {
      "doc_name": "sql-rollback",
      "section_title": "Notes",
      "url": "https://www.postgresql.org/docs/16/sql-rollback.html"
    }
  },
  {
    "chunk_id": 5,
    "text": "To abort all changes:\n\n\nCODE:\n\nROLLBACK;",
    "metadata": {
      "doc_name": "sql-rollback",
      "section_title": "Examples",
      "url": "https://www.postgresql.org/docs/16/sql-rollback.html"
    }
  },
  {
    "chunk_id": 6,
    "text": "The commandROLLBACKconforms to the SQL standard. The formROLLBACK TRANSACTIONis a PostgreSQL extension.",
    "metadata": {
      "doc_name": "sql-rollback",
      "section_title": "Compatibility",
      "url": "https://www.postgresql.org/docs/16/sql-rollback.html"
    }
  },
  {
    "chunk_id": 0,
    "text": "SAVEPOINT — define a new savepoint within the current transaction",
    "metadata": {
      "doc_name": "sql-savepoint",
      "section_title": "SAVEPOINT",
      "url": "https://www.postgresql.org/docs/16/sql-savepoint.html"
    }
  },
  {
    "chunk_id": 1,
    "text": "CODE:\n\nSAVEPOINT savepoint_name",
    "metadata": {
      "doc_name": "sql-savepoint",
      "section_title": "Synopsis",
      "url": "https://www.postgresql.org/docs/16/sql-savepoint.html"
    }
  },
  {
    "chunk_id": 2,
    "text": "SAVEPOINTestablishes a new savepoint within the current transaction.\nA savepoint is a special mark inside a transaction that allows all commands that are executed after it was established to be rolled back, restoring the transaction state to what it was at the time of the savepoint.",
    "metadata": {
      "doc_name": "sql-savepoint",
      "section_title": "Description",
      "url": "https://www.postgresql.org/docs/16/sql-savepoint.html"
    }
  },
  {
    "chunk_id": 3,
    "text": "The name to give to the new savepoint. If savepoints with the same name already exist, they will be inaccessible until newer identically-named savepoints are released.",
    "metadata": {
      "doc_name": "sql-savepoint",
      "section_title": "Parameters",
      "url": "https://www.postgresql.org/docs/16/sql-savepoint.html"
    }
  },
  {
    "chunk_id": 4,
    "text": "UseROLLBACK TOto rollback to a savepoint. UseRELEASE SAVEPOINTto destroy a savepoint, keeping the effects of commands executed after it was established.\nSavepoints can only be established when inside a transaction block. There can be multiple savepoints defined within a transaction.",
    "metadata": {
      "doc_name": "sql-savepoint",
      "section_title": "Notes",
      "url": "https://www.postgresql.org/docs/16/sql-savepoint.html"
    }
  },
  {
    "chunk_id": 5,
    "text": "To establish a savepoint and later undo the effects of all commands executed after it was established:\n\n\nCODE:\n\nBEGIN;\n    INSERT INTO table1 VALUES (1);\n    SAVEPOINT my_savepoint;\n    INSERT INTO table1 VALUES (2);\n    ROLLBACK TO SAVEPOINT my_savepoint;\n    INSERT INTO table1 VALUES (3);\nCOMMIT;\n\nThe above transaction will insert the values 1 and 3, but not 2.\nTo establish and later destroy a savepoint:\n\n\nCODE:\n\nBEGIN;\n    INSERT INTO table1 VALUES (3);\n    SAVEPOINT my_savepoint;\n    INSERT INTO table1 VALUES (4);\n    RELEASE SAVEPOINT my_savepoint;\nCOMMIT;\n\nThe above transaction will insert both 3 and 4.\nTo use a single savepoint name:\n\n\nCODE:\n\nBEGIN;\n    INSERT INTO table1 VALUES (1);\n    SAVEPOINT my_savepoint;\n    INSERT INTO table1 VALUES (2);\n    SAVEPOINT my_savepoint;\n    INSERT INTO table1 VALUES (3);\n\n    -- rollback to the second savepoint\n    ROLLBACK TO SAVEPOINT my_savepoint;\n    SELECT * FROM table1;               -- shows rows 1 and 2\n\n    -- release the second savepoint\n    RELEASE SAVEPOINT my_savepoint;\n\n    -- rollback to the first savepoint\n    ROLLBACK TO SAVEPOINT my_savepoint;\n    SELECT * FROM table1;               -- shows only row 1\nCOMMIT;\n\nThe above transaction shows row 3 being rolled back first, then row 2.",
    "metadata": {
      "doc_name": "sql-savepoint",
      "section_title": "Examples",
      "url": "https://www.postgresql.org/docs/16/sql-savepoint.html"
    }
  },
  {
    "chunk_id": 6,
    "text": "SQL requires a savepoint to be destroyed automatically when another savepoint with the same name is established. InPostgreSQL, the old savepoint is kept, though only the more recent one will be used when rolling back or releasing. (Releasing the newer savepoint withRELEASE SAVEPOINTwill cause the older one to again become accessible toROLLBACK TO SAVEPOINTandRELEASE SAVEPOINT.) Otherwise,SAVEPOINTis fully SQL conforming.",
    "metadata": {
      "doc_name": "sql-savepoint",
      "section_title": "Compatibility",
      "url": "https://www.postgresql.org/docs/16/sql-savepoint.html"
    }
  },
  {
    "chunk_id": 0,
    "text": "SELECT, TABLE, WITH — retrieve rows from a table or view",
    "metadata": {
      "doc_name": "sql-select",
      "section_title": "SELECT",
      "url": "https://www.postgresql.org/docs/16/sql-select.html"
    }
  },
  {
    "chunk_id": 1,
    "text": "CODE:\n\n[ WITH [ RECURSIVE ] with_query [, ...] ]\nSELECT [ ALL | DISTINCT [ ON ( expression [, ...] ) ] ]\n    [ { * | expression [ [ AS ] output_name ] } [, ...] ]\n    [ FROM from_item [, ...] ]\n    [ WHERE condition ]\n    [ GROUP BY [ ALL | DISTINCT ] grouping_element [, ...] ]\n    [ HAVING condition ]\n    [ WINDOW window_name AS ( window_definition ) [, ...] ]\n    [ { UNION | INTERSECT | EXCEPT } [ ALL | DISTINCT ] select ]\n    [ ORDER BY expression [ ASC | DESC | USING operator ] [ NULLS { FIRST | LAST } ] [, ...] ]\n    [ LIMIT { count | ALL } ]\n    [ OFFSET start [ ROW | ROWS ] ]\n    [ FETCH { FIRST | NEXT } [ count ] { ROW | ROWS } { ONLY | WITH TIES } ]\n    [ FOR { UPDATE | NO KEY UPDATE | SHARE | KEY SHARE } [ OF table_name [, ...] ] [ NOWAIT | SKIP LOCKED ] [...] ]\n\nwhere from_item can be one of:\n\n    [ ONLY ] table_name [ * ] [ [ AS ] alias [ ( column_alias [, ...] ) ] ]\n                [ TABLESAMPLE sampling_method ( argument [, ...] ) [ REPEATABLE ( seed ) ] ]\n    [ LATERAL ] ( select ) [ [ AS ] alias [ ( column_alias [, ...] ) ] ]\n    with_query_name [ [ AS ] alias [ ( column_alias [, ...] ) ] ]\n    [ LATERAL ] function_name ( [ argument [, ...] ] )\n                [ WITH ORDINALITY ] [ [ AS ] alias [ ( column_alias [, ...] ) ] ]\n    [ LATERAL ] function_name ( [ argument [, ...] ] ) [ AS ] alias ( column_definition [, ...] )\n    [ LATERAL ] function_name ( [ argument [, ...] ] ) AS ( column_definition [, ...] )\n    [ LATERAL ] ROWS FROM( function_name ( [ argument [, ...] ] ) [ AS ( column_definition [, ...] ) ] [, ...] )\n                [ WITH ORDINALITY ] [ [ AS ] alias [ ( column_alias [, ...] ) ] ]\n    from_item join_type from_item { ON join_condition | USING ( join_column [, ...] ) [ AS join_using_alias ] }\n    from_item NATURAL join_type from_item",
    "metadata": {
      "doc_name": "sql-select",
      "section_title": "Synopsis",
      "url": "https://www.postgresql.org/docs/16/sql-select.html"
    }
  },
  {
    "chunk_id": 2,
    "text": "column_definition [, ...] )\n    [ LATERAL ] ROWS FROM( function_name ( [ argument [, ...] ] ) [ AS ( column_definition [, ...] ) ] [, ...] )\n                [ WITH ORDINALITY ] [ [ AS ] alias [ ( column_alias [, ...] ) ] ]\n    from_item join_type from_item { ON join_condition | USING ( join_column [, ...] ) [ AS join_using_alias ] }\n    from_item NATURAL join_type from_item\n    from_item CROSS JOIN from_item\n\nand grouping_element can be one of:\n\n    ( )\n    expression\n    ( expression [, ...] )\n    ROLLUP ( { expression | ( expression [, ...] ) } [, ...] )\n    CUBE ( { expression | ( expression [, ...] ) } [, ...] )\n    GROUPING SETS ( grouping_element [, ...] )\n\nand with_query is:\n\n    with_query_name [ ( column_name [, ...] ) ] AS [ [ NOT ] MATERIALIZED ] ( select | values | insert | update | delete )\n        [ SEARCH { BREADTH | DEPTH } FIRST BY column_name [, ...] SET search_seq_col_name ]\n        [ CYCLE column_name [, ...] SET cycle_mark_col_name [ TO cycle_mark_value DEFAULT cycle_mark_default ] USING cycle_path_col_name ]\n\nTABLE [ ONLY ] table_name [ * ]",
    "metadata": {
      "doc_name": "sql-select",
      "section_title": "Synopsis",
      "url": "https://www.postgresql.org/docs/16/sql-select.html"
    }
  },
  {
    "chunk_id": 3,
    "text": "SELECTretrieves rows from zero or more tables. The general processing ofSELECTis as follows:\nAll queries in theWITHlist are computed. These effectively serve as temporary tables that can be referenced in theFROMlist. AWITHquery that is referenced more than once inFROMis computed only once, unless specified otherwise withNOT MATERIALIZED. (SeeWITH Clausebelow.)\nAll elements in theFROMlist are computed. (Each element in theFROMlist is a real or virtual table.) If more than one element is specified in theFROMlist, they are cross-joined together. (SeeFROM Clausebelow.)\nIf theWHEREclause is specified, all rows that do not satisfy the condition are eliminated from the output. (SeeWHERE Clausebelow.)\nIf theGROUP BYclause is specified, or if there are aggregate function calls, the output is combined into groups of rows that match on one or more values, and the results of aggregate functions are computed. If theHAVINGclause is present, it eliminates groups that do not satisfy the given condition. (SeeGROUP BY ClauseandHAVING Clausebelow.) Although query output columns are nominally computed in the next step, they can also be referenced (by name or ordinal number) in theGROUP BYclause.\nThe actual output rows are computed using theSELECToutput expressions for each selected row or row group. (SeeSELECT Listbelow.)\nSELECT DISTINCTeliminates duplicate rows from the result.SELECT DISTINCT ONeliminates rows that match on all the specified expressions.SELECT ALL(the default) will return all candidate rows, including duplicates. (SeeDISTINCT Clausebelow.)\nUsing the operatorsUNION,INTERSECT, andEXCEPT, the output of more than oneSELECTstatement can be combined to form a single result set. TheUNIONoperator returns all rows that are in one or both of the result sets. TheINTERSECToperator returns all rows that are strictly in both result sets. TheEXCEPToperator returns the rows that are in the first result set but not in the second. In all three cases, duplicate rows are eliminated unlessALLis specified. The noise wordDISTINCTcan be added to explicitly specify eliminating duplicate rows. Notice thatDISTINCTis the default behavior here, even thoughALLis the default forSELECTitself. (SeeUNION Clause,INTERSECT Clause, andEXCEPT Clausebelow.)\nIf theORDER BYclause is specified, the returned rows are sorted in the specified order. IfORDER BYis not given,",
    "metadata": {
      "doc_name": "sql-select",
      "section_title": "Description",
      "url": "https://www.postgresql.org/docs/16/sql-select.html"
    }
  },
  {
    "chunk_id": 4,
    "text": "result set but not in the second. In all three cases, duplicate rows are eliminated unlessALLis specified. The noise wordDISTINCTcan be added to explicitly specify eliminating duplicate rows. Notice thatDISTINCTis the default behavior here, even thoughALLis the default forSELECTitself. (SeeUNION Clause,INTERSECT Clause, andEXCEPT Clausebelow.)\nIf theORDER BYclause is specified, the returned rows are sorted in the specified order. IfORDER BYis not given, the rows are returned in whatever order the system finds fastest to produce. (SeeORDER BY Clausebelow.)\nIf theLIMIT(orFETCH FIRST) orOFFSETclause is specified, theSELECTstatement only returns a subset of the result rows. (SeeLIMIT Clausebelow.)\nIfFOR UPDATE,FOR NO KEY UPDATE,FOR SHAREorFOR KEY SHAREis specified, theSELECTstatement locks the selected rows against concurrent updates. (SeeThe Locking Clausebelow.)\nYou must haveSELECTprivilege on each column used in aSELECTcommand. The use ofFOR NO KEY UPDATE,FOR UPDATE,FOR SHAREorFOR KEY SHARErequiresUPDATEprivilege as well (for at least one column of each table so selected).",
    "metadata": {
      "doc_name": "sql-select",
      "section_title": "Description",
      "url": "https://www.postgresql.org/docs/16/sql-select.html"
    }
  },
  {
    "chunk_id": 5,
    "text": "TheWITHclause allows you to specify one or more subqueries that can be referenced by name in the primary query. The subqueries effectively act as temporary tables or views for the duration of the primary query. Each subquery can be aSELECT,TABLE,VALUES,INSERT,UPDATEorDELETEstatement. When writing a data-modifying statement (INSERT,UPDATEorDELETE) inWITH, it is usual to include aRETURNINGclause. It is the output ofRETURNING,notthe underlying table that the statement modifies, that forms the temporary table that is read by the primary query. IfRETURNINGis omitted, the statement is still executed, but it produces no output so it cannot be referenced as a table by the primary query.\nA name (without schema qualification) must be specified for eachWITHquery. Optionally, a list of column names can be specified; if this is omitted, the column names are inferred from the subquery.\nIfRECURSIVEis specified, it allows aSELECTsubquery to reference itself by name. Such a subquery must have the form\n\n\nCODE:\n\nnon_recursive_term UNION [ ALL | DISTINCT ] recursive_term\n\nwhere the recursive self-reference must appear on the right-hand side of theUNION. Only one recursive self-reference is permitted per query. Recursive data-modifying statements are not supported, but you can use the results of a recursiveSELECTquery in a data-modifying statement. SeeSection 7.8for an example.\nAnother effect ofRECURSIVEis thatWITHqueries need not be ordered: a query can reference another one that is later in the list. (However, circular references, or mutual recursion, are not implemented.) WithoutRECURSIVE,WITHqueries can only reference siblingWITHqueries that are earlier in theWITHlist.\nWhen there are multiple queries in theWITHclause,RECURSIVEshould be written only once, immediately afterWITH. It applies to all queries in theWITHclause, though it has no effect on queries that do not use recursion or forward references.\nThe optionalSEARCHclause computes asearch sequence columnthat can be used for ordering the results of a recursive query in either breadth-first or depth-first order. The supplied column name list specifies the row key that is to be used for keeping track of visited rows. A column namedsearch_seq_col_namewill be added to the result column list of theWITHquery. This column can be ordered by in the outer query to achieve the respective ordering. See",
    "metadata": {
      "doc_name": "sql-select",
      "section_title": "WITHClause",
      "url": "https://www.postgresql.org/docs/16/sql-select.html"
    }
  },
  {
    "chunk_id": 6,
    "text": "queries that do not use recursion or forward references.\nThe optionalSEARCHclause computes asearch sequence columnthat can be used for ordering the results of a recursive query in either breadth-first or depth-first order. The supplied column name list specifies the row key that is to be used for keeping track of visited rows. A column namedsearch_seq_col_namewill be added to the result column list of theWITHquery. This column can be ordered by in the outer query to achieve the respective ordering. SeeSection 7.8.2.1for examples.\nThe optionalCYCLEclause is used to detect cycles in recursive queries. The supplied column name list specifies the row key that is to be used for keeping track of visited rows. A column namedcycle_mark_col_namewill be added to the result column list of theWITHquery. This column will be set tocycle_mark_valuewhen a cycle has been detected, else tocycle_mark_default. Furthermore, processing of the recursive union will stop when a cycle has been detected.cycle_mark_valueandcycle_mark_defaultmust be constants and they must be coercible to a common data type, and the data type must have an inequality operator. (The SQL standard requires that they be Boolean constants or character strings, but PostgreSQL does not require that.) By default,TRUEandFALSE(of typeboolean) are used. Furthermore, a column namedcycle_path_col_namewill be added to the result column list of theWITHquery. This column is used internally for tracking visited rows. SeeSection 7.8.2.2for examples.\nBoth theSEARCHand theCYCLEclause are only valid for recursiveWITHqueries. Thewith_querymust be aUNION(orUNION ALL) of twoSELECT(or equivalent) commands (no nestedUNIONs). If both clauses are used, the column added by theSEARCHclause appears before the columns added by theCYCLEclause.\nThe primary query and theWITHqueries are all (notionally) executed at the same time. This implies that the effects of a data-modifying statement inWITHcannot be seen from other parts of the query, other than by reading itsRETURNINGoutput. If two such data-modifying statements attempt to modify the same row, the results are unspecified.\nA key property ofWITHqueries is that they are normally evaluated only once per execution of the primary query, even if the primary query refers to them more than once. In particular, data-modifying statements are guaranteed to",
    "metadata": {
      "doc_name": "sql-select",
      "section_title": "WITHClause",
      "url": "https://www.postgresql.org/docs/16/sql-select.html"
    }
  },
  {
    "chunk_id": 7,
    "text": "executed at the same time. This implies that the effects of a data-modifying statement inWITHcannot be seen from other parts of the query, other than by reading itsRETURNINGoutput. If two such data-modifying statements attempt to modify the same row, the results are unspecified.\nA key property ofWITHqueries is that they are normally evaluated only once per execution of the primary query, even if the primary query refers to them more than once. In particular, data-modifying statements are guaranteed to be executed once and only once, regardless of whether the primary query reads all or any of their output.\nHowever, aWITHquery can be markedNOT MATERIALIZEDto remove this guarantee. In that case, theWITHquery can be folded into the primary query much as though it were a simple sub-SELECTin the primary query'sFROMclause. This results in duplicate computations if the primary query refers to thatWITHquery more than once; but if each such use requires only a few rows of theWITHquery's total output,NOT MATERIALIZEDcan provide a net savings by allowing the queries to be optimized jointly.NOT MATERIALIZEDis ignored if it is attached to aWITHquery that is recursive or is not side-effect-free (i.e., is not a plainSELECTcontaining no volatile functions).\nBy default, a side-effect-freeWITHquery is folded into the primary query if it is used exactly once in the primary query'sFROMclause. This allows joint optimization of the two query levels in situations where that should be semantically invisible. However, such folding can be prevented by marking theWITHquery asMATERIALIZED. That might be useful, for example, if theWITHquery is being used as an optimization fence to prevent the planner from choosing a bad plan.PostgreSQLversions before v12 never did such folding, so queries written for older versions might rely onWITHto act as an optimization fence.\nSeeSection 7.8for additional information.",
    "metadata": {
      "doc_name": "sql-select",
      "section_title": "WITHClause",
      "url": "https://www.postgresql.org/docs/16/sql-select.html"
    }
  },
  {
    "chunk_id": 8,
    "text": "TheFROMclause specifies one or more source tables for theSELECT. If multiple sources are specified, the result is the Cartesian product (cross join) of all the sources. But usually qualification conditions are added (viaWHERE) to restrict the returned rows to a small subset of the Cartesian product.\nTheFROMclause can contain the following elements:\nThe name (optionally schema-qualified) of an existing table or view. IfONLYis specified before the table name, only that table is scanned. IfONLYis not specified, the table and all its descendant tables (if any) are scanned. Optionally,*can be specified after the table name to explicitly indicate that descendant tables are included.\nA substitute name for theFROMitem containing the alias. An alias is used for brevity or to eliminate ambiguity for self-joins (where the same table is scanned multiple times). When an alias is provided, it completely hides the actual name of the table or function; for example givenFROM foo AS f, the remainder of theSELECTmust refer to thisFROMitem asfnotfoo. If an alias is written, a column alias list can also be written to provide substitute names for one or more columns of the table.\nATABLESAMPLEclause after atable_nameindicates that the specifiedsampling_methodshould be used to retrieve a subset of the rows in that table. This sampling precedes the application of any other filters such asWHEREclauses. The standardPostgreSQLdistribution includes two sampling methods,BERNOULLIandSYSTEM, and other sampling methods can be installed in the database via extensions.\nTheBERNOULLIandSYSTEMsampling methods each accept a singleargumentwhich is the fraction of the table to sample, expressed as a percentage between 0 and 100. This argument can be anyreal-valued expression. (Other sampling methods might accept more or different arguments.) These two methods each return a randomly-chosen sample of the table that will contain approximately the specified percentage of the table's rows. TheBERNOULLImethod scans the whole table and selects or ignores individual rows independently with the specified probability. TheSYSTEMmethod does block-level sampling with each block having the specified chance of being selected; all rows in each selected block are returned. TheSYSTEMmethod is significantly faster than theBERNOULLImethod when small sampling percentages are specified, but it may return a less-random sample of the table as a result of clustering effects.\nThe optionalREPEATABLEclause specifies aseednumber or expression to",
    "metadata": {
      "doc_name": "sql-select",
      "section_title": "FROMClause",
      "url": "https://www.postgresql.org/docs/16/sql-select.html"
    }
  },
  {
    "chunk_id": 9,
    "text": "TheBERNOULLImethod scans the whole table and selects or ignores individual rows independently with the specified probability. TheSYSTEMmethod does block-level sampling with each block having the specified chance of being selected; all rows in each selected block are returned. TheSYSTEMmethod is significantly faster than theBERNOULLImethod when small sampling percentages are specified, but it may return a less-random sample of the table as a result of clustering effects.\nThe optionalREPEATABLEclause specifies aseednumber or expression to use for generating random numbers within the sampling method. The seed value can be any non-null floating-point value. Two queries that specify the same seed andargumentvalues will select the same sample of the table, if the table has not been changed meanwhile. But different seed values will usually produce different samples. IfREPEATABLEis not given then a new random sample is selected for each query, based upon a system-generated seed. Note that some add-on sampling methods do not acceptREPEATABLE, and will always produce new samples on each use.\nA sub-SELECTcan appear in theFROMclause. This acts as though its output were created as a temporary table for the duration of this singleSELECTcommand. Note that the sub-SELECTmust be surrounded by parentheses, and an alias can be provided in the same way as for a table. AVALUEScommand can also be used here.\nAWITHquery is referenced by writing its name, just as though the query's name were a table name. (In fact, theWITHquery hides any real table of the same name for the purposes of the primary query. If necessary, you can refer to a real table of the same name by schema-qualifying the table's name.) An alias can be provided in the same way as for a table.\nFunction calls can appear in theFROMclause. (This is especially useful for functions that return result sets, but any function can be used.) This acts as though the function's output were created as a temporary table for the duration of this singleSELECTcommand. If the function's result type is composite (including the case of a function with multipleOUTparameters), each attribute becomes a separate column in the implicit table.\nWhen the optionalWITH ORDINALITYclause is added to the function call, an additional column of typebigintwill be appended to the function's result column(s). This column numbers the rows of the function's result set, starting from 1. By default, this column is namedordinality",
    "metadata": {
      "doc_name": "sql-select",
      "section_title": "FROMClause",
      "url": "https://www.postgresql.org/docs/16/sql-select.html"
    }
  },
  {
    "chunk_id": 10,
    "text": "temporary table for the duration of this singleSELECTcommand. If the function's result type is composite (including the case of a function with multipleOUTparameters), each attribute becomes a separate column in the implicit table.\nWhen the optionalWITH ORDINALITYclause is added to the function call, an additional column of typebigintwill be appended to the function's result column(s). This column numbers the rows of the function's result set, starting from 1. By default, this column is namedordinality.\nAn alias can be provided in the same way as for a table. If an alias is written, a column alias list can also be written to provide substitute names for one or more attributes of the function's composite return type, including the ordinality column if present.\nMultiple function calls can be combined into a singleFROM-clause item by surrounding them withROWS FROM( ... ). The output of such an item is the concatenation of the first row from each function, then the second row from each function, etc. If some of the functions produce fewer rows than others, null values are substituted for the missing data, so that the total number of rows returned is always the same as for the function that produced the most rows.\nIf the function has been defined as returning therecorddata type, then an alias or the key wordASmust be present, followed by a column definition list in the form(column_namedata_type[, ...]). The column definition list must match the actual number and types of columns returned by the function.\nWhen using theROWS FROM( ... )syntax, if one of the functions requires a column definition list, it's preferred to put the column definition list after the function call insideROWS FROM( ... ). A column definition list can be placed after theROWS FROM( ... )construct only if there's just a single function and noWITH ORDINALITYclause.\nTo useORDINALITYtogether with a column definition list, you must use theROWS FROM( ... )syntax and put the column definition list insideROWS FROM( ... ).\nOne of\n[ INNER ] JOIN\nLEFT [ OUTER ] JOIN\nRIGHT [ OUTER ] JOIN\nFULL [ OUTER ] JOIN\nFor theINNERandOUTERjoin types, a join condition must be specified, namely exactly one ofONjoin_condition,USING (join_column[, ...]), orNATURAL. See below for the meaning.\nAJOINclause combines twoFROMitems, which for convenience we will refer to as“tables”, though",
    "metadata": {
      "doc_name": "sql-select",
      "section_title": "FROMClause",
      "url": "https://www.postgresql.org/docs/16/sql-select.html"
    }
  },
  {
    "chunk_id": 11,
    "text": "put the column definition list insideROWS FROM( ... ).\nOne of\n[ INNER ] JOIN\nLEFT [ OUTER ] JOIN\nRIGHT [ OUTER ] JOIN\nFULL [ OUTER ] JOIN\nFor theINNERandOUTERjoin types, a join condition must be specified, namely exactly one ofONjoin_condition,USING (join_column[, ...]), orNATURAL. See below for the meaning.\nAJOINclause combines twoFROMitems, which for convenience we will refer to as“tables”, though in reality they can be any type ofFROMitem. Use parentheses if necessary to determine the order of nesting. In the absence of parentheses,JOINs nest left-to-right. In any caseJOINbinds more tightly than the commas separatingFROM-list items. All theJOINoptions are just a notational convenience, since they do nothing you couldn't do with plainFROMandWHERE.\nLEFT OUTER JOINreturns all rows in the qualified Cartesian product (i.e., all combined rows that pass its join condition), plus one copy of each row in the left-hand table for which there was no right-hand row that passed the join condition. This left-hand row is extended to the full width of the joined table by inserting null values for the right-hand columns. Note that only theJOINclause's own condition is considered while deciding which rows have matches. Outer conditions are applied afterwards.\nConversely,RIGHT OUTER JOINreturns all the joined rows, plus one row for each unmatched right-hand row (extended with nulls on the left). This is just a notational convenience, since you could convert it to aLEFT OUTER JOINby switching the left and right tables.\nFULL OUTER JOINreturns all the joined rows, plus one row for each unmatched left-hand row (extended with nulls on the right), plus one row for each unmatched right-hand row (extended with nulls on the left).\njoin_conditionis an expression resulting in a value of typeboolean(similar to aWHEREclause) that specifies which rows in a join are considered to match.\nA clause of the formUSING ( a, b, ... )is shorthand forON left_table.a = right_table.a AND left_table.b = right_table.b .... Also,USINGimplies that only one of each pair of equivalent columns will be included in the join output, not both.\nIf ajoin_using_aliasname is specified, it provides a table alias for the join columns. Only the join columns listed in theUSINGclause are addressable by this",
    "metadata": {
      "doc_name": "sql-select",
      "section_title": "FROMClause",
      "url": "https://www.postgresql.org/docs/16/sql-select.html"
    }
  },
  {
    "chunk_id": 12,
    "text": "join are considered to match.\nA clause of the formUSING ( a, b, ... )is shorthand forON left_table.a = right_table.a AND left_table.b = right_table.b .... Also,USINGimplies that only one of each pair of equivalent columns will be included in the join output, not both.\nIf ajoin_using_aliasname is specified, it provides a table alias for the join columns. Only the join columns listed in theUSINGclause are addressable by this name. Unlike a regularalias, this does not hide the names of the joined tables from the rest of the query. Also unlike a regularalias, you cannot write a column alias list — the output names of the join columns are the same as they appear in theUSINGlist.\nNATURALis shorthand for aUSINGlist that mentions all columns in the two tables that have matching names. If there are no common column names,NATURALis equivalent toON TRUE.\nCROSS JOINis equivalent toINNER JOIN ON (TRUE), that is, no rows are removed by qualification. They produce a simple Cartesian product, the same result as you get from listing the two tables at the top level ofFROM, but restricted by the join condition (if any).\nTheLATERALkey word can precede a sub-SELECTFROMitem. This allows the sub-SELECTto refer to columns ofFROMitems that appear before it in theFROMlist. (WithoutLATERAL, each sub-SELECTis evaluated independently and so cannot cross-reference any otherFROMitem.)\nLATERALcan also precede a function-callFROMitem, but in this case it is a noise word, because the function expression can refer to earlierFROMitems in any case.\nALATERALitem can appear at top level in theFROMlist, or within aJOINtree. In the latter case it can also refer to any items that are on the left-hand side of aJOINthat it is on the right-hand side of.\nWhen aFROMitem containsLATERALcross-references, evaluation proceeds as follows: for each row of theFROMitem providing the cross-referenced column(s), or set of rows of multipleFROMitems providing the columns, theLATERALitem is evaluated using that row or row set's values of the columns. The resulting row(s) are joined as usual with the rows they were computed from. This is repeated for each row or set of rows from the column source table(s).",
    "metadata": {
      "doc_name": "sql-select",
      "section_title": "FROMClause",
      "url": "https://www.postgresql.org/docs/16/sql-select.html"
    }
  },
  {
    "chunk_id": 13,
    "text": "of.\nWhen aFROMitem containsLATERALcross-references, evaluation proceeds as follows: for each row of theFROMitem providing the cross-referenced column(s), or set of rows of multipleFROMitems providing the columns, theLATERALitem is evaluated using that row or row set's values of the columns. The resulting row(s) are joined as usual with the rows they were computed from. This is repeated for each row or set of rows from the column source table(s).\nThe column source table(s) must beINNERorLEFTjoined to theLATERALitem, else there would not be a well-defined set of rows from which to compute each set of rows for theLATERALitem. Thus, although a construct such asXRIGHT JOIN LATERALYis syntactically valid, it is not actually allowed forYto referenceX.",
    "metadata": {
      "doc_name": "sql-select",
      "section_title": "FROMClause",
      "url": "https://www.postgresql.org/docs/16/sql-select.html"
    }
  },
  {
    "chunk_id": 14,
    "text": "The optionalWHEREclause has the general form\n\n\nCODE:\n\nWHERE condition\n\nwhereconditionis any expression that evaluates to a result of typeboolean. Any row that does not satisfy this condition will be eliminated from the output. A row satisfies the condition if it returns true when the actual row values are substituted for any variable references.",
    "metadata": {
      "doc_name": "sql-select",
      "section_title": "WHEREClause",
      "url": "https://www.postgresql.org/docs/16/sql-select.html"
    }
  },
  {
    "chunk_id": 15,
    "text": "The optionalGROUP BYclause has the general form\n\n\nCODE:\n\nGROUP BY [ ALL | DISTINCT ] grouping_element [, ...]\n\nGROUP BYwill condense into a single row all selected rows that share the same values for the grouped expressions. Anexpressionused inside agrouping_elementcan be an input column name, or the name or ordinal number of an output column (SELECTlist item), or an arbitrary expression formed from input-column values. In case of ambiguity, aGROUP BYname will be interpreted as an input-column name rather than an output column name.\nIf any ofGROUPING SETS,ROLLUPorCUBEare present as grouping elements, then theGROUP BYclause as a whole defines some number of independentgrouping sets. The effect of this is equivalent to constructing aUNION ALLbetween subqueries with the individual grouping sets as theirGROUP BYclauses. The optionalDISTINCTclause removes duplicate sets before processing; it doesnottransform theUNION ALLinto aUNION DISTINCT. For further details on the handling of grouping sets seeSection 7.2.4.\nAggregate functions, if any are used, are computed across all rows making up each group, producing a separate value for each group. (If there are aggregate functions but noGROUP BYclause, the query is treated as having a single group comprising all the selected rows.) The set of rows fed to each aggregate function can be further filtered by attaching aFILTERclause to the aggregate function call; seeSection 4.2.7for more information. When aFILTERclause is present, only those rows matching it are included in the input to that aggregate function.\nWhenGROUP BYis present, or any aggregate functions are present, it is not valid for theSELECTlist expressions to refer to ungrouped columns except within aggregate functions or when the ungrouped column is functionally dependent on the grouped columns, since there would otherwise be more than one possible value to return for an ungrouped column. A functional dependency exists if the grouped columns (or a subset thereof) are the primary key of the table containing the ungrouped column.\nKeep in mind that all aggregate functions are evaluated before evaluating any“scalar”expressions in theHAVINGclause orSELECTlist. This means that, for example, aCASEexpression cannot be used to skip evaluation of an aggregate function; seeSection 4.2.14.\nCurrently,FOR NO KEY UPDATE,FOR UPDATE,FOR SHAREandFOR KEY SHAREcannot be specified withGROUP",
    "metadata": {
      "doc_name": "sql-select",
      "section_title": "GROUP BYClause",
      "url": "https://www.postgresql.org/docs/16/sql-select.html"
    }
  },
  {
    "chunk_id": 16,
    "text": "the grouped columns (or a subset thereof) are the primary key of the table containing the ungrouped column.\nKeep in mind that all aggregate functions are evaluated before evaluating any“scalar”expressions in theHAVINGclause orSELECTlist. This means that, for example, aCASEexpression cannot be used to skip evaluation of an aggregate function; seeSection 4.2.14.\nCurrently,FOR NO KEY UPDATE,FOR UPDATE,FOR SHAREandFOR KEY SHAREcannot be specified withGROUP BY.",
    "metadata": {
      "doc_name": "sql-select",
      "section_title": "GROUP BYClause",
      "url": "https://www.postgresql.org/docs/16/sql-select.html"
    }
  },
  {
    "chunk_id": 17,
    "text": "The optionalHAVINGclause has the general form\n\n\nCODE:\n\nHAVING condition\n\nwhereconditionis the same as specified for theWHEREclause.\nHAVINGeliminates group rows that do not satisfy the condition.HAVINGis different fromWHERE:WHEREfilters individual rows before the application ofGROUP BY, whileHAVINGfilters group rows created byGROUP BY. Each column referenced inconditionmust unambiguously reference a grouping column, unless the reference appears within an aggregate function or the ungrouped column is functionally dependent on the grouping columns.\nThe presence ofHAVINGturns a query into a grouped query even if there is noGROUP BYclause. This is the same as what happens when the query contains aggregate functions but noGROUP BYclause. All the selected rows are considered to form a single group, and theSELECTlist andHAVINGclause can only reference table columns from within aggregate functions. Such a query will emit a single row if theHAVINGcondition is true, zero rows if it is not true.\nCurrently,FOR NO KEY UPDATE,FOR UPDATE,FOR SHAREandFOR KEY SHAREcannot be specified withHAVING.",
    "metadata": {
      "doc_name": "sql-select",
      "section_title": "HAVINGClause",
      "url": "https://www.postgresql.org/docs/16/sql-select.html"
    }
  },
  {
    "chunk_id": 18,
    "text": "The optionalWINDOWclause has the general form\n\n\nCODE:\n\nWINDOW window_name AS ( window_definition ) [, ...]\n\nwherewindow_nameis a name that can be referenced fromOVERclauses or subsequent window definitions, andwindow_definitionis\n\n\nCODE:\n\n[ existing_window_name ]\n[ PARTITION BY expression [, ...] ]\n[ ORDER BY expression [ ASC | DESC | USING operator ] [ NULLS { FIRST | LAST } ] [, ...] ]\n[ frame_clause ]\n\nIf anexisting_window_nameis specified it must refer to an earlier entry in theWINDOWlist; the new window copies its partitioning clause from that entry, as well as its ordering clause if any. In this case the new window cannot specify its ownPARTITION BYclause, and it can specifyORDER BYonly if the copied window does not have one. The new window always uses its own frame clause; the copied window must not specify a frame clause.\nThe elements of thePARTITION BYlist are interpreted in much the same fashion as elements of aGROUP BYclause, except that they are always simple expressions and never the name or number of an output column. Another difference is that these expressions can contain aggregate function calls, which are not allowed in a regularGROUP BYclause. They are allowed here because windowing occurs after grouping and aggregation.\nSimilarly, the elements of theORDER BYlist are interpreted in much the same fashion as elements of a statement-levelORDER BYclause, except that the expressions are always taken as simple expressions and never the name or number of an output column.\nThe optionalframe_clausedefines thewindow framefor window functions that depend on the frame (not all do). The window frame is a set of related rows for each row of the query (called thecurrent row). Theframe_clausecan be one of\n\n\nCODE:\n\n{ RANGE | ROWS | GROUPS } frame_start [ frame_exclusion ]\n{ RANGE | ROWS | GROUPS } BETWEEN frame_start AND frame_end [ frame_exclusion ]\n\nwhereframe_startandframe_endcan be one of\n\n\nCODE:\n\nUNBOUNDED PRECEDING\noffset PRECEDING\nCURRENT ROW\noffset FOLLOWING\nUNBOUNDED FOLLOWING\n\nandframe_exclusioncan be one of\n\n\nCODE:\n\nEXCLUDE CURRENT ROW\nEXCLUDE GROUP\nEXCLUDE TIES\nEXCLUDE NO OTHERS\n\nIfframe_endis omitted it defaults toCURRENT ROW. Restrictions are thatframe_startcannot beUNBOUNDED FOLLOWING,frame_endcannot be",
    "metadata": {
      "doc_name": "sql-select",
      "section_title": "WINDOWClause",
      "url": "https://www.postgresql.org/docs/16/sql-select.html"
    }
  },
  {
    "chunk_id": 19,
    "text": "frame_startandframe_endcan be one of\n\n\nCODE:\n\nUNBOUNDED PRECEDING\noffset PRECEDING\nCURRENT ROW\noffset FOLLOWING\nUNBOUNDED FOLLOWING\n\nandframe_exclusioncan be one of\n\n\nCODE:\n\nEXCLUDE CURRENT ROW\nEXCLUDE GROUP\nEXCLUDE TIES\nEXCLUDE NO OTHERS\n\nIfframe_endis omitted it defaults toCURRENT ROW. Restrictions are thatframe_startcannot beUNBOUNDED FOLLOWING,frame_endcannot beUNBOUNDED PRECEDING, and theframe_endchoice cannot appear earlier in the above list offrame_startandframe_endoptions than theframe_startchoice does — for exampleRANGE BETWEEN CURRENT ROW ANDoffsetPRECEDINGis not allowed.\nThe default framing option isRANGE UNBOUNDED PRECEDING, which is the same asRANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW; it sets the frame to be all rows from the partition start up through the current row's lastpeer(a row that the window'sORDER BYclause considers equivalent to the current row; all rows are peers if there is noORDER BY). In general,UNBOUNDED PRECEDINGmeans that the frame starts with the first row of the partition, and similarlyUNBOUNDED FOLLOWINGmeans that the frame ends with the last row of the partition, regardless ofRANGE,ROWSorGROUPSmode. InROWSmode,CURRENT ROWmeans that the frame starts or ends with the current row; but inRANGEorGROUPSmode it means that the frame starts or ends with the current row's first or last peer in theORDER BYordering. TheoffsetPRECEDINGandoffsetFOLLOWINGoptions vary in meaning depending on the frame mode. InROWSmode, theoffsetis an integer indicating that the frame starts or ends that many rows before or after the current row. InGROUPSmode, theoffsetis an integer indicating that the frame starts or ends that many peer groups before or after the current row's peer group, where apeer groupis a group of rows that are equivalent according to the window'sORDER BYclause. InRANGEmode, use of anoffsetoption requires that there be exactly oneORDER BYcolumn in the window definition. Then the frame contains those rows whose ordering column value is no more thanoffsetless than (forPRECEDING) or more than (forFOLLOWING) the current row's ordering column value. In these",
    "metadata": {
      "doc_name": "sql-select",
      "section_title": "WINDOWClause",
      "url": "https://www.postgresql.org/docs/16/sql-select.html"
    }
  },
  {
    "chunk_id": 20,
    "text": "peer groups before or after the current row's peer group, where apeer groupis a group of rows that are equivalent according to the window'sORDER BYclause. InRANGEmode, use of anoffsetoption requires that there be exactly oneORDER BYcolumn in the window definition. Then the frame contains those rows whose ordering column value is no more thanoffsetless than (forPRECEDING) or more than (forFOLLOWING) the current row's ordering column value. In these cases the data type of theoffsetexpression depends on the data type of the ordering column. For numeric ordering columns it is typically of the same type as the ordering column, but for datetime ordering columns it is aninterval. In all these cases, the value of theoffsetmust be non-null and non-negative. Also, while theoffsetdoes not have to be a simple constant, it cannot contain variables, aggregate functions, or window functions.\nTheframe_exclusionoption allows rows around the current row to be excluded from the frame, even if they would be included according to the frame start and frame end options.EXCLUDE CURRENT ROWexcludes the current row from the frame.EXCLUDE GROUPexcludes the current row and its ordering peers from the frame.EXCLUDE TIESexcludes any peers of the current row from the frame, but not the current row itself.EXCLUDE NO OTHERSsimply specifies explicitly the default behavior of not excluding the current row or its peers.\nBeware that theROWSmode can produce unpredictable results if theORDER BYordering does not order the rows uniquely. TheRANGEandGROUPSmodes are designed to ensure that rows that are peers in theORDER BYordering are treated alike: all rows of a given peer group will be in the frame or excluded from it.\nThe purpose of aWINDOWclause is to specify the behavior ofwindow functionsappearing in the query'sSELECTlistorORDER BYclause. These functions can reference theWINDOWclause entries by name in theirOVERclauses. AWINDOWclause entry does not have to be referenced anywhere, however; if it is not used in the query it is simply ignored. It is possible to use window functions without anyWINDOWclause at all, since a window function call can specify its window definition directly in itsOVERclause. However, theWINDOWclause saves typing when the same window definition is needed for more than one window function.\nCurrently,FOR NO KEY UPDATE,FOR UPDATE,FOR SHAREandFOR KEY SHAREcannot be specified withWINDOW.\nWindow",
    "metadata": {
      "doc_name": "sql-select",
      "section_title": "WINDOWClause",
      "url": "https://www.postgresql.org/docs/16/sql-select.html"
    }
  },
  {
    "chunk_id": 21,
    "text": "INDOWclause entry does not have to be referenced anywhere, however; if it is not used in the query it is simply ignored. It is possible to use window functions without anyWINDOWclause at all, since a window function call can specify its window definition directly in itsOVERclause. However, theWINDOWclause saves typing when the same window definition is needed for more than one window function.\nCurrently,FOR NO KEY UPDATE,FOR UPDATE,FOR SHAREandFOR KEY SHAREcannot be specified withWINDOW.\nWindow functions are described in detail inSection 3.5,Section 4.2.8, andSection 7.2.5.",
    "metadata": {
      "doc_name": "sql-select",
      "section_title": "WINDOWClause",
      "url": "https://www.postgresql.org/docs/16/sql-select.html"
    }
  },
  {
    "chunk_id": 22,
    "text": "TheSELECTlist (between the key wordsSELECTandFROM) specifies expressions that form the output rows of theSELECTstatement. The expressions can (and usually do) refer to columns computed in theFROMclause.\nJust as in a table, every output column of aSELECThas a name. In a simpleSELECTthis name is just used to label the column for display, but when theSELECTis a sub-query of a larger query, the name is seen by the larger query as the column name of the virtual table produced by the sub-query. To specify the name to use for an output column, writeASoutput_nameafter the column's expression. (You can omitAS, but only if the desired output name does not match anyPostgreSQLkeyword (seeAppendix C). For protection against possible future keyword additions, it is recommended that you always either writeASor double-quote the output name.) If you do not specify a column name, a name is chosen automatically byPostgreSQL. If the column's expression is a simple column reference then the chosen name is the same as that column's name. In more complex cases a function or type name may be used, or the system may fall back on a generated name such as?column?.\nAn output column's name can be used to refer to the column's value inORDER BYandGROUP BYclauses, but not in theWHEREorHAVINGclauses; there you must write out the expression instead.\nInstead of an expression,*can be written in the output list as a shorthand for all the columns of the selected rows. Also, you can writetable_name.*as a shorthand for the columns coming from just that table. In these cases it is not possible to specify new names withAS; the output column names will be the same as the table columns' names.\nAccording to the SQL standard, the expressions in the output list should be computed before applyingDISTINCT,ORDER BY, orLIMIT. This is obviously necessary when usingDISTINCT, since otherwise it's not clear what values are being made distinct. However, in many cases it is convenient if output expressions are computed afterORDER BYandLIMIT; particularly if the output list contains any volatile or expensive functions. With that behavior, the order of function evaluations is more intuitive and there will not be evaluations corresponding to rows that never appear in the output.PostgreSQLwill effectively evaluate output expressions after sorting and limiting, so long as those expressions are not referenced inDISTINCT,ORDER",
    "metadata": {
      "doc_name": "sql-select",
      "section_title": "SELECTList",
      "url": "https://www.postgresql.org/docs/16/sql-select.html"
    }
  },
  {
    "chunk_id": 23,
    "text": "usingDISTINCT, since otherwise it's not clear what values are being made distinct. However, in many cases it is convenient if output expressions are computed afterORDER BYandLIMIT; particularly if the output list contains any volatile or expensive functions. With that behavior, the order of function evaluations is more intuitive and there will not be evaluations corresponding to rows that never appear in the output.PostgreSQLwill effectively evaluate output expressions after sorting and limiting, so long as those expressions are not referenced inDISTINCT,ORDER BYorGROUP BY. (As a counterexample,SELECT f(x) FROM tab ORDER BY 1clearly must evaluatef(x)before sorting.) Output expressions that contain set-returning functions are effectively evaluated after sorting and before limiting, so thatLIMITwill act to cut off the output from a set-returning function.",
    "metadata": {
      "doc_name": "sql-select",
      "section_title": "SELECTList",
      "url": "https://www.postgresql.org/docs/16/sql-select.html"
    }
  },
  {
    "chunk_id": 24,
    "text": "PostgreSQLversions before 9.6 did not provide any guarantees about the timing of evaluation of output expressions versus sorting and limiting; it depended on the form of the chosen query plan.",
    "metadata": {
      "doc_name": "sql-select",
      "section_title": "Note",
      "url": "https://www.postgresql.org/docs/16/sql-select.html"
    }
  },
  {
    "chunk_id": 25,
    "text": "IfSELECT DISTINCTis specified, all duplicate rows are removed from the result set (one row is kept from each group of duplicates).SELECT ALLspecifies the opposite: all rows are kept; that is the default.\nSELECT DISTINCT ON (expression[, ...] )keeps only the first row of each set of rows where the given expressions evaluate to equal. TheDISTINCT ONexpressions are interpreted using the same rules as forORDER BY(see above). Note that the“first row”of each set is unpredictable unlessORDER BYis used to ensure that the desired row appears first. For example:\n\n\nCODE:\n\nSELECT DISTINCT ON (location) location, time, report\n    FROM weather_reports\n    ORDER BY location, time DESC;\n\nretrieves the most recent weather report for each location. But if we had not usedORDER BYto force descending order of time values for each location, we'd have gotten a report from an unpredictable time for each location.\nTheDISTINCT ONexpression(s) must match the leftmostORDER BYexpression(s). TheORDER BYclause will normally contain additional expression(s) that determine the desired precedence of rows within eachDISTINCT ONgroup.\nCurrently,FOR NO KEY UPDATE,FOR UPDATE,FOR SHAREandFOR KEY SHAREcannot be specified withDISTINCT.",
    "metadata": {
      "doc_name": "sql-select",
      "section_title": "DISTINCTClause",
      "url": "https://www.postgresql.org/docs/16/sql-select.html"
    }
  },
  {
    "chunk_id": 26,
    "text": "TheUNIONclause has this general form:\n\n\nCODE:\n\nselect_statement UNION [ ALL | DISTINCT ] select_statement\n\nselect_statementis anySELECTstatement without anORDER BY,LIMIT,FOR NO KEY UPDATE,FOR UPDATE,FOR SHARE, orFOR KEY SHAREclause. (ORDER BYandLIMITcan be attached to a subexpression if it is enclosed in parentheses. Without parentheses, these clauses will be taken to apply to the result of theUNION, not to its right-hand input expression.)\nTheUNIONoperator computes the set union of the rows returned by the involvedSELECTstatements. A row is in the set union of two result sets if it appears in at least one of the result sets. The twoSELECTstatements that represent the direct operands of theUNIONmust produce the same number of columns, and corresponding columns must be of compatible data types.\nThe result ofUNIONdoes not contain any duplicate rows unless theALLoption is specified.ALLprevents elimination of duplicates. (Therefore,UNION ALLis usually significantly quicker thanUNION; useALLwhen you can.)DISTINCTcan be written to explicitly specify the default behavior of eliminating duplicate rows.\nMultipleUNIONoperators in the sameSELECTstatement are evaluated left to right, unless otherwise indicated by parentheses.\nCurrently,FOR NO KEY UPDATE,FOR UPDATE,FOR SHAREandFOR KEY SHAREcannot be specified either for aUNIONresult or for any input of aUNION.",
    "metadata": {
      "doc_name": "sql-select",
      "section_title": "UNIONClause",
      "url": "https://www.postgresql.org/docs/16/sql-select.html"
    }
  },
  {
    "chunk_id": 27,
    "text": "TheINTERSECTclause has this general form:\n\n\nCODE:\n\nselect_statement INTERSECT [ ALL | DISTINCT ] select_statement\n\nselect_statementis anySELECTstatement without anORDER BY,LIMIT,FOR NO KEY UPDATE,FOR UPDATE,FOR SHARE, orFOR KEY SHAREclause.\nTheINTERSECToperator computes the set intersection of the rows returned by the involvedSELECTstatements. A row is in the intersection of two result sets if it appears in both result sets.\nThe result ofINTERSECTdoes not contain any duplicate rows unless theALLoption is specified. WithALL, a row that hasmduplicates in the left table andnduplicates in the right table will appear min(m,n) times in the result set.DISTINCTcan be written to explicitly specify the default behavior of eliminating duplicate rows.\nMultipleINTERSECToperators in the sameSELECTstatement are evaluated left to right, unless parentheses dictate otherwise.INTERSECTbinds more tightly thanUNION. That is,A UNION B INTERSECT Cwill be read asA UNION (B INTERSECT C).\nCurrently,FOR NO KEY UPDATE,FOR UPDATE,FOR SHAREandFOR KEY SHAREcannot be specified either for anINTERSECTresult or for any input of anINTERSECT.",
    "metadata": {
      "doc_name": "sql-select",
      "section_title": "INTERSECTClause",
      "url": "https://www.postgresql.org/docs/16/sql-select.html"
    }
  },
  {
    "chunk_id": 28,
    "text": "TheEXCEPTclause has this general form:\n\n\nCODE:\n\nselect_statement EXCEPT [ ALL | DISTINCT ] select_statement\n\nselect_statementis anySELECTstatement without anORDER BY,LIMIT,FOR NO KEY UPDATE,FOR UPDATE,FOR SHARE, orFOR KEY SHAREclause.\nTheEXCEPToperator computes the set of rows that are in the result of the leftSELECTstatement but not in the result of the right one.\nThe result ofEXCEPTdoes not contain any duplicate rows unless theALLoption is specified. WithALL, a row that hasmduplicates in the left table andnduplicates in the right table will appear max(m-n,0) times in the result set.DISTINCTcan be written to explicitly specify the default behavior of eliminating duplicate rows.\nMultipleEXCEPToperators in the sameSELECTstatement are evaluated left to right, unless parentheses dictate otherwise.EXCEPTbinds at the same level asUNION.\nCurrently,FOR NO KEY UPDATE,FOR UPDATE,FOR SHAREandFOR KEY SHAREcannot be specified either for anEXCEPTresult or for any input of anEXCEPT.",
    "metadata": {
      "doc_name": "sql-select",
      "section_title": "EXCEPTClause",
      "url": "https://www.postgresql.org/docs/16/sql-select.html"
    }
  },
  {
    "chunk_id": 29,
    "text": "The optionalORDER BYclause has this general form:\n\n\nCODE:\n\nORDER BY expression [ ASC | DESC | USING operator ] [ NULLS { FIRST | LAST } ] [, ...]\n\nTheORDER BYclause causes the result rows to be sorted according to the specified expression(s). If two rows are equal according to the leftmost expression, they are compared according to the next expression and so on. If they are equal according to all specified expressions, they are returned in an implementation-dependent order.\nEachexpressioncan be the name or ordinal number of an output column (SELECTlist item), or it can be an arbitrary expression formed from input-column values.\nThe ordinal number refers to the ordinal (left-to-right) position of the output column. This feature makes it possible to define an ordering on the basis of a column that does not have a unique name. This is never absolutely necessary because it is always possible to assign a name to an output column using theASclause.\nIt is also possible to use arbitrary expressions in theORDER BYclause, including columns that do not appear in theSELECToutput list. Thus the following statement is valid:\n\n\nCODE:\n\nSELECT name FROM distributors ORDER BY code;\n\nA limitation of this feature is that anORDER BYclause applying to the result of aUNION,INTERSECT, orEXCEPTclause can only specify an output column name or number, not an expression.\nIf anORDER BYexpression is a simple name that matches both an output column name and an input column name,ORDER BYwill interpret it as the output column name. This is the opposite of the choice thatGROUP BYwill make in the same situation. This inconsistency is made to be compatible with the SQL standard.\nOptionally one can add the key wordASC(ascending) orDESC(descending) after any expression in theORDER BYclause. If not specified,ASCis assumed by default. Alternatively, a specific ordering operator name can be specified in theUSINGclause. An ordering operator must be a less-than or greater-than member of some B-tree operator family.ASCis usually equivalent toUSING <andDESCis usually equivalent toUSING >. (But the creator of a user-defined data type can define exactly what the default sort ordering is, and it might correspond to operators with other names.)\nIfNULLS LASTis specified, null values sort after all non-null values; ifNULLS FIRSTis specified, null values sort before all non-null values. If neither is specified, the default behavior isNULLS",
    "metadata": {
      "doc_name": "sql-select",
      "section_title": "ORDER BYClause",
      "url": "https://www.postgresql.org/docs/16/sql-select.html"
    }
  },
  {
    "chunk_id": 30,
    "text": "-than member of some B-tree operator family.ASCis usually equivalent toUSING <andDESCis usually equivalent toUSING >. (But the creator of a user-defined data type can define exactly what the default sort ordering is, and it might correspond to operators with other names.)\nIfNULLS LASTis specified, null values sort after all non-null values; ifNULLS FIRSTis specified, null values sort before all non-null values. If neither is specified, the default behavior isNULLS LASTwhenASCis specified or implied, andNULLS FIRSTwhenDESCis specified (thus, the default is to act as though nulls are larger than non-nulls). WhenUSINGis specified, the default nulls ordering depends on whether the operator is a less-than or greater-than operator.\nNote that ordering options apply only to the expression they follow; for exampleORDER BY x, y DESCdoes not mean the same thing asORDER BY x DESC, y DESC.\nCharacter-string data is sorted according to the collation that applies to the column being sorted. That can be overridden at need by including aCOLLATEclause in theexpression, for exampleORDER BY mycolumn COLLATE \"en_US\". For more information seeSection 4.2.10andSection 24.2.",
    "metadata": {
      "doc_name": "sql-select",
      "section_title": "ORDER BYClause",
      "url": "https://www.postgresql.org/docs/16/sql-select.html"
    }
  },
  {
    "chunk_id": 31,
    "text": "TheLIMITclause consists of two independent sub-clauses:\n\n\nCODE:\n\nLIMIT { count | ALL }\nOFFSET start\n\nThe parametercountspecifies the maximum number of rows to return, whilestartspecifies the number of rows to skip before starting to return rows. When both are specified,startrows are skipped before starting to count thecountrows to be returned.\nIf thecountexpression evaluates to NULL, it is treated asLIMIT ALL, i.e., no limit. Ifstartevaluates to NULL, it is treated the same asOFFSET 0.\nSQL:2008 introduced a different syntax to achieve the same result, whichPostgreSQLalso supports. It is:\n\n\nCODE:\n\nOFFSET start { ROW | ROWS }\nFETCH { FIRST | NEXT } [ count ] { ROW | ROWS } { ONLY | WITH TIES }\n\nIn this syntax, thestartorcountvalue is required by the standard to be a literal constant, a parameter, or a variable name; as aPostgreSQLextension, other expressions are allowed, but will generally need to be enclosed in parentheses to avoid ambiguity. Ifcountis omitted in aFETCHclause, it defaults to 1. TheWITH TIESoption is used to return any additional rows that tie for the last place in the result set according to theORDER BYclause;ORDER BYis mandatory in this case, andSKIP LOCKEDis not allowed.ROWandROWSas well asFIRSTandNEXTare noise words that don't influence the effects of these clauses. According to the standard, theOFFSETclause must come before theFETCHclause if both are present; butPostgreSQLis laxer and allows either order.\nWhen usingLIMIT, it is a good idea to use anORDER BYclause that constrains the result rows into a unique order. Otherwise you will get an unpredictable subset of the query's rows — you might be asking for the tenth through twentieth rows, but tenth through twentieth in what ordering? You don't know what ordering unless you specifyORDER BY.\nThe query planner takesLIMITinto account when generating a query plan, so you are very likely to get different plans (yielding different row orders) depending on what you use forLIMITandOFFSET. Thus, using differentLIMIT/OFFSETvalues to select different subsets of a query resultwill give inconsistent resultsunless you enforce a predictable result ordering withORDER BY. This is not a bug; it is an inherent consequence of the fact that SQL does not promise to deliver the results of a query in any particular order unlessORDER",
    "metadata": {
      "doc_name": "sql-select",
      "section_title": "LIMITClause",
      "url": "https://www.postgresql.org/docs/16/sql-select.html"
    }
  },
  {
    "chunk_id": 32,
    "text": "takesLIMITinto account when generating a query plan, so you are very likely to get different plans (yielding different row orders) depending on what you use forLIMITandOFFSET. Thus, using differentLIMIT/OFFSETvalues to select different subsets of a query resultwill give inconsistent resultsunless you enforce a predictable result ordering withORDER BY. This is not a bug; it is an inherent consequence of the fact that SQL does not promise to deliver the results of a query in any particular order unlessORDER BYis used to constrain the order.\nIt is even possible for repeated executions of the sameLIMITquery to return different subsets of the rows of a table, if there is not anORDER BYto enforce selection of a deterministic subset. Again, this is not a bug; determinism of the results is simply not guaranteed in such a case.",
    "metadata": {
      "doc_name": "sql-select",
      "section_title": "LIMITClause",
      "url": "https://www.postgresql.org/docs/16/sql-select.html"
    }
  },
  {
    "chunk_id": 33,
    "text": "FOR UPDATE,FOR NO KEY UPDATE,FOR SHAREandFOR KEY SHAREarelocking clauses; they affect howSELECTlocks rows as they are obtained from the table.\nThe locking clause has the general form\n\n\nCODE:\n\nFOR lock_strength [ OF table_name [, ...] ] [ NOWAIT | SKIP LOCKED ]\n\nwherelock_strengthcan be one of\n\n\nCODE:\n\nUPDATE\nNO KEY UPDATE\nSHARE\nKEY SHARE\n\nFor more information on each row-level lock mode, refer toSection 13.3.2.\nTo prevent the operation from waiting for other transactions to commit, use either theNOWAITorSKIP LOCKEDoption. WithNOWAIT, the statement reports an error, rather than waiting, if a selected row cannot be locked immediately. WithSKIP LOCKED, any selected rows that cannot be immediately locked are skipped. Skipping locked rows provides an inconsistent view of the data, so this is not suitable for general purpose work, but can be used to avoid lock contention with multiple consumers accessing a queue-like table. Note thatNOWAITandSKIP LOCKEDapply only to the row-level lock(s) — the requiredROW SHAREtable-level lock is still taken in the ordinary way (seeChapter 13). You can useLOCKwith theNOWAIToption first, if you need to acquire the table-level lock without waiting.\nIf specific tables are named in a locking clause, then only rows coming from those tables are locked; any other tables used in theSELECTare simply read as usual. A locking clause without a table list affects all tables used in the statement. If a locking clause is applied to a view or sub-query, it affects all tables used in the view or sub-query. However, these clauses do not apply toWITHqueries referenced by the primary query. If you want row locking to occur within aWITHquery, specify a locking clause within theWITHquery.\nMultiple locking clauses can be written if it is necessary to specify different locking behavior for different tables. If the same table is mentioned (or implicitly affected) by more than one locking clause, then it is processed as if it was only specified by the strongest one. Similarly, a table is processed asNOWAITif that is specified in any of the clauses affecting it. Otherwise, it is processed asSKIP LOCKEDif that is specified in any of the clauses affecting it.\nThe locking clauses cannot be used in contexts where returned rows cannot be clearly identified with individual table rows; for example they cannot be used with aggregation.\nWhen a",
    "metadata": {
      "doc_name": "sql-select",
      "section_title": "The Locking Clause",
      "url": "https://www.postgresql.org/docs/16/sql-select.html"
    }
  },
  {
    "chunk_id": 34,
    "text": "(or implicitly affected) by more than one locking clause, then it is processed as if it was only specified by the strongest one. Similarly, a table is processed asNOWAITif that is specified in any of the clauses affecting it. Otherwise, it is processed asSKIP LOCKEDif that is specified in any of the clauses affecting it.\nThe locking clauses cannot be used in contexts where returned rows cannot be clearly identified with individual table rows; for example they cannot be used with aggregation.\nWhen a locking clause appears at the top level of aSELECTquery, the rows that are locked are exactly those that are returned by the query; in the case of a join query, the rows locked are those that contribute to returned join rows. In addition, rows that satisfied the query conditions as of the query snapshot will be locked, although they will not be returned if they were updated after the snapshot and no longer satisfy the query conditions. If aLIMITis used, locking stops once enough rows have been returned to satisfy the limit (but note that rows skipped over byOFFSETwill get locked). Similarly, if a locking clause is used in a cursor's query, only rows actually fetched or stepped past by the cursor will be locked.\nWhen a locking clause appears in a sub-SELECT, the rows locked are those returned to the outer query by the sub-query. This might involve fewer rows than inspection of the sub-query alone would suggest, since conditions from the outer query might be used to optimize execution of the sub-query. For example,\n\n\nCODE:\n\nSELECT * FROM (SELECT * FROM mytable FOR UPDATE) ss WHERE col1 = 5;\n\nwill lock only rows havingcol1 = 5, even though that condition is not textually within the sub-query.\nPrevious releases failed to preserve a lock which is upgraded by a later savepoint. For example, this code:\n\n\nCODE:\n\nBEGIN;\nSELECT * FROM mytable WHERE key = 1 FOR UPDATE;\nSAVEPOINT s;\nUPDATE mytable SET ... WHERE key = 1;\nROLLBACK TO s;\n\nwould fail to preserve theFOR UPDATElock after theROLLBACK TO. This has been fixed in release 9.3.",
    "metadata": {
      "doc_name": "sql-select",
      "section_title": "The Locking Clause",
      "url": "https://www.postgresql.org/docs/16/sql-select.html"
    }
  },
  {
    "chunk_id": 35,
    "text": "It is possible for aSELECTcommand running at theREAD COMMITTEDtransaction isolation level and usingORDER BYand a locking clause to return rows out of order. This is becauseORDER BYis applied first. The command sorts the result, but might then block trying to obtain a lock on one or more of the rows. Once theSELECTunblocks, some of the ordering column values might have been modified, leading to those rows appearing to be out of order (though they are in order in terms of the original column values). This can be worked around at need by placing theFOR UPDATE/SHAREclause in a sub-query, for example\n\n\nCODE:\n\nSELECT * FROM (SELECT * FROM mytable FOR UPDATE) ss ORDER BY column1;\n\nNote that this will result in locking all rows ofmytable, whereasFOR UPDATEat the top level would lock only the actually returned rows. This can make for a significant performance difference, particularly if theORDER BYis combined withLIMITor other restrictions. So this technique is recommended only if concurrent updates of the ordering columns are expected and a strictly sorted result is required.\nAt theREPEATABLE READorSERIALIZABLEtransaction isolation level this would cause a serialization failure (with anSQLSTATEof'40001'), so there is no possibility of receiving rows out of order under these isolation levels.",
    "metadata": {
      "doc_name": "sql-select",
      "section_title": "Caution",
      "url": "https://www.postgresql.org/docs/16/sql-select.html"
    }
  },
  {
    "chunk_id": 36,
    "text": "The command\n\n\nCODE:\n\nTABLE name\n\nis equivalent to\n\n\nCODE:\n\nSELECT * FROM name\n\nIt can be used as a top-level command or as a space-saving syntax variant in parts of complex queries. Only theWITH,UNION,INTERSECT,EXCEPT,ORDER BY,LIMIT,OFFSET,FETCHandFORlocking clauses can be used withTABLE; theWHEREclause and any form of aggregation cannot be used.",
    "metadata": {
      "doc_name": "sql-select",
      "section_title": "TABLECommand",
      "url": "https://www.postgresql.org/docs/16/sql-select.html"
    }
  },
  {
    "chunk_id": 37,
    "text": "To join the tablefilmswith the tabledistributors:\n\n\nCODE:\n\nSELECT f.title, f.did, d.name, f.date_prod, f.kind\n    FROM distributors d JOIN films f USING (did);\n\n       title       | did |     name     | date_prod  |   kind\n-------------------+-----+--------------+------------+----------\n The Third Man     | 101 | British Lion | 1949-12-23 | Drama\n The African Queen | 101 | British Lion | 1951-08-11 | Romantic\n ...\n\nTo sum the columnlenof all films and group the results bykind:\n\n\nCODE:\n\nSELECT kind, sum(len) AS total FROM films GROUP BY kind;\n\n   kind   | total\n----------+-------\n Action   | 07:34\n Comedy   | 02:58\n Drama    | 14:28\n Musical  | 06:42\n Romantic | 04:38\n\nTo sum the columnlenof all films, group the results bykindand show those group totals that are less than 5 hours:\n\n\nCODE:\n\nSELECT kind, sum(len) AS total\n    FROM films\n    GROUP BY kind\n    HAVING sum(len) < interval '5 hours';\n\n   kind   | total\n----------+-------\n Comedy   | 02:58\n Romantic | 04:38\n\nThe following two examples are identical ways of sorting the individual results according to the contents of the second column (name):\n\n\nCODE:\n\nSELECT * FROM distributors ORDER BY name;\nSELECT * FROM distributors ORDER BY 2;\n\n did |       name\n-----+------------------\n 109 | 20th Century Fox\n 110 | Bavaria Atelier\n 101 | British Lion\n 107 | Columbia\n 102 | Jean Luc Godard\n 113 | Luso films\n 104 | Mosfilm\n 103 | Paramount\n 106 | Toho\n 105 | United Artists\n 111 | Walt Disney\n 112 | Warner Bros.\n 108 | Westward\n\nThe next example shows how to obtain the union of the tablesdistributorsandactors, restricting the results to those that begin with the letter W in each table. Only distinct rows are wanted, so the key wordALLis omitted.\n\n\nCODE:\n\ndistributors:               actors:\n did |     name              id |     name\n-----+--------------        ----+----------------\n 108 | Westward               1 | Woody Allen\n 111 | Walt Disney",
    "metadata": {
      "doc_name": "sql-select",
      "section_title": "Examples",
      "url": "https://www.postgresql.org/docs/16/sql-select.html"
    }
  },
  {
    "chunk_id": 38,
    "text": "Warner Bros.\n 108 | Westward\n\nThe next example shows how to obtain the union of the tablesdistributorsandactors, restricting the results to those that begin with the letter W in each table. Only distinct rows are wanted, so the key wordALLis omitted.\n\n\nCODE:\n\ndistributors:               actors:\n did |     name              id |     name\n-----+--------------        ----+----------------\n 108 | Westward               1 | Woody Allen\n 111 | Walt Disney            2 | Warren Beatty\n 112 | Warner Bros.           3 | Walter Matthau\n ...                         ...\n\nSELECT distributors.name\n    FROM distributors\n    WHERE distributors.name LIKE 'W%'\nUNION\nSELECT actors.name\n    FROM actors\n    WHERE actors.name LIKE 'W%';\n\n      name\n----------------\n Walt Disney\n Walter Matthau\n Warner Bros.\n Warren Beatty\n Westward\n Woody Allen\n\nThis example shows how to use a function in theFROMclause, both with and without a column definition list:\n\n\nCODE:\n\nCREATE FUNCTION distributors(int) RETURNS SETOF distributors AS $$\n    SELECT * FROM distributors WHERE did = $1;\n$$ LANGUAGE SQL;\n\nSELECT * FROM distributors(111);\n did |    name\n-----+-------------\n 111 | Walt Disney\n\nCREATE FUNCTION distributors_2(int) RETURNS SETOF record AS $$\n    SELECT * FROM distributors WHERE did = $1;\n$$ LANGUAGE SQL;\n\nSELECT * FROM distributors_2(111) AS (f1 int, f2 text);\n f1  |     f2\n-----+-------------\n 111 | Walt Disney\n\nHere is an example of a function with an ordinality column added:\n\n\nCODE:\n\nSELECT * FROM unnest(ARRAY['a','b','c','d','e','f']) WITH ORDINALITY;\n unnest | ordinality\n--------+----------\n a      |        1\n b      |        2\n c      |        3\n d      |        4\n e      |        5\n f      |        6\n(6 rows)\n\nThis example shows how to use a simpleWITHclause:\n\n\nCODE:\n\nWITH t AS (\n    SELECT random() as x FROM generate_series(1, 3)\n  )\nSELECT * FROM t\nUNION ALL\nSELECT * FROM t;\n         x\n--------------------\n  0.534150459803641\n  0.520092216785997\n 0.073562025092542",
    "metadata": {
      "doc_name": "sql-select",
      "section_title": "Examples",
      "url": "https://www.postgresql.org/docs/16/sql-select.html"
    }
  },
  {
    "chunk_id": 39,
    "text": "e      |        5\n f      |        6\n(6 rows)\n\nThis example shows how to use a simpleWITHclause:\n\n\nCODE:\n\nWITH t AS (\n    SELECT random() as x FROM generate_series(1, 3)\n  )\nSELECT * FROM t\nUNION ALL\nSELECT * FROM t;\n         x\n--------------------\n  0.534150459803641\n  0.520092216785997\n 0.0735620250925422\n  0.534150459803641\n  0.520092216785997\n 0.0735620250925422\n\nNotice that theWITHquery was evaluated only once, so that we got two sets of the same three random values.\nThis example usesWITH RECURSIVEto find all subordinates (direct or indirect) of the employee Mary, and their level of indirectness, from a table that shows only direct subordinates:\n\n\nCODE:\n\nWITH RECURSIVE employee_recursive(distance, employee_name, manager_name) AS (\n    SELECT 1, employee_name, manager_name\n    FROM employee\n    WHERE manager_name = 'Mary'\n  UNION ALL\n    SELECT er.distance + 1, e.employee_name, e.manager_name\n    FROM employee_recursive er, employee e\n    WHERE er.employee_name = e.manager_name\n  )\nSELECT distance, employee_name FROM employee_recursive;\n\nNotice the typical form of recursive queries: an initial condition, followed byUNION, followed by the recursive part of the query. Be sure that the recursive part of the query will eventually return no tuples, or else the query will loop indefinitely. (SeeSection 7.8for more examples.)\nThis example usesLATERALto apply a set-returning functionget_product_names()for each row of themanufacturerstable:\n\n\nCODE:\n\nSELECT m.name AS mname, pname\nFROM manufacturers m, LATERAL get_product_names(m.id) pname;\n\nManufacturers not currently having any products would not appear in the result, since it is an inner join. If we wished to include the names of such manufacturers in the result, we could do:\n\n\nCODE:\n\nSELECT m.name AS mname, pname\nFROM manufacturers m LEFT JOIN LATERAL get_product_names(m.id) pname ON true;",
    "metadata": {
      "doc_name": "sql-select",
      "section_title": "Examples",
      "url": "https://www.postgresql.org/docs/16/sql-select.html"
    }
  },
  {
    "chunk_id": 40,
    "text": "Of course, theSELECTstatement is compatible with the SQL standard. But there are some extensions and some missing features.",
    "metadata": {
      "doc_name": "sql-select",
      "section_title": "Compatibility",
      "url": "https://www.postgresql.org/docs/16/sql-select.html"
    }
  },
  {
    "chunk_id": 41,
    "text": "PostgreSQLallows one to omit theFROMclause. It has a straightforward use to compute the results of simple expressions:\n\n\nCODE:\n\nSELECT 2+2;\n\n ?column?\n----------\n        4\n\nSome otherSQLdatabases cannot do this except by introducing a dummy one-row table from which to do theSELECT.",
    "metadata": {
      "doc_name": "sql-select",
      "section_title": "OmittedFROMClauses",
      "url": "https://www.postgresql.org/docs/16/sql-select.html"
    }
  },
  {
    "chunk_id": 42,
    "text": "The list of output expressions afterSELECTcan be empty, producing a zero-column result table. This is not valid syntax according to the SQL standard.PostgreSQLallows it to be consistent with allowing zero-column tables. However, an empty list is not allowed whenDISTINCTis used.",
    "metadata": {
      "doc_name": "sql-select",
      "section_title": "EmptySELECTLists",
      "url": "https://www.postgresql.org/docs/16/sql-select.html"
    }
  },
  {
    "chunk_id": 43,
    "text": "In the SQL standard, the optional key wordAScan be omitted before an output column name whenever the new column name is a valid column name (that is, not the same as any reserved keyword).PostgreSQLis slightly more restrictive:ASis required if the new column name matches any keyword at all, reserved or not. Recommended practice is to useASor double-quote output column names, to prevent any possible conflict against future keyword additions.\nInFROMitems, both the standard andPostgreSQLallowASto be omitted before an alias that is an unreserved keyword. But this is impractical for output column names, because of syntactic ambiguities.",
    "metadata": {
      "doc_name": "sql-select",
      "section_title": "Omitting theASKey Word",
      "url": "https://www.postgresql.org/docs/16/sql-select.html"
    }
  },
  {
    "chunk_id": 44,
    "text": "According to the SQL standard, a sub-SELECTin theFROMlist must have an alias. InPostgreSQL, this alias may be omitted.",
    "metadata": {
      "doc_name": "sql-select",
      "section_title": "Omitting Sub-SELECTAliases inFROM",
      "url": "https://www.postgresql.org/docs/16/sql-select.html"
    }
  },
  {
    "chunk_id": 45,
    "text": "The SQL standard requires parentheses around the table name when writingONLY, for exampleSELECT * FROM ONLY (tab1), ONLY (tab2) WHERE ....PostgreSQLconsiders these parentheses to be optional.\nPostgreSQLallows a trailing*to be written to explicitly specify the non-ONLYbehavior of including child tables. The standard does not allow this.\n(These points apply equally to all SQL commands supporting theONLYoption.)",
    "metadata": {
      "doc_name": "sql-select",
      "section_title": "ONLYand Inheritance",
      "url": "https://www.postgresql.org/docs/16/sql-select.html"
    }
  },
  {
    "chunk_id": 46,
    "text": "TheTABLESAMPLEclause is currently accepted only on regular tables and materialized views. According to the SQL standard it should be possible to apply it to anyFROMitem.",
    "metadata": {
      "doc_name": "sql-select",
      "section_title": "TABLESAMPLEClause Restrictions",
      "url": "https://www.postgresql.org/docs/16/sql-select.html"
    }
  },
  {
    "chunk_id": 47,
    "text": "PostgreSQLallows a function call to be written directly as a member of theFROMlist. In the SQL standard it would be necessary to wrap such a function call in a sub-SELECT; that is, the syntaxFROMfunc(...)aliasis approximately equivalent toFROM LATERAL (SELECTfunc(...))alias. Note thatLATERALis considered to be implicit; this is because the standard requiresLATERALsemantics for anUNNEST()item inFROM.PostgreSQLtreatsUNNEST()the same as other set-returning functions.",
    "metadata": {
      "doc_name": "sql-select",
      "section_title": "Function Calls inFROM",
      "url": "https://www.postgresql.org/docs/16/sql-select.html"
    }
  },
  {
    "chunk_id": 48,
    "text": "In the SQL-92 standard, anORDER BYclause can only use output column names or numbers, while aGROUP BYclause can only use expressions based on input column names.PostgreSQLextends each of these clauses to allow the other choice as well (but it uses the standard's interpretation if there is ambiguity).PostgreSQLalso allows both clauses to specify arbitrary expressions. Note that names appearing in an expression will always be taken as input-column names, not as output-column names.\nSQL:1999 and later use a slightly different definition which is not entirely upward compatible with SQL-92. In most cases, however,PostgreSQLwill interpret anORDER BYorGROUP BYexpression the same way SQL:1999 does.",
    "metadata": {
      "doc_name": "sql-select",
      "section_title": "Namespace Available toGROUP BYandORDER BY",
      "url": "https://www.postgresql.org/docs/16/sql-select.html"
    }
  },
  {
    "chunk_id": 49,
    "text": "PostgreSQLrecognizes functional dependency (allowing columns to be omitted fromGROUP BY) only when a table's primary key is included in theGROUP BYlist. The SQL standard specifies additional conditions that should be recognized.",
    "metadata": {
      "doc_name": "sql-select",
      "section_title": "Functional Dependencies",
      "url": "https://www.postgresql.org/docs/16/sql-select.html"
    }
  },
  {
    "chunk_id": 50,
    "text": "The clausesLIMITandOFFSETarePostgreSQL-specific syntax, also used byMySQL. The SQL:2008 standard has introduced the clausesOFFSET ... FETCH {FIRST|NEXT} ...for the same functionality, as shown above inLIMIT Clause. This syntax is also used byIBM DB2. (Applications written forOraclefrequently use a workaround involving the automatically generatedrownumcolumn, which is not available in PostgreSQL, to implement the effects of these clauses.)",
    "metadata": {
      "doc_name": "sql-select",
      "section_title": "LIMITandOFFSET",
      "url": "https://www.postgresql.org/docs/16/sql-select.html"
    }
  },
  {
    "chunk_id": 51,
    "text": "AlthoughFOR UPDATEappears in the SQL standard, the standard allows it only as an option ofDECLARE CURSOR.PostgreSQLallows it in anySELECTquery as well as in sub-SELECTs, but this is an extension. TheFOR NO KEY UPDATE,FOR SHAREandFOR KEY SHAREvariants, as well as theNOWAITandSKIP LOCKEDoptions, do not appear in the standard.",
    "metadata": {
      "doc_name": "sql-select",
      "section_title": "FOR NO KEY UPDATE,FOR UPDATE,FOR SHARE,FOR KEY SHARE",
      "url": "https://www.postgresql.org/docs/16/sql-select.html"
    }
  },
  {
    "chunk_id": 52,
    "text": "PostgreSQLallowsINSERT,UPDATE, andDELETEto be used asWITHqueries. This is not found in the SQL standard.",
    "metadata": {
      "doc_name": "sql-select",
      "section_title": "Data-Modifying Statements inWITH",
      "url": "https://www.postgresql.org/docs/16/sql-select.html"
    }
  },
  {
    "chunk_id": 53,
    "text": "DISTINCT ON ( ... )is an extension of the SQL standard.\nROWS FROM( ... )is an extension of the SQL standard.\nTheMATERIALIZEDandNOT MATERIALIZEDoptions ofWITHare extensions of the SQL standard.",
    "metadata": {
      "doc_name": "sql-select",
      "section_title": "Nonstandard Clauses",
      "url": "https://www.postgresql.org/docs/16/sql-select.html"
    }
  },
  {
    "chunk_id": 0,
    "text": "SET TRANSACTION — set the characteristics of the current transaction",
    "metadata": {
      "doc_name": "sql-set-transaction",
      "section_title": "SET TRANSACTION",
      "url": "https://www.postgresql.org/docs/16/sql-set-transaction.html"
    }
  },
  {
    "chunk_id": 1,
    "text": "CODE:\n\nSET TRANSACTION transaction_mode [, ...]\nSET TRANSACTION SNAPSHOT snapshot_id\nSET SESSION CHARACTERISTICS AS TRANSACTION transaction_mode [, ...]\n\nwhere transaction_mode is one of:\n\n    ISOLATION LEVEL { SERIALIZABLE | REPEATABLE READ | READ COMMITTED | READ UNCOMMITTED }\n    READ WRITE | READ ONLY\n    [ NOT ] DEFERRABLE",
    "metadata": {
      "doc_name": "sql-set-transaction",
      "section_title": "Synopsis",
      "url": "https://www.postgresql.org/docs/16/sql-set-transaction.html"
    }
  },
  {
    "chunk_id": 2,
    "text": "TheSET TRANSACTIONcommand sets the characteristics of the current transaction. It has no effect on any subsequent transactions.SET SESSION CHARACTERISTICSsets the default transaction characteristics for subsequent transactions of a session. These defaults can be overridden bySET TRANSACTIONfor an individual transaction.\nThe available transaction characteristics are the transaction isolation level, the transaction access mode (read/write or read-only), and the deferrable mode. In addition, a snapshot can be selected, though only for the current transaction, not as a session default.\nThe isolation level of a transaction determines what data the transaction can see when other transactions are running concurrently:\nA statement can only see rows committed before it began. This is the default.\nAll statements of the current transaction can only see rows committed before the first query or data-modification statement was executed in this transaction.\nAll statements of the current transaction can only see rows committed before the first query or data-modification statement was executed in this transaction. If a pattern of reads and writes among concurrent serializable transactions would create a situation which could not have occurred for any serial (one-at-a-time) execution of those transactions, one of them will be rolled back with aserialization_failureerror.\nThe SQL standard defines one additional level,READ UNCOMMITTED. InPostgreSQLREAD UNCOMMITTEDis treated asREAD COMMITTED.\nThe transaction isolation level cannot be changed after the first query or data-modification statement (SELECT,INSERT,DELETE,UPDATE,MERGE,FETCH, orCOPY) of a transaction has been executed. SeeChapter 13for more information about transaction isolation and concurrency control.\nThe transaction access mode determines whether the transaction is read/write or read-only. Read/write is the default. When a transaction is read-only, the following SQL commands are disallowed:INSERT,UPDATE,DELETE,MERGE, andCOPY FROMif the table they would write to is not a temporary table; allCREATE,ALTER, andDROPcommands;COMMENT,GRANT,REVOKE,TRUNCATE; andEXPLAIN ANALYZEandEXECUTEif the command they would execute is among those listed. This is a high-level notion of read-only that does not prevent all writes to disk.\nTheDEFERRABLEtransaction property has no effect unless the transaction is alsoSERIALIZABLEandREAD ONLY. When all three of these properties are selected for a transaction, the transaction may block when first acquiring its snapshot, after which it is able to run without the normal overhead of aSERIALIZABLEtransaction and without any risk of contributing",
    "metadata": {
      "doc_name": "sql-set-transaction",
      "section_title": "Description",
      "url": "https://www.postgresql.org/docs/16/sql-set-transaction.html"
    }
  },
  {
    "chunk_id": 3,
    "text": "YZEandEXECUTEif the command they would execute is among those listed. This is a high-level notion of read-only that does not prevent all writes to disk.\nTheDEFERRABLEtransaction property has no effect unless the transaction is alsoSERIALIZABLEandREAD ONLY. When all three of these properties are selected for a transaction, the transaction may block when first acquiring its snapshot, after which it is able to run without the normal overhead of aSERIALIZABLEtransaction and without any risk of contributing to or being canceled by a serialization failure. This mode is well suited for long-running reports or backups.\nTheSET TRANSACTION SNAPSHOTcommand allows a new transaction to run with the samesnapshotas an existing transaction. The pre-existing transaction must have exported its snapshot with thepg_export_snapshotfunction (seeSection 9.27.5). That function returns a snapshot identifier, which must be given toSET TRANSACTION SNAPSHOTto specify which snapshot is to be imported. The identifier must be written as a string literal in this command, for example'00000003-0000001B-1'.SET TRANSACTION SNAPSHOTcan only be executed at the start of a transaction, before the first query or data-modification statement (SELECT,INSERT,DELETE,UPDATE,MERGE,FETCH, orCOPY) of the transaction. Furthermore, the transaction must already be set toSERIALIZABLEorREPEATABLE READisolation level (otherwise, the snapshot would be discarded immediately, sinceREAD COMMITTEDmode takes a new snapshot for each command). If the importing transaction usesSERIALIZABLEisolation level, then the transaction that exported the snapshot must also use that isolation level. Also, a non-read-only serializable transaction cannot import a snapshot from a read-only transaction.",
    "metadata": {
      "doc_name": "sql-set-transaction",
      "section_title": "Description",
      "url": "https://www.postgresql.org/docs/16/sql-set-transaction.html"
    }
  },
  {
    "chunk_id": 4,
    "text": "IfSET TRANSACTIONis executed without a priorSTART TRANSACTIONorBEGIN, it emits a warning and otherwise has no effect.\nIt is possible to dispense withSET TRANSACTIONby instead specifying the desiredtransaction_modesinBEGINorSTART TRANSACTION. But that option is not available forSET TRANSACTION SNAPSHOT.\nThe session default transaction modes can also be set or examined via the configuration parametersdefault_transaction_isolation,default_transaction_read_only, anddefault_transaction_deferrable. (In factSET SESSION CHARACTERISTICSis just a verbose equivalent for setting these variables withSET.) This means the defaults can be set in the configuration file, viaALTER DATABASE, etc. ConsultChapter 20for more information.\nThe current transaction's modes can similarly be set or examined via the configuration parameterstransaction_isolation,transaction_read_only, andtransaction_deferrable. Setting one of these parameters acts the same as the correspondingSET TRANSACTIONoption, with the same restrictions on when it can be done. However, these parameters cannot be set in the configuration file, or from any source other than live SQL.",
    "metadata": {
      "doc_name": "sql-set-transaction",
      "section_title": "Notes",
      "url": "https://www.postgresql.org/docs/16/sql-set-transaction.html"
    }
  },
  {
    "chunk_id": 5,
    "text": "To begin a new transaction with the same snapshot as an already existing transaction, first export the snapshot from the existing transaction. That will return the snapshot identifier, for example:\n\n\nCODE:\n\nBEGIN TRANSACTION ISOLATION LEVEL REPEATABLE READ;\nSELECT pg_export_snapshot();\n pg_export_snapshot\n---------------------\n 00000003-0000001B-1\n(1 row)\n\nThen give the snapshot identifier in aSET TRANSACTION SNAPSHOTcommand at the beginning of the newly opened transaction:\n\n\nCODE:\n\nBEGIN TRANSACTION ISOLATION LEVEL REPEATABLE READ;\nSET TRANSACTION SNAPSHOT '00000003-0000001B-1';",
    "metadata": {
      "doc_name": "sql-set-transaction",
      "section_title": "Examples",
      "url": "https://www.postgresql.org/docs/16/sql-set-transaction.html"
    }
  },
  {
    "chunk_id": 6,
    "text": "These commands are defined in theSQLstandard, except for theDEFERRABLEtransaction mode and theSET TRANSACTION SNAPSHOTform, which arePostgreSQLextensions.\nSERIALIZABLEis the default transaction isolation level in the standard. InPostgreSQLthe default is ordinarilyREAD COMMITTED, but you can change it as mentioned above.\nIn the SQL standard, there is one other transaction characteristic that can be set with these commands: the size of the diagnostics area. This concept is specific to embedded SQL, and therefore is not implemented in thePostgreSQLserver.\nThe SQL standard requires commas between successivetransaction_modes, but for historical reasonsPostgreSQLallows the commas to be omitted.",
    "metadata": {
      "doc_name": "sql-set-transaction",
      "section_title": "Compatibility",
      "url": "https://www.postgresql.org/docs/16/sql-set-transaction.html"
    }
  },
  {
    "chunk_id": 0,
    "text": "SET — change a run-time parameter",
    "metadata": {
      "doc_name": "sql-set",
      "section_title": "SET",
      "url": "https://www.postgresql.org/docs/16/sql-set.html"
    }
  },
  {
    "chunk_id": 1,
    "text": "CODE:\n\nSET [ SESSION | LOCAL ] configuration_parameter { TO | = } { value | 'value' | DEFAULT }\nSET [ SESSION | LOCAL ] TIME ZONE { value | 'value' | LOCAL | DEFAULT }",
    "metadata": {
      "doc_name": "sql-set",
      "section_title": "Synopsis",
      "url": "https://www.postgresql.org/docs/16/sql-set.html"
    }
  },
  {
    "chunk_id": 2,
    "text": "TheSETcommand changes run-time configuration parameters. Many of the run-time parameters listed inChapter 20can be changed on-the-fly withSET. (Some parameters can only be changed by superusers and users who have been grantedSETprivilege on that parameter. There are also parameters that cannot be changed after server or session start.)SETonly affects the value used by the current session.\nIfSET(or equivalentlySET SESSION) is issued within a transaction that is later aborted, the effects of theSETcommand disappear when the transaction is rolled back. Once the surrounding transaction is committed, the effects will persist until the end of the session, unless overridden by anotherSET.\nThe effects ofSET LOCALlast only till the end of the current transaction, whether committed or not. A special case isSETfollowed bySET LOCALwithin a single transaction: theSET LOCALvalue will be seen until the end of the transaction, but afterwards (if the transaction is committed) theSETvalue will take effect.\nThe effects ofSETorSET LOCALare also canceled by rolling back to a savepoint that is earlier than the command.\nIfSET LOCALis used within a function that has aSEToption for the same variable (seeCREATE FUNCTION), the effects of theSET LOCALcommand disappear at function exit; that is, the value in effect when the function was called is restored anyway. This allowsSET LOCALto be used for dynamic or repeated changes of a parameter within a function, while still having the convenience of using theSEToption to save and restore the caller's value. However, a regularSETcommand overrides any surrounding function'sSEToption; its effects will persist unless rolled back.",
    "metadata": {
      "doc_name": "sql-set",
      "section_title": "Description",
      "url": "https://www.postgresql.org/docs/16/sql-set.html"
    }
  },
  {
    "chunk_id": 3,
    "text": "InPostgreSQLversions 8.0 through 8.2, the effects of aSET LOCALwould be canceled by releasing an earlier savepoint, or by successful exit from aPL/pgSQLexception block. This behavior has been changed because it was deemed unintuitive.",
    "metadata": {
      "doc_name": "sql-set",
      "section_title": "Note",
      "url": "https://www.postgresql.org/docs/16/sql-set.html"
    }
  },
  {
    "chunk_id": 4,
    "text": "Specifies that the command takes effect for the current session. (This is the default if neitherSESSIONnorLOCALappears.)\nSpecifies that the command takes effect for only the current transaction. AfterCOMMITorROLLBACK, the session-level setting takes effect again. Issuing this outside of a transaction block emits a warning and otherwise has no effect.\nName of a settable run-time parameter. Available parameters are documented inChapter 20and below.\nNew value of parameter. Values can be specified as string constants, identifiers, numbers, or comma-separated lists of these, as appropriate for the particular parameter.DEFAULTcan be written to specify resetting the parameter to its default value (that is, whatever value it would have had if noSEThad been executed in the current session).\nBesides the configuration parameters documented inChapter 20, there are a few that can only be adjusted using theSETcommand or that have a special syntax:\nSET SCHEMA 'value'is an alias forSET search_path TOvalue. Only one schema can be specified using this syntax.\nSET NAMESvalueis an alias forSET client_encoding TOvalue.\nSets the internal seed for the random number generator (the functionrandom). Allowed values are floating-point numbers between -1 and 1 inclusive.\nThe seed can also be set by invoking the functionsetseed:\n\n\nCODE:\n\nSELECT setseed(value);\n\nSET TIME ZONE 'value'is an alias forSET timezone TO 'value'. The syntaxSET TIME ZONEallows special syntax for the time zone specification. Here are examples of valid values:\nThe time zone for Berkeley, California.\nThe time zone for Italy.\nThe time zone 7 hours west from UTC (equivalent to PDT). Positive values are east from UTC.\nThe time zone 8 hours west from UTC (equivalent to PST).\nSet the time zone to your local time zone (that is, the server's default value oftimezone).\nTimezone settings given as numbers or intervals are internally translated to POSIX timezone syntax. For example, afterSET TIME ZONE -7,SHOW TIME ZONEwould report<-07>+07.\nTime zone abbreviations are not supported bySET; seeSection 8.5.3for more information about time zones.",
    "metadata": {
      "doc_name": "sql-set",
      "section_title": "Parameters",
      "url": "https://www.postgresql.org/docs/16/sql-set.html"
    }
  },
  {
    "chunk_id": 5,
    "text": "The functionset_configprovides equivalent functionality; seeSection 9.27.1. Also, it is possible to UPDATE thepg_settingssystem view to perform the equivalent ofSET.",
    "metadata": {
      "doc_name": "sql-set",
      "section_title": "Notes",
      "url": "https://www.postgresql.org/docs/16/sql-set.html"
    }
  },
  {
    "chunk_id": 6,
    "text": "Set the schema search path:\n\n\nCODE:\n\nSET search_path TO my_schema, public;\n\nSet the style of date to traditionalPOSTGRESwith“day before month”input convention:\n\n\nCODE:\n\nSET datestyle TO postgres, dmy;\n\nSet the time zone for Berkeley, California:\n\n\nCODE:\n\nSET TIME ZONE 'America/Los_Angeles';\n\nSet the time zone for Italy:\n\n\nCODE:\n\nSET TIME ZONE 'Europe/Rome';",
    "metadata": {
      "doc_name": "sql-set",
      "section_title": "Examples",
      "url": "https://www.postgresql.org/docs/16/sql-set.html"
    }
  },
  {
    "chunk_id": 7,
    "text": "SET TIME ZONEextends syntax defined in the SQL standard. The standard allows only numeric time zone offsets whilePostgreSQLallows more flexible time-zone specifications. All otherSETfeatures arePostgreSQLextensions.",
    "metadata": {
      "doc_name": "sql-set",
      "section_title": "Compatibility",
      "url": "https://www.postgresql.org/docs/16/sql-set.html"
    }
  },
  {
    "chunk_id": 0,
    "text": "SHOW — show the value of a run-time parameter",
    "metadata": {
      "doc_name": "sql-show",
      "section_title": "SHOW",
      "url": "https://www.postgresql.org/docs/16/sql-show.html"
    }
  },
  {
    "chunk_id": 1,
    "text": "CODE:\n\nSHOW name\nSHOW ALL",
    "metadata": {
      "doc_name": "sql-show",
      "section_title": "Synopsis",
      "url": "https://www.postgresql.org/docs/16/sql-show.html"
    }
  },
  {
    "chunk_id": 2,
    "text": "SHOWwill display the current setting of run-time parameters. These variables can be set using theSETstatement, by editing thepostgresql.confconfiguration file, through thePGOPTIONSenvironmental variable (when usinglibpqor alibpq-based application), or through command-line flags when starting thepostgresserver. SeeChapter 20for details.",
    "metadata": {
      "doc_name": "sql-show",
      "section_title": "Description",
      "url": "https://www.postgresql.org/docs/16/sql-show.html"
    }
  },
  {
    "chunk_id": 3,
    "text": "The name of a run-time parameter. Available parameters are documented inChapter 20and on theSETreference page. In addition, there are a few parameters that can be shown but not set:\nShows the server's version number.\nShows the server-side character set encoding. At present, this parameter can be shown but not set, because the encoding is determined at database creation time.\nTrue if the current role has superuser privileges.\nShow the values of all configuration parameters, with descriptions.",
    "metadata": {
      "doc_name": "sql-show",
      "section_title": "Parameters",
      "url": "https://www.postgresql.org/docs/16/sql-show.html"
    }
  },
  {
    "chunk_id": 4,
    "text": "The functioncurrent_settingproduces equivalent output; seeSection 9.27.1. Also, thepg_settingssystem view produces the same information.",
    "metadata": {
      "doc_name": "sql-show",
      "section_title": "Notes",
      "url": "https://www.postgresql.org/docs/16/sql-show.html"
    }
  },
  {
    "chunk_id": 5,
    "text": "Show the current setting of the parameterDateStyle:\n\n\nCODE:\n\nSHOW DateStyle;\n DateStyle\n-----------\n ISO, MDY\n(1 row)\n\nShow the current setting of the parametergeqo:\n\n\nCODE:\n\nSHOW geqo;\n geqo\n------\n on\n(1 row)\n\nShow all settings:\n\n\nCODE:\n\nSHOW ALL;\n            name         | setting |                description\n-------------------------+---------+-------------------------------------------------\n allow_system_table_mods | off     | Allows modifications of the structure of ...\n    .\n    .\n    .\n xmloption               | content | Sets whether XML data in implicit parsing ...\n zero_damaged_pages      | off     | Continues processing past damaged page headers.\n(196 rows)",
    "metadata": {
      "doc_name": "sql-show",
      "section_title": "Examples",
      "url": "https://www.postgresql.org/docs/16/sql-show.html"
    }
  },
  {
    "chunk_id": 6,
    "text": "TheSHOWcommand is aPostgreSQLextension.",
    "metadata": {
      "doc_name": "sql-show",
      "section_title": "Compatibility",
      "url": "https://www.postgresql.org/docs/16/sql-show.html"
    }
  },
  {
    "chunk_id": 0,
    "text": "TRUNCATE — empty a table or set of tables",
    "metadata": {
      "doc_name": "sql-truncate",
      "section_title": "TRUNCATE",
      "url": "https://www.postgresql.org/docs/16/sql-truncate.html"
    }
  },
  {
    "chunk_id": 1,
    "text": "CODE:\n\nTRUNCATE [ TABLE ] [ ONLY ] name [ * ] [, ... ]\n    [ RESTART IDENTITY | CONTINUE IDENTITY ] [ CASCADE | RESTRICT ]",
    "metadata": {
      "doc_name": "sql-truncate",
      "section_title": "Synopsis",
      "url": "https://www.postgresql.org/docs/16/sql-truncate.html"
    }
  },
  {
    "chunk_id": 2,
    "text": "TRUNCATEquickly removes all rows from a set of tables. It has the same effect as an unqualifiedDELETEon each table, but since it does not actually scan the tables it is faster. Furthermore, it reclaims disk space immediately, rather than requiring a subsequentVACUUMoperation. This is most useful on large tables.",
    "metadata": {
      "doc_name": "sql-truncate",
      "section_title": "Description",
      "url": "https://www.postgresql.org/docs/16/sql-truncate.html"
    }
  },
  {
    "chunk_id": 3,
    "text": "The name (optionally schema-qualified) of a table to truncate. IfONLYis specified before the table name, only that table is truncated. IfONLYis not specified, the table and all its descendant tables (if any) are truncated. Optionally,*can be specified after the table name to explicitly indicate that descendant tables are included.\nAutomatically restart sequences owned by columns of the truncated table(s).\nDo not change the values of sequences. This is the default.\nAutomatically truncate all tables that have foreign-key references to any of the named tables, or to any tables added to the group due toCASCADE.\nRefuse to truncate if any of the tables have foreign-key references from tables that are not listed in the command. This is the default.",
    "metadata": {
      "doc_name": "sql-truncate",
      "section_title": "Parameters",
      "url": "https://www.postgresql.org/docs/16/sql-truncate.html"
    }
  },
  {
    "chunk_id": 4,
    "text": "You must have theTRUNCATEprivilege on a table to truncate it.\nTRUNCATEacquires anACCESS EXCLUSIVElock on each table it operates on, which blocks all other concurrent operations on the table. WhenRESTART IDENTITYis specified, any sequences that are to be restarted are likewise locked exclusively. If concurrent access to a table is required, then theDELETEcommand should be used instead.\nTRUNCATEcannot be used on a table that has foreign-key references from other tables, unless all such tables are also truncated in the same command. Checking validity in such cases would require table scans, and the whole point is not to do one. TheCASCADEoption can be used to automatically include all dependent tables — but be very careful when using this option, or else you might lose data you did not intend to! Note in particular that when the table to be truncated is a partition, siblings partitions are left untouched, but cascading occurs to all referencing tables and all their partitions with no distinction.\nTRUNCATEwill not fire anyON DELETEtriggers that might exist for the tables. But it will fireON TRUNCATEtriggers. IfON TRUNCATEtriggers are defined for any of the tables, then allBEFORE TRUNCATEtriggers are fired before any truncation happens, and allAFTER TRUNCATEtriggers are fired after the last truncation is performed and any sequences are reset. The triggers will fire in the order that the tables are to be processed (first those listed in the command, and then any that were added due to cascading).\nTRUNCATEis not MVCC-safe. After truncation, the table will appear empty to concurrent transactions, if they are using a snapshot taken before the truncation occurred. SeeSection 13.6for more details.\nTRUNCATEis transaction-safe with respect to the data in the tables: the truncation will be safely rolled back if the surrounding transaction does not commit.\nWhenRESTART IDENTITYis specified, the impliedALTER SEQUENCE RESTARToperations are also done transactionally; that is, they will be rolled back if the surrounding transaction does not commit. Be aware that if any additional sequence operations are done on the restarted sequences before the transaction rolls back, the effects of these operations on the sequences will be rolled back, but not their effects oncurrval(); that is, after the transactioncurrval()will continue to reflect the last sequence value obtained inside the failed transaction, even though the",
    "metadata": {
      "doc_name": "sql-truncate",
      "section_title": "Notes",
      "url": "https://www.postgresql.org/docs/16/sql-truncate.html"
    }
  },
  {
    "chunk_id": 5,
    "text": "is specified, the impliedALTER SEQUENCE RESTARToperations are also done transactionally; that is, they will be rolled back if the surrounding transaction does not commit. Be aware that if any additional sequence operations are done on the restarted sequences before the transaction rolls back, the effects of these operations on the sequences will be rolled back, but not their effects oncurrval(); that is, after the transactioncurrval()will continue to reflect the last sequence value obtained inside the failed transaction, even though the sequence itself may no longer be consistent with that. This is similar to the usual behavior ofcurrval()after a failed transaction.\nTRUNCATEcan be used for foreign tables if supported by the foreign data wrapper, for instance, seepostgres_fdw.",
    "metadata": {
      "doc_name": "sql-truncate",
      "section_title": "Notes",
      "url": "https://www.postgresql.org/docs/16/sql-truncate.html"
    }
  },
  {
    "chunk_id": 6,
    "text": "Truncate the tablesbigtableandfattable:\n\n\nCODE:\n\nTRUNCATE bigtable, fattable;\n\nThe same, and also reset any associated sequence generators:\n\n\nCODE:\n\nTRUNCATE bigtable, fattable RESTART IDENTITY;\n\nTruncate the tableothertable, and cascade to any tables that referenceothertablevia foreign-key constraints:\n\n\nCODE:\n\nTRUNCATE othertable CASCADE;",
    "metadata": {
      "doc_name": "sql-truncate",
      "section_title": "Examples",
      "url": "https://www.postgresql.org/docs/16/sql-truncate.html"
    }
  },
  {
    "chunk_id": 7,
    "text": "The SQL:2008 standard includes aTRUNCATEcommand with the syntaxTRUNCATE TABLEtablename. The clausesCONTINUE IDENTITY/RESTART IDENTITYalso appear in that standard, but have slightly different though related meanings. Some of the concurrency behavior of this command is left implementation-defined by the standard, so the above notes should be considered and compared with other implementations if necessary.",
    "metadata": {
      "doc_name": "sql-truncate",
      "section_title": "Compatibility",
      "url": "https://www.postgresql.org/docs/16/sql-truncate.html"
    }
  },
  {
    "chunk_id": 0,
    "text": "UPDATE — update rows of a table",
    "metadata": {
      "doc_name": "sql-update",
      "section_title": "UPDATE",
      "url": "https://www.postgresql.org/docs/16/sql-update.html"
    }
  },
  {
    "chunk_id": 1,
    "text": "CODE:\n\n[ WITH [ RECURSIVE ] with_query [, ...] ]\nUPDATE [ ONLY ] table_name [ * ] [ [ AS ] alias ]\n    SET { column_name = { expression | DEFAULT } |\n          ( column_name [, ...] ) = [ ROW ] ( { expression | DEFAULT } [, ...] ) |\n          ( column_name [, ...] ) = ( sub-SELECT )\n        } [, ...]\n    [ FROM from_item [, ...] ]\n    [ WHERE condition | WHERE CURRENT OF cursor_name ]\n    [ RETURNING { * | output_expression [ [ AS ] output_name ] } [, ...] ]",
    "metadata": {
      "doc_name": "sql-update",
      "section_title": "Synopsis",
      "url": "https://www.postgresql.org/docs/16/sql-update.html"
    }
  },
  {
    "chunk_id": 2,
    "text": "UPDATEchanges the values of the specified columns in all rows that satisfy the condition. Only the columns to be modified need be mentioned in theSETclause; columns not explicitly modified retain their previous values.\nThere are two ways to modify a table using information contained in other tables in the database: using sub-selects, or specifying additional tables in theFROMclause. Which technique is more appropriate depends on the specific circumstances.\nThe optionalRETURNINGclause causesUPDATEto compute and return value(s) based on each row actually updated. Any expression using the table's columns, and/or columns of other tables mentioned inFROM, can be computed. The new (post-update) values of the table's columns are used. The syntax of theRETURNINGlist is identical to that of the output list ofSELECT.\nYou must have theUPDATEprivilege on the table, or at least on the column(s) that are listed to be updated. You must also have theSELECTprivilege on any column whose values are read in theexpressionsorcondition.",
    "metadata": {
      "doc_name": "sql-update",
      "section_title": "Description",
      "url": "https://www.postgresql.org/docs/16/sql-update.html"
    }
  },
  {
    "chunk_id": 3,
    "text": "TheWITHclause allows you to specify one or more subqueries that can be referenced by name in theUPDATEquery. SeeSection 7.8andSELECTfor details.\nThe name (optionally schema-qualified) of the table to update. IfONLYis specified before the table name, matching rows are updated in the named table only. IfONLYis not specified, matching rows are also updated in any tables inheriting from the named table. Optionally,*can be specified after the table name to explicitly indicate that descendant tables are included.\nA substitute name for the target table. When an alias is provided, it completely hides the actual name of the table. For example, givenUPDATE foo AS f, the remainder of theUPDATEstatement must refer to this table asfnotfoo.\nThe name of a column in the table named bytable_name. The column name can be qualified with a subfield name or array subscript, if needed. Do not include the table's name in the specification of a target column — for example,UPDATE table_name SET table_name.col = 1is invalid.\nAn expression to assign to the column. The expression can use the old values of this and other columns in the table.\nSet the column to its default value (which will be NULL if no specific default expression has been assigned to it). An identity column will be set to a new value generated by the associated sequence. For a generated column, specifying this is permitted but merely specifies the normal behavior of computing the column from its generation expression.\nASELECTsub-query that produces as many output columns as are listed in the parenthesized column list preceding it. The sub-query must yield no more than one row when executed. If it yields one row, its column values are assigned to the target columns; if it yields no rows, NULL values are assigned to the target columns. The sub-query can refer to old values of the current row of the table being updated.\nA table expression allowing columns from other tables to appear in theWHEREcondition and update expressions. This uses the same syntax as theFROMclause of aSELECTstatement; for example, an alias for the table name can be specified. Do not repeat the target table as afrom_itemunless you intend a self-join (in which case it must appear with an alias in thefrom_item).\nAn expression that returns a value of typeboolean. Only rows for which this expression returnstruewill be updated.\nThe name of the cursor to use in aWHERE CURRENT",
    "metadata": {
      "doc_name": "sql-update",
      "section_title": "Parameters",
      "url": "https://www.postgresql.org/docs/16/sql-update.html"
    }
  },
  {
    "chunk_id": 4,
    "text": "theWHEREcondition and update expressions. This uses the same syntax as theFROMclause of aSELECTstatement; for example, an alias for the table name can be specified. Do not repeat the target table as afrom_itemunless you intend a self-join (in which case it must appear with an alias in thefrom_item).\nAn expression that returns a value of typeboolean. Only rows for which this expression returnstruewill be updated.\nThe name of the cursor to use in aWHERE CURRENT OFcondition. The row to be updated is the one most recently fetched from this cursor. The cursor must be a non-grouping query on theUPDATE's target table. Note thatWHERE CURRENT OFcannot be specified together with a Boolean condition. SeeDECLAREfor more information about using cursors withWHERE CURRENT OF.\nAn expression to be computed and returned by theUPDATEcommand after each row is updated. The expression can use any column names of the table named bytable_nameor table(s) listed inFROM. Write*to return all columns.\nA name to use for a returned column.",
    "metadata": {
      "doc_name": "sql-update",
      "section_title": "Parameters",
      "url": "https://www.postgresql.org/docs/16/sql-update.html"
    }
  },
  {
    "chunk_id": 5,
    "text": "On successful completion, anUPDATEcommand returns a command tag of the form\n\n\nCODE:\n\nUPDATE count\n\nThecountis the number of rows updated, including matched rows whose values did not change. Note that the number may be less than the number of rows that matched theconditionwhen updates were suppressed by aBEFORE UPDATEtrigger. Ifcountis 0, no rows were updated by the query (this is not considered an error).\nIf theUPDATEcommand contains aRETURNINGclause, the result will be similar to that of aSELECTstatement containing the columns and values defined in theRETURNINGlist, computed over the row(s) updated by the command.",
    "metadata": {
      "doc_name": "sql-update",
      "section_title": "Outputs",
      "url": "https://www.postgresql.org/docs/16/sql-update.html"
    }
  },
  {
    "chunk_id": 6,
    "text": "When aFROMclause is present, what essentially happens is that the target table is joined to the tables mentioned in thefrom_itemlist, and each output row of the join represents an update operation for the target table. When usingFROMyou should ensure that the join produces at most one output row for each row to be modified. In other words, a target row shouldn't join to more than one row from the other table(s). If it does, then only one of the join rows will be used to update the target row, but which one will be used is not readily predictable.\nBecause of this indeterminacy, referencing other tables only within sub-selects is safer, though often harder to read and slower than using a join.\nIn the case of a partitioned table, updating a row might cause it to no longer satisfy the partition constraint of the containing partition. In that case, if there is some other partition in the partition tree for which this row satisfies its partition constraint, then the row is moved to that partition. If there is no such partition, an error will occur. Behind the scenes, the row movement is actually aDELETEandINSERToperation.\nThere is a possibility that a concurrentUPDATEorDELETEon the row being moved will get a serialization failure error. Suppose session 1 is performing anUPDATEon a partition key, and meanwhile a concurrent session 2 for which this row is visible performs anUPDATEorDELETEoperation on this row. In such case, session 2'sUPDATEorDELETEwill detect the row movement and raise a serialization failure error (which always returns with an SQLSTATE code '40001'). Applications may wish to retry the transaction if this occurs. In the usual case where the table is not partitioned, or where there is no row movement, session 2 would have identified the newly updated row and carried out theUPDATE/DELETEon this new row version.\nNote that while rows can be moved from local partitions to a foreign-table partition (provided the foreign data wrapper supports tuple routing), they cannot be moved from a foreign-table partition to another partition.\nAn attempt of moving a row from one partition to another will fail if a foreign key is found to directly reference an ancestor of the source partition that is not the same as the ancestor that's mentioned in theUPDATEquery.",
    "metadata": {
      "doc_name": "sql-update",
      "section_title": "Notes",
      "url": "https://www.postgresql.org/docs/16/sql-update.html"
    }
  },
  {
    "chunk_id": 7,
    "text": "Change the wordDramatoDramaticin the columnkindof the tablefilms:\n\n\nCODE:\n\nUPDATE films SET kind = 'Dramatic' WHERE kind = 'Drama';\n\nAdjust temperature entries and reset precipitation to its default value in one row of the tableweather:\n\n\nCODE:\n\nUPDATE weather SET temp_lo = temp_lo+1, temp_hi = temp_lo+15, prcp = DEFAULT\n  WHERE city = 'San Francisco' AND date = '2003-07-03';\n\nPerform the same operation and return the updated entries:\n\n\nCODE:\n\nUPDATE weather SET temp_lo = temp_lo+1, temp_hi = temp_lo+15, prcp = DEFAULT\n  WHERE city = 'San Francisco' AND date = '2003-07-03'\n  RETURNING temp_lo, temp_hi, prcp;\n\nUse the alternative column-list syntax to do the same update:\n\n\nCODE:\n\nUPDATE weather SET (temp_lo, temp_hi, prcp) = (temp_lo+1, temp_lo+15, DEFAULT)\n  WHERE city = 'San Francisco' AND date = '2003-07-03';\n\nIncrement the sales count of the salesperson who manages the account for Acme Corporation, using theFROMclause syntax:\n\n\nCODE:\n\nUPDATE employees SET sales_count = sales_count + 1 FROM accounts\n  WHERE accounts.name = 'Acme Corporation'\n  AND employees.id = accounts.sales_person;\n\nPerform the same operation, using a sub-select in theWHEREclause:\n\n\nCODE:\n\nUPDATE employees SET sales_count = sales_count + 1 WHERE id =\n  (SELECT sales_person FROM accounts WHERE name = 'Acme Corporation');\n\nUpdate contact names in an accounts table to match the currently assigned salespeople:\n\n\nCODE:\n\nUPDATE accounts SET (contact_first_name, contact_last_name) =\n    (SELECT first_name, last_name FROM employees\n     WHERE employees.id = accounts.sales_person);\n\nA similar result could be accomplished with a join:\n\n\nCODE:\n\nUPDATE accounts SET contact_first_name = first_name,\n                    contact_last_name = last_name\n  FROM employees WHERE employees.id = accounts.sales_person;\n\nHowever, the second query may give unexpected results ifemployees.idis not a unique key, whereas the first query is guaranteed to raise an error if there are multipleidmatches. Also, if there is no match for a particularaccounts.sales_personentry, the first query will set the corresponding name fields to NULL, whereas the second query will not update that row at all.\nUpdate statistics in a summary",
    "metadata": {
      "doc_name": "sql-update",
      "section_title": "Examples",
      "url": "https://www.postgresql.org/docs/16/sql-update.html"
    }
  },
  {
    "chunk_id": 8,
    "text": "_name,\n                    contact_last_name = last_name\n  FROM employees WHERE employees.id = accounts.sales_person;\n\nHowever, the second query may give unexpected results ifemployees.idis not a unique key, whereas the first query is guaranteed to raise an error if there are multipleidmatches. Also, if there is no match for a particularaccounts.sales_personentry, the first query will set the corresponding name fields to NULL, whereas the second query will not update that row at all.\nUpdate statistics in a summary table to match the current data:\n\n\nCODE:\n\nUPDATE summary s SET (sum_x, sum_y, avg_x, avg_y) =\n    (SELECT sum(x), sum(y), avg(x), avg(y) FROM data d\n     WHERE d.group_id = s.group_id);\n\nAttempt to insert a new stock item along with the quantity of stock. If the item already exists, instead update the stock count of the existing item. To do this without failing the entire transaction, use savepoints:\n\n\nCODE:\n\nBEGIN;\n-- other operations\nSAVEPOINT sp1;\nINSERT INTO wines VALUES('Chateau Lafite 2003', '24');\n-- Assume the above fails because of a unique key violation,\n-- so now we issue these commands:\nROLLBACK TO sp1;\nUPDATE wines SET stock = stock + 24 WHERE winename = 'Chateau Lafite 2003';\n-- continue with other operations, and eventually\nCOMMIT;\n\nChange thekindcolumn of the tablefilmsin the row on which the cursorc_filmsis currently positioned:\n\n\nCODE:\n\nUPDATE films SET kind = 'Dramatic' WHERE CURRENT OF c_films;",
    "metadata": {
      "doc_name": "sql-update",
      "section_title": "Examples",
      "url": "https://www.postgresql.org/docs/16/sql-update.html"
    }
  },
  {
    "chunk_id": 9,
    "text": "This command conforms to theSQLstandard, except that theFROMandRETURNINGclauses arePostgreSQLextensions, as is the ability to useWITHwithUPDATE.\nSome other database systems offer aFROMoption in which the target table is supposed to be listed again withinFROM. That is not howPostgreSQLinterpretsFROM. Be careful when porting applications that use this extension.\nAccording to the standard, the source value for a parenthesized sub-list of target column names can be any row-valued expression yielding the correct number of columns.PostgreSQLonly allows the source value to be arow constructoror a sub-SELECT. An individual column's updated value can be specified asDEFAULTin the row-constructor case, but not inside a sub-SELECT.",
    "metadata": {
      "doc_name": "sql-update",
      "section_title": "Compatibility",
      "url": "https://www.postgresql.org/docs/16/sql-update.html"
    }
  },
  {
    "chunk_id": 0,
    "text": "VACUUM — garbage-collect and optionally analyze a database",
    "metadata": {
      "doc_name": "sql-vacuum",
      "section_title": "VACUUM",
      "url": "https://www.postgresql.org/docs/16/sql-vacuum.html"
    }
  },
  {
    "chunk_id": 1,
    "text": "CODE:\n\nVACUUM [ ( option [, ...] ) ] [ table_and_columns [, ...] ]\nVACUUM [ FULL ] [ FREEZE ] [ VERBOSE ] [ ANALYZE ] [ table_and_columns [, ...] ]\n\nwhere option can be one of:\n\n    FULL [ boolean ]\n    FREEZE [ boolean ]\n    VERBOSE [ boolean ]\n    ANALYZE [ boolean ]\n    DISABLE_PAGE_SKIPPING [ boolean ]\n    SKIP_LOCKED [ boolean ]\n    INDEX_CLEANUP { AUTO | ON | OFF }\n    PROCESS_MAIN [ boolean ]\n    PROCESS_TOAST [ boolean ]\n    TRUNCATE [ boolean ]\n    PARALLEL integer\n    SKIP_DATABASE_STATS [ boolean ]\n    ONLY_DATABASE_STATS [ boolean ]\n    BUFFER_USAGE_LIMIT size\n\nand table_and_columns is:\n\n    table_name [ ( column_name [, ...] ) ]",
    "metadata": {
      "doc_name": "sql-vacuum",
      "section_title": "Synopsis",
      "url": "https://www.postgresql.org/docs/16/sql-vacuum.html"
    }
  },
  {
    "chunk_id": 2,
    "text": "VACUUMreclaims storage occupied by dead tuples. In normalPostgreSQLoperation, tuples that are deleted or obsoleted by an update are not physically removed from their table; they remain present until aVACUUMis done. Therefore it's necessary to doVACUUMperiodically, especially on frequently-updated tables.\nWithout atable_and_columnslist,VACUUMprocesses every table and materialized view in the current database that the current user has permission to vacuum. With a list,VACUUMprocesses only those table(s).\nVACUUM ANALYZEperforms aVACUUMand then anANALYZEfor each selected table. This is a handy combination form for routine maintenance scripts. SeeANALYZEfor more details about its processing.\nPlainVACUUM(withoutFULL) simply reclaims space and makes it available for re-use. This form of the command can operate in parallel with normal reading and writing of the table, as an exclusive lock is not obtained. However, extra space is not returned to the operating system (in most cases); it's just kept available for re-use within the same table. It also allows us to leverage multiple CPUs in order to process indexes. This feature is known asparallel vacuum. To disable this feature, one can usePARALLELoption and specify parallel workers as zero.VACUUM FULLrewrites the entire contents of the table into a new disk file with no extra space, allowing unused space to be returned to the operating system. This form is much slower and requires anACCESS EXCLUSIVElock on each table while it is being processed.\nWhen the option list is surrounded by parentheses, the options can be written in any order. Without parentheses, options must be specified in exactly the order shown above. The parenthesized syntax was added inPostgreSQL9.0; the unparenthesized syntax is deprecated.",
    "metadata": {
      "doc_name": "sql-vacuum",
      "section_title": "Description",
      "url": "https://www.postgresql.org/docs/16/sql-vacuum.html"
    }
  },
  {
    "chunk_id": 3,
    "text": "Selects“full”vacuum, which can reclaim more space, but takes much longer and exclusively locks the table. This method also requires extra disk space, since it writes a new copy of the table and doesn't release the old copy until the operation is complete. Usually this should only be used when a significant amount of space needs to be reclaimed from within the table.\nSelects aggressive“freezing”of tuples. SpecifyingFREEZEis equivalent to performingVACUUMwith thevacuum_freeze_min_ageandvacuum_freeze_table_ageparameters set to zero. Aggressive freezing is always performed when the table is rewritten, so this option is redundant whenFULLis specified.\nPrints a detailed vacuum activity report for each table.\nUpdates statistics used by the planner to determine the most efficient way to execute a query.\nNormally,VACUUMwill skip pages based on thevisibility map. Pages where all tuples are known to be frozen can always be skipped, and those where all tuples are known to be visible to all transactions may be skipped except when performing an aggressive vacuum. Furthermore, except when performing an aggressive vacuum, some pages may be skipped in order to avoid waiting for other sessions to finish using them. This option disables all page-skipping behavior, and is intended to be used only when the contents of the visibility map are suspect, which should happen only if there is a hardware or software issue causing database corruption.\nSpecifies thatVACUUMshould not wait for any conflicting locks to be released when beginning work on a relation: if a relation cannot be locked immediately without waiting, the relation is skipped. Note that even with this option,VACUUMmay still block when opening the relation's indexes. Additionally,VACUUM ANALYZEmay still block when acquiring sample rows from partitions, table inheritance children, and some types of foreign tables. Also, whileVACUUMordinarily processes all partitions of specified partitioned tables, this option will causeVACUUMto skip all partitions if there is a conflicting lock on the partitioned table.\nNormally,VACUUMwill skip index vacuuming when there are very few dead tuples in the table. The cost of processing all of the table's indexes is expected to greatly exceed the benefit of removing dead index tuples when this happens. This option can be used to forceVACUUMto process indexes when there are more than zero dead tuples. The default isAUTO, which allowsVACUUMto skip index",
    "metadata": {
      "doc_name": "sql-vacuum",
      "section_title": "Parameters",
      "url": "https://www.postgresql.org/docs/16/sql-vacuum.html"
    }
  },
  {
    "chunk_id": 4,
    "text": "to skip all partitions if there is a conflicting lock on the partitioned table.\nNormally,VACUUMwill skip index vacuuming when there are very few dead tuples in the table. The cost of processing all of the table's indexes is expected to greatly exceed the benefit of removing dead index tuples when this happens. This option can be used to forceVACUUMto process indexes when there are more than zero dead tuples. The default isAUTO, which allowsVACUUMto skip index vacuuming when appropriate. IfINDEX_CLEANUPis set toON,VACUUMwill conservatively remove all dead tuples from indexes. This may be useful for backwards compatibility with earlier releases ofPostgreSQLwhere this was the standard behavior.\nINDEX_CLEANUPcan also be set toOFFto forceVACUUMtoalwaysskip index vacuuming, even when there are many dead tuples in the table. This may be useful when it is necessary to makeVACUUMrun as quickly as possible to avoid imminent transaction ID wraparound (seeSection 25.1.5). However, the wraparound failsafe mechanism controlled byvacuum_failsafe_agewill generally trigger automatically to avoid transaction ID wraparound failure, and should be preferred. If index cleanup is not performed regularly, performance may suffer, because as the table is modified indexes will accumulate dead tuples and the table itself will accumulate dead line pointers that cannot be removed until index cleanup is completed.\nThis option has no effect for tables that have no index and is ignored if theFULLoption is used. It also has no effect on the transaction ID wraparound failsafe mechanism. When triggered it will skip index vacuuming, even whenINDEX_CLEANUPis set toON.\nSpecifies thatVACUUMshould attempt to process the main relation. This is usually the desired behavior and is the default. Setting this option to false may be useful when it is only necessary to vacuum a relation's correspondingTOASTtable.\nSpecifies thatVACUUMshould attempt to process the correspondingTOASTtable for each relation, if one exists. This is usually the desired behavior and is the default. Setting this option to false may be useful when it is only necessary to vacuum the main relation. This option is required when theFULLoption is used.\nSpecifies thatVACUUMshould attempt to truncate off any empty pages at the end of the table and allow the disk space for the truncated pages to be returned to the operating system. This is",
    "metadata": {
      "doc_name": "sql-vacuum",
      "section_title": "Parameters",
      "url": "https://www.postgresql.org/docs/16/sql-vacuum.html"
    }
  },
  {
    "chunk_id": 5,
    "text": "ACUUMshould attempt to process the correspondingTOASTtable for each relation, if one exists. This is usually the desired behavior and is the default. Setting this option to false may be useful when it is only necessary to vacuum the main relation. This option is required when theFULLoption is used.\nSpecifies thatVACUUMshould attempt to truncate off any empty pages at the end of the table and allow the disk space for the truncated pages to be returned to the operating system. This is normally the desired behavior and is the default unless thevacuum_truncateoption has been set to false for the table to be vacuumed. Setting this option to false may be useful to avoidACCESS EXCLUSIVElock on the table that the truncation requires. This option is ignored if theFULLoption is used.\nPerform index vacuum and index cleanup phases ofVACUUMin parallel usingintegerbackground workers (for the details of each vacuum phase, please refer toTable 28.45). The number of workers used to perform the operation is equal to the number of indexes on the relation that support parallel vacuum which is limited by the number of workers specified withPARALLELoption if any which is further limited bymax_parallel_maintenance_workers. An index can participate in parallel vacuum if and only if the size of the index is more thanmin_parallel_index_scan_size. Please note that it is not guaranteed that the number of parallel workers specified inintegerwill be used during execution. It is possible for a vacuum to run with fewer workers than specified, or even with no workers at all. Only one worker can be used per index. So parallel workers are launched only when there are at least2indexes in the table. Workers for vacuum are launched before the start of each phase and exit at the end of the phase. These behaviors might change in a future release. This option can't be used with theFULLoption.\nSpecifies thatVACUUMshould skip updating the database-wide statistics about oldest unfrozen XIDs. NormallyVACUUMwill update these statistics once at the end of the command. However, this can take awhile in a database with a very large number of tables, and it will accomplish nothing unless the table that had contained the oldest unfrozen XID was among those vacuumed. Moreover, if multipleVACUUMcommands are issued in parallel, only one of them can update the database-wide statistics at a time. Therefore, if an application intends to issue a series of manyV",
    "metadata": {
      "doc_name": "sql-vacuum",
      "section_title": "Parameters",
      "url": "https://www.postgresql.org/docs/16/sql-vacuum.html"
    }
  },
  {
    "chunk_id": 6,
    "text": "IDs. NormallyVACUUMwill update these statistics once at the end of the command. However, this can take awhile in a database with a very large number of tables, and it will accomplish nothing unless the table that had contained the oldest unfrozen XID was among those vacuumed. Moreover, if multipleVACUUMcommands are issued in parallel, only one of them can update the database-wide statistics at a time. Therefore, if an application intends to issue a series of manyVACUUMcommands, it can be helpful to set this option in all but the last such command; or set it in all the commands and separately issueVACUUM (ONLY_DATABASE_STATS)afterwards.\nSpecifies thatVACUUMshould do nothing except update the database-wide statistics about oldest unfrozen XIDs. When this option is specified, thetable_and_columnslist must be empty, and no other option may be enabled exceptVERBOSE.\nSpecifies theBuffer Access Strategyring buffer size forVACUUM. This size is used to calculate the number of shared buffers which will be reused as part of this strategy.0disables use of aBuffer Access Strategy. IfANALYZEis also specified, theBUFFER_USAGE_LIMITvalue is used for both the vacuum and analyze stages. This option can't be used with theFULLoption except ifANALYZEis also specified. When this option is not specified,VACUUMuses the value fromvacuum_buffer_usage_limit. Higher settings can allowVACUUMto run more quickly, but having too large a setting may cause too many other useful pages to be evicted from shared buffers. The minimum value is128 kBand the maximum value is16 GB.\nSpecifies whether the selected option should be turned on or off. You can writeTRUE,ON, or1to enable the option, andFALSE,OFF, or0to disable it. Thebooleanvalue can also be omitted, in which caseTRUEis assumed.\nSpecifies a non-negative integer value passed to the selected option.\nSpecifies an amount of memory in kilobytes. Sizes may also be specified as a string containing the numerical size followed by any one of the following memory units:B(bytes),kB(kilobytes),MB(megabytes),GB(gigabytes), orTB(terabytes).\nThe name (optionally schema-qualified) of a specific table or materialized view to vacuum. If the specified table is a partitioned table, all of its",
    "metadata": {
      "doc_name": "sql-vacuum",
      "section_title": "Parameters",
      "url": "https://www.postgresql.org/docs/16/sql-vacuum.html"
    }
  },
  {
    "chunk_id": 7,
    "text": "a non-negative integer value passed to the selected option.\nSpecifies an amount of memory in kilobytes. Sizes may also be specified as a string containing the numerical size followed by any one of the following memory units:B(bytes),kB(kilobytes),MB(megabytes),GB(gigabytes), orTB(terabytes).\nThe name (optionally schema-qualified) of a specific table or materialized view to vacuum. If the specified table is a partitioned table, all of its leaf partitions are vacuumed.\nThe name of a specific column to analyze. Defaults to all columns. If a column list is specified,ANALYZEmust also be specified.",
    "metadata": {
      "doc_name": "sql-vacuum",
      "section_title": "Parameters",
      "url": "https://www.postgresql.org/docs/16/sql-vacuum.html"
    }
  },
  {
    "chunk_id": 8,
    "text": "WhenVERBOSEis specified,VACUUMemits progress messages to indicate which table is currently being processed. Various statistics about the tables are printed as well.",
    "metadata": {
      "doc_name": "sql-vacuum",
      "section_title": "Outputs",
      "url": "https://www.postgresql.org/docs/16/sql-vacuum.html"
    }
  },
  {
    "chunk_id": 9,
    "text": "To vacuum a table, one must ordinarily be the table's owner or a superuser. However, database owners are allowed to vacuum all tables in their databases, except shared catalogs. (The restriction for shared catalogs means that a true database-wideVACUUMcan only be performed by a superuser.)VACUUMwill skip over any tables that the calling user does not have permission to vacuum.\nVACUUMcannot be executed inside a transaction block.\nFor tables withGINindexes,VACUUM(in any form) also completes any pending index insertions, by moving pending index entries to the appropriate places in the mainGINindex structure. SeeSection 70.4.1for details.\nWe recommend that all databases be vacuumed regularly in order to remove dead rows.PostgreSQLincludes an“autovacuum”facility which can automate routine vacuum maintenance. For more information about automatic and manual vacuuming, seeSection 25.1.\nTheFULLoption is not recommended for routine use, but might be useful in special cases. An example is when you have deleted or updated most of the rows in a table and would like the table to physically shrink to occupy less disk space and allow faster table scans.VACUUM FULLwill usually shrink the table more than a plainVACUUMwould.\nThePARALLELoption is used only for vacuum purposes. If this option is specified with theANALYZEoption, it does not affectANALYZE.\nVACUUMcauses a substantial increase in I/O traffic, which might cause poor performance for other active sessions. Therefore, it is sometimes advisable to use the cost-based vacuum delay feature. For parallel vacuum, each worker sleeps in proportion to the work done by that worker. SeeSection 20.4.4for details.\nEach backend runningVACUUMwithout theFULLoption will report its progress in thepg_stat_progress_vacuumview. Backends runningVACUUM FULLwill instead report their progress in thepg_stat_progress_clusterview. SeeSection 28.4.5andSection 28.4.2for details.",
    "metadata": {
      "doc_name": "sql-vacuum",
      "section_title": "Notes",
      "url": "https://www.postgresql.org/docs/16/sql-vacuum.html"
    }
  },
  {
    "chunk_id": 10,
    "text": "To clean a single tableonek, analyze it for the optimizer and print a detailed vacuum activity report:\n\n\nCODE:\n\nVACUUM (VERBOSE, ANALYZE) onek;",
    "metadata": {
      "doc_name": "sql-vacuum",
      "section_title": "Examples",
      "url": "https://www.postgresql.org/docs/16/sql-vacuum.html"
    }
  },
  {
    "chunk_id": 11,
    "text": "There is noVACUUMstatement in the SQL standard.",
    "metadata": {
      "doc_name": "sql-vacuum",
      "section_title": "Compatibility",
      "url": "https://www.postgresql.org/docs/16/sql-vacuum.html"
    }
  }
]