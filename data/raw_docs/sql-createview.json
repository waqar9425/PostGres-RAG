{
  "doc_name": "sql-createview",
  "url": "https://www.postgresql.org/docs/16/sql-createview.html",
  "sections": [
    {
      "title": "CREATE VIEW",
      "text": "CREATE VIEW — define a new view\n"
    },
    {
      "title": "Synopsis",
      "text": "\n\nCODE:\n\nCREATE [ OR REPLACE ] [ TEMP | TEMPORARY ] [ RECURSIVE ] VIEW name [ ( column_name [, ...] ) ]\n    [ WITH ( view_option_name [= view_option_value] [, ... ] ) ]\n    AS query\n    [ WITH [ CASCADED | LOCAL ] CHECK OPTION ]\n\n"
    },
    {
      "title": "Description",
      "text": "CREATE VIEWdefines a view of a query. The view is not physically materialized. Instead, the query is run every time the view is referenced in a query.\nCREATE OR REPLACE VIEWis similar, but if a view of the same name already exists, it is replaced. The new query must generate the same columns that were generated by the existing view query (that is, the same column names in the same order and with the same data types), but it may add additional columns to the end of the list. The calculations giving rise to the output columns may be completely different.\nIf a schema name is given (for example,CREATE VIEW myschema.myview ...) then the view is created in the specified schema. Otherwise it is created in the current schema. Temporary views exist in a special schema, so a schema name cannot be given when creating a temporary view. The name of the view must be distinct from the name of any other relation (table, sequence, index, view, materialized view, or foreign table) in the same schema.\n"
    },
    {
      "title": "Parameters",
      "text": "If specified, the view is created as a temporary view. Temporary views are automatically dropped at the end of the current session. Existing permanent relations with the same name are not visible to the current session while the temporary view exists, unless they are referenced with schema-qualified names.\nIf any of the tables referenced by the view are temporary, the view is created as a temporary view (whetherTEMPORARYis specified or not).\nCreates a recursive view. The syntax\n\n\nCODE:\n\nCREATE RECURSIVE VIEW [ schema . ] view_name (column_names) AS SELECT ...;\n\nis equivalent to\n\n\nCODE:\n\nCREATE VIEW [ schema . ] view_name AS WITH RECURSIVE view_name (column_names) AS (SELECT ...) SELECT column_names FROM view_name;\n\nA view column name list must be specified for a recursive view.\nThe name (optionally schema-qualified) of a view to be created.\nAn optional list of names to be used for columns of the view. If not given, the column names are deduced from the query.\nThis clause specifies optional parameters for a view; the following parameters are supported:\nThis parameter may be eitherlocalorcascaded, and is equivalent to specifyingWITH [ CASCADED | LOCAL ] CHECK OPTION(see below).\nThis should be used if the view is intended to provide row-level security. SeeSection 41.5for full details.\nThis option causes the underlying base relations to be checked against the privileges of the user of the view rather than the view owner. See the notes below for full details.\nAll of the above options can be changed on existing views usingALTER VIEW.\nASELECTorVALUEScommand which will provide the columns and rows of the view.\nThis option controls the behavior of automatically updatable views. When this option is specified,INSERTandUPDATEcommands on the view will be checked to ensure that new rows satisfy the view-defining condition (that is, the new rows are checked to ensure that they are visible through the view). If they are not, the update will be rejected. If theCHECK OPTIONis not specified,INSERTandUPDATEcommands on the view are allowed to create rows that are not visible through the view. The following check options are supported:\nNew rows are only checked against the conditions defined directly in the view itself. Any conditions defined on underlying base views are not checked (unless they also specify theCHECK OPTION).\nNew rows are checked against the conditions of the view and all underlying base views. If theCHECK OPTIONis specified, and neitherLOCALnorCASCADEDis specified, thenCASCADEDis assumed.\nTheCHECK OPTIONmay not be used withRECURSIVEviews.\nNote that theCHECK OPTIONis only supported on views that are automatically updatable, and do not haveINSTEAD OFtriggers orINSTEADrules. If an automatically updatable view is defined on top of a base view that hasINSTEAD OFtriggers, then theLOCAL CHECK OPTIONmay be used to check the conditions on the automatically updatable view, but the conditions on the base view withINSTEAD OFtriggers will not be checked (a cascaded check option will not cascade down to a trigger-updatable view, and any check options defined directly on a trigger-updatable view will be ignored). If the view or any of its base relations has anINSTEADrule that causes theINSERTorUPDATEcommand to be rewritten, then all check options will be ignored in the rewritten query, including any checks from automatically updatable views defined on top of the relation with theINSTEADrule.\n"
    },
    {
      "title": "Notes",
      "text": "Use theDROP VIEWstatement to drop views.\nBe careful that the names and types of the view's columns will be assigned the way you want. For example:\n\n\nCODE:\n\nCREATE VIEW vista AS SELECT 'Hello World';\n\nis bad form because the column name defaults to?column?; also, the column data type defaults totext, which might not be what you wanted. Better style for a string literal in a view's result is something like:\n\n\nCODE:\n\nCREATE VIEW vista AS SELECT text 'Hello World' AS hello;\n\nBy default, access to the underlying base relations referenced in the view is determined by the permissions of the view owner. In some cases, this can be used to provide secure but restricted access to the underlying tables. However, not all views are secure against tampering; seeSection 41.5for details.\nIf the view has thesecurity_invokerproperty set totrue, access to the underlying base relations is determined by the permissions of the user executing the query, rather than the view owner. Thus, the user of a security invoker view must have the relevant permissions on the view and its underlying base relations.\nIf any of the underlying base relations is a security invoker view, it will be treated as if it had been accessed directly from the original query. Thus, a security invoker view will always check its underlying base relations using the permissions of the current user, even if it is accessed from a view without thesecurity_invokerproperty.\nIf any of the underlying base relations hasrow-level securityenabled, then by default, the row-level security policies of the view owner are applied, and access to any additional relations referred to by those policies is determined by the permissions of the view owner. However, if the view hassecurity_invokerset totrue, then the policies and permissions of the invoking user are used instead, as if the base relations had been referenced directly from the query using the view.\nFunctions called in the view are treated the same as if they had been called directly from the query using the view. Therefore, the user of a view must have permissions to call all functions used by the view. Functions in the view are executed with the privileges of the user executing the query or the function owner, depending on whether the functions are defined asSECURITY INVOKERorSECURITY DEFINER. Thus, for example, callingCURRENT_USERdirectly in a view will always return the invoking user, not the view owner. This is not affected by the view'ssecurity_invokersetting, and so a view withsecurity_invokerset tofalseisnotequivalent to aSECURITY DEFINERfunction and those concepts should not be confused.\nThe user creating or replacing a view must haveUSAGEprivileges on any schemas referred to in the view query, in order to look up the referenced objects in those schemas. Note, however, that this lookup only happens when the view is created or replaced. Therefore, the user of the view only requires theUSAGEprivilege on the schema containing the view, not on the schemas referred to in the view query, even for a security invoker view.\nWhenCREATE OR REPLACE VIEWis used on an existing view, only the view's defining SELECT rule, plus anyWITH ( ... )parameters and itsCHECK OPTIONare changed. Other view properties, including ownership, permissions, and non-SELECT rules, remain unchanged. You must own the view to replace it (this includes being a member of the owning role).\n"
    },
    {
      "title": "Updatable Views",
      "text": "Simple views are automatically updatable: the system will allowINSERT,UPDATEandDELETEstatements to be used on the view in the same way as on a regular table. A view is automatically updatable if it satisfies all of the following conditions:\nThe view must have exactly one entry in itsFROMlist, which must be a table or another updatable view.\nThe view definition must not containWITH,DISTINCT,GROUP BY,HAVING,LIMIT, orOFFSETclauses at the top level.\nThe view definition must not contain set operations (UNION,INTERSECTorEXCEPT) at the top level.\nThe view's select list must not contain any aggregates, window functions or set-returning functions.\nAn automatically updatable view may contain a mix of updatable and non-updatable columns. A column is updatable if it is a simple reference to an updatable column of the underlying base relation; otherwise the column is read-only, and an error will be raised if anINSERTorUPDATEstatement attempts to assign a value to it.\nIf the view is automatically updatable the system will convert anyINSERT,UPDATEorDELETEstatement on the view into the corresponding statement on the underlying base relation.INSERTstatements that have anON CONFLICT UPDATEclause are fully supported.\nIf an automatically updatable view contains aWHEREcondition, the condition restricts which rows of the base relation are available to be modified byUPDATEandDELETEstatements on the view. However, anUPDATEis allowed to change a row so that it no longer satisfies theWHEREcondition, and thus is no longer visible through the view. Similarly, anINSERTcommand can potentially insert base-relation rows that do not satisfy theWHEREcondition and thus are not visible through the view (ON CONFLICT UPDATEmay similarly affect an existing row not visible through the view). TheCHECK OPTIONmay be used to preventINSERTandUPDATEcommands from creating such rows that are not visible through the view.\nIf an automatically updatable view is marked with thesecurity_barrierproperty then all the view'sWHEREconditions (and any conditions using operators which are marked asLEAKPROOF) will always be evaluated before any conditions that a user of the view has added. SeeSection 41.5for full details. Note that, due to this, rows which are not ultimately returned (because they do not pass the user'sWHEREconditions) may still end up being locked.EXPLAINcan be used to see which conditions are applied at the relation level (and therefore do not lock rows) and which are not.\nA more complex view that does not satisfy all these conditions is read-only by default: the system will not allow an insert, update, or delete on the view. You can get the effect of an updatable view by creatingINSTEAD OFtriggers on the view, which must convert attempted inserts, etc. on the view into appropriate actions on other tables. For more information seeCREATE TRIGGER. Another possibility is to create rules (seeCREATE RULE), but in practice triggers are easier to understand and use correctly.\nNote that the user performing the insert, update or delete on the view must have the corresponding insert, update or delete privilege on the view. In addition, by default, the view's owner must have the relevant privileges on the underlying base relations, whereas the user performing the update does not need any permissions on the underlying base relations (seeSection 41.5). However, if the view hassecurity_invokerset totrue, the user performing the update, rather than the view owner, must have the relevant privileges on the underlying base relations.\n"
    },
    {
      "title": "Examples",
      "text": "Create a view consisting of all comedy films:\n\n\nCODE:\n\nCREATE VIEW comedies AS\n    SELECT *\n    FROM films\n    WHERE kind = 'Comedy';\n\nThis will create a view containing the columns that are in thefilmtable at the time of view creation. Though*was used to create the view, columns added later to the table will not be part of the view.\nCreate a view withLOCAL CHECK OPTION:\n\n\nCODE:\n\nCREATE VIEW universal_comedies AS\n    SELECT *\n    FROM comedies\n    WHERE classification = 'U'\n    WITH LOCAL CHECK OPTION;\n\nThis will create a view based on thecomediesview, showing only films withkind = 'Comedy'andclassification = 'U'. Any attempt toINSERTorUPDATEa row in the view will be rejected if the new row doesn't haveclassification = 'U', but the filmkindwill not be checked.\nCreate a view withCASCADED CHECK OPTION:\n\n\nCODE:\n\nCREATE VIEW pg_comedies AS\n    SELECT *\n    FROM comedies\n    WHERE classification = 'PG'\n    WITH CASCADED CHECK OPTION;\n\nThis will create a view that checks both thekindandclassificationof new rows.\nCreate a view with a mix of updatable and non-updatable columns:\n\n\nCODE:\n\nCREATE VIEW comedies AS\n    SELECT f.*,\n           country_code_to_name(f.country_code) AS country,\n           (SELECT avg(r.rating)\n            FROM user_ratings r\n            WHERE r.film_id = f.id) AS avg_rating\n    FROM films f\n    WHERE f.kind = 'Comedy';\n\nThis view will supportINSERT,UPDATEandDELETE. All the columns from thefilmstable will be updatable, whereas the computed columnscountryandavg_ratingwill be read-only.\nCreate a recursive view consisting of the numbers from 1 to 100:\n\n\nCODE:\n\nCREATE RECURSIVE VIEW public.nums_1_100 (n) AS\n    VALUES (1)\nUNION ALL\n    SELECT n+1 FROM nums_1_100 WHERE n < 100;\n\nNotice that although the recursive view's name is schema-qualified in thisCREATE, its internal self-reference is not schema-qualified. This is because the implicitly-created CTE's name cannot be schema-qualified.\n"
    },
    {
      "title": "Compatibility",
      "text": "CREATE OR REPLACE VIEWis aPostgreSQLlanguage extension. So is the concept of a temporary view. TheWITH ( ... )clause is an extension as well, as are security barrier views and security invoker views.\n"
    }
  ]
}