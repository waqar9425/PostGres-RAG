{
  "doc_name": "sql-insert",
  "url": "https://www.postgresql.org/docs/16/sql-insert.html",
  "sections": [
    {
      "title": "INSERT",
      "text": "INSERT — create new rows in a table\n"
    },
    {
      "title": "Synopsis",
      "text": "\n\nCODE:\n\n[ WITH [ RECURSIVE ] with_query [, ...] ]\nINSERT INTO table_name [ AS alias ] [ ( column_name [, ...] ) ]\n    [ OVERRIDING { SYSTEM | USER } VALUE ]\n    { DEFAULT VALUES | VALUES ( { expression | DEFAULT } [, ...] ) [, ...] | query }\n    [ ON CONFLICT [ conflict_target ] conflict_action ]\n    [ RETURNING { * | output_expression [ [ AS ] output_name ] } [, ...] ]\n\nwhere conflict_target can be one of:\n\n    ( { index_column_name | ( index_expression ) } [ COLLATE collation ] [ opclass ] [, ...] ) [ WHERE index_predicate ]\n    ON CONSTRAINT constraint_name\n\nand conflict_action is one of:\n\n    DO NOTHING\n    DO UPDATE SET { column_name = { expression | DEFAULT } |\n                    ( column_name [, ...] ) = [ ROW ] ( { expression | DEFAULT } [, ...] ) |\n                    ( column_name [, ...] ) = ( sub-SELECT )\n                  } [, ...]\n              [ WHERE condition ]\n\n"
    },
    {
      "title": "Description",
      "text": "INSERTinserts new rows into a table. One can insert one or more rows specified by value expressions, or zero or more rows resulting from a query.\nThe target column names can be listed in any order. If no list of column names is given at all, the default is all the columns of the table in their declared order; or the firstNcolumn names, if there are onlyNcolumns supplied by theVALUESclause orquery. The values supplied by theVALUESclause orqueryare associated with the explicit or implicit column list left-to-right.\nEach column not present in the explicit or implicit column list will be filled with a default value, either its declared default value or null if there is none.\nIf the expression for any column is not of the correct data type, automatic type conversion will be attempted.\nINSERTinto tables that lack unique indexes will not be blocked by concurrent activity. Tables with unique indexes might block if concurrent sessions perform actions that lock or modify rows matching the unique index values being inserted; the details are covered inSection 64.5.ON CONFLICTcan be used to specify an alternative action to raising a unique constraint or exclusion constraint violation error. (SeeON CONFLICT Clausebelow.)\nThe optionalRETURNINGclause causesINSERTto compute and return value(s) based on each row actually inserted (or updated, if anON CONFLICT DO UPDATEclause was used). This is primarily useful for obtaining values that were supplied by defaults, such as a serial sequence number. However, any expression using the table's columns is allowed. The syntax of theRETURNINGlist is identical to that of the output list ofSELECT. Only rows that were successfully inserted or updated will be returned. For example, if a row was locked but not updated because anON CONFLICT DO UPDATE ... WHEREclauseconditionwas not satisfied, the row will not be returned.\nYou must haveINSERTprivilege on a table in order to insert into it. IfON CONFLICT DO UPDATEis present,UPDATEprivilege on the table is also required.\nIf a column list is specified, you only needINSERTprivilege on the listed columns. Similarly, whenON CONFLICT DO UPDATEis specified, you only needUPDATEprivilege on the column(s) that are listed to be updated. However,ON CONFLICT DO UPDATEalso requiresSELECTprivilege on any column whose values are read in theON CONFLICT DO UPDATEexpressions orcondition.\nUse of theRETURNINGclause requiresSELECTprivilege on all columns mentioned inRETURNING. If you use thequeryclause to insert rows from a query, you of course need to haveSELECTprivilege on any table or column used in the query.\n"
    },
    {
      "title": "Inserting",
      "text": "This section covers parameters that may be used when only inserting new rows. Parametersexclusivelyused with theON CONFLICTclause are described separately.\nTheWITHclause allows you to specify one or more subqueries that can be referenced by name in theINSERTquery. SeeSection 7.8andSELECTfor details.\nIt is possible for thequery(SELECTstatement) to also contain aWITHclause. In such a case both sets ofwith_querycan be referenced within thequery, but the second one takes precedence since it is more closely nested.\nThe name (optionally schema-qualified) of an existing table.\nA substitute name fortable_name. When an alias is provided, it completely hides the actual name of the table. This is particularly useful whenON CONFLICT DO UPDATEtargets a table namedexcluded, since that will otherwise be taken as the name of the special table representing the row proposed for insertion.\nThe name of a column in the table named bytable_name. The column name can be qualified with a subfield name or array subscript, if needed. (Inserting into only some fields of a composite column leaves the other fields null.) When referencing a column withON CONFLICT DO UPDATE, do not include the table's name in the specification of a target column. For example,INSERT INTO table_name ... ON CONFLICT DO UPDATE SET table_name.col = 1is invalid (this follows the general behavior forUPDATE).\nIf this clause is specified, then any values supplied for identity columns will override the default sequence-generated values.\nFor an identity column defined asGENERATED ALWAYS, it is an error to insert an explicit value (other thanDEFAULT) without specifying eitherOVERRIDING SYSTEM VALUEorOVERRIDING USER VALUE. (For an identity column defined asGENERATED BY DEFAULT,OVERRIDING SYSTEM VALUEis the normal behavior and specifying it does nothing, butPostgreSQLallows it as an extension.)\nIf this clause is specified, then any values supplied for identity columns are ignored and the default sequence-generated values are applied.\nThis clause is useful for example when copying values between tables. WritingINSERT INTO tbl2 OVERRIDING USER VALUE SELECT * FROM tbl1will copy fromtbl1all columns that are not identity columns intbl2while values for the identity columns intbl2will be generated by the sequences associated withtbl2.\nAll columns will be filled with their default values, as ifDEFAULTwere explicitly specified for each column. (AnOVERRIDINGclause is not permitted in this form.)\nAn expression or value to assign to the corresponding column.\nThe corresponding column will be filled with its default value. An identity column will be filled with a new value generated by the associated sequence. For a generated column, specifying this is permitted but merely specifies the normal behavior of computing the column from its generation expression.\nA query (SELECTstatement) that supplies the rows to be inserted. Refer to theSELECTstatement for a description of the syntax.\nAn expression to be computed and returned by theINSERTcommand after each row is inserted or updated. The expression can use any column names of the table named bytable_name. Write*to return all columns of the inserted or updated row(s).\nA name to use for a returned column.\n"
    },
    {
      "title": "ON CONFLICTClause",
      "text": "The optionalON CONFLICTclause specifies an alternative action to raising a unique violation or exclusion constraint violation error. For each individual row proposed for insertion, either the insertion proceeds, or, if anarbiterconstraint or index specified byconflict_targetis violated, the alternativeconflict_actionis taken.ON CONFLICT DO NOTHINGsimply avoids inserting a row as its alternative action.ON CONFLICT DO UPDATEupdates the existing row that conflicts with the row proposed for insertion as its alternative action.\nconflict_targetcan performunique index inference. When performing inference, it consists of one or moreindex_column_namecolumns and/orindex_expressionexpressions, and an optionalindex_predicate. Alltable_nameunique indexes that, without regard to order, contain exactly theconflict_target-specified columns/expressions are inferred (chosen) as arbiter indexes. If anindex_predicateis specified, it must, as a further requirement for inference, satisfy arbiter indexes. Note that this means a non-partial unique index (a unique index without a predicate) will be inferred (and thus used byON CONFLICT) if such an index satisfying every other criteria is available. If an attempt at inference is unsuccessful, an error is raised.\nON CONFLICT DO UPDATEguarantees an atomicINSERTorUPDATEoutcome; provided there is no independent error, one of those two outcomes is guaranteed, even under high concurrency. This is also known asUPSERT—“UPDATE or INSERT”.\nSpecifies which conflictsON CONFLICTtakes the alternative action on by choosingarbiter indexes. Either performsunique index inference, or names a constraint explicitly. ForON CONFLICT DO NOTHING, it is optional to specify aconflict_target; when omitted, conflicts with all usable constraints (and unique indexes) are handled. ForON CONFLICT DO UPDATE, aconflict_targetmustbe provided.\nconflict_actionspecifies an alternativeON CONFLICTaction. It can be eitherDO NOTHING, or aDO UPDATEclause specifying the exact details of theUPDATEaction to be performed in case of a conflict. TheSETandWHEREclauses inON CONFLICT DO UPDATEhave access to the existing row using the table's name (or an alias), and to the row proposed for insertion using the specialexcludedtable.SELECTprivilege is required on any column in the target table where correspondingexcludedcolumns are read.\nNote that the effects of all per-rowBEFORE INSERTtriggers are reflected inexcludedvalues, since those effects may have contributed to the row being excluded from insertion.\nThe name of atable_namecolumn. Used to infer arbiter indexes. FollowsCREATE INDEXformat.SELECTprivilege onindex_column_nameis required.\nSimilar toindex_column_name, but used to infer expressions ontable_namecolumns appearing within index definitions (not simple columns). FollowsCREATE INDEXformat.SELECTprivilege on any column appearing withinindex_expressionis required.\nWhen specified, mandates that correspondingindex_column_nameorindex_expressionuse a particular collation in order to be matched during inference. Typically this is omitted, as collations usually do not affect whether or not a constraint violation occurs. FollowsCREATE INDEXformat.\nWhen specified, mandates that correspondingindex_column_nameorindex_expressionuse particular operator class in order to be matched during inference. Typically this is omitted, as theequalitysemantics are often equivalent across a type's operator classes anyway, or because it's sufficient to trust that the defined unique indexes have the pertinent definition of equality. FollowsCREATE INDEXformat.\nUsed to allow inference of partial unique indexes. Any indexes that satisfy the predicate (which need not actually be partial indexes) can be inferred. FollowsCREATE INDEXformat.SELECTprivilege on any column appearing withinindex_predicateis required.\nExplicitly specifies an arbiterconstraintby name, rather than inferring a constraint or index.\nAn expression that returns a value of typeboolean. Only rows for which this expression returnstruewill be updated, although all rows will be locked when theON CONFLICT DO UPDATEaction is taken. Note thatconditionis evaluated last, after a conflict has been identified as a candidate to update.\nNote that exclusion constraints are not supported as arbiters withON CONFLICT DO UPDATE. In all cases, onlyNOT DEFERRABLEconstraints and unique indexes are supported as arbiters.\nINSERTwith anON CONFLICT DO UPDATEclause is a“deterministic”statement. This means that the command will not be allowed to affect any single existing row more than once; a cardinality violation error will be raised when this situation arises. Rows proposed for insertion should not duplicate each other in terms of attributes constrained by an arbiter index or constraint.\nNote that it is currently not supported for theON CONFLICT DO UPDATEclause of anINSERTapplied to a partitioned table to update the partition key of a conflicting row such that it requires the row be moved to a new partition.\n"
    },
    {
      "title": "Tip",
      "text": "It is often preferable to use unique index inference rather than naming a constraint directly usingON CONFLICT ON CONSTRAINTconstraint_name. Inference will continue to work correctly when the underlying index is replaced by another more or less equivalent index in an overlapping way, for example when usingCREATE UNIQUE INDEX ... CONCURRENTLYbefore dropping the index being replaced.\n"
    },
    {
      "title": "Warning",
      "text": "WhileCREATE INDEX CONCURRENTLYorREINDEX CONCURRENTLYis running on a unique index,INSERT ... ON CONFLICTstatements on the same table may unexpectedly fail with a unique violation.\n"
    },
    {
      "title": "Outputs",
      "text": "On successful completion, anINSERTcommand returns a command tag of the form\n\n\nCODE:\n\nINSERT oid count\n\nThecountis the number of rows inserted or updated.oidis always 0 (it used to be theOIDassigned to the inserted row ifcountwas exactly one and the target table was declaredWITH OIDSand 0 otherwise, but creating a tableWITH OIDSis not supported anymore).\nIf theINSERTcommand contains aRETURNINGclause, the result will be similar to that of aSELECTstatement containing the columns and values defined in theRETURNINGlist, computed over the row(s) inserted or updated by the command.\n"
    },
    {
      "title": "Notes",
      "text": "If the specified table is a partitioned table, each row is routed to the appropriate partition and inserted into it. If the specified table is a partition, an error will occur if one of the input rows violates the partition constraint.\nYou may also wish to consider usingMERGE, since that allows mixingINSERT,UPDATE, andDELETEwithin a single statement. SeeMERGE.\n"
    },
    {
      "title": "Examples",
      "text": "Insert a single row into tablefilms:\n\n\nCODE:\n\nINSERT INTO films VALUES\n    ('UA502', 'Bananas', 105, '1971-07-13', 'Comedy', '82 minutes');\n\nIn this example, thelencolumn is omitted and therefore it will have the default value:\n\n\nCODE:\n\nINSERT INTO films (code, title, did, date_prod, kind)\n    VALUES ('T_601', 'Yojimbo', 106, '1961-06-16', 'Drama');\n\nThis example uses theDEFAULTclause for the date columns rather than specifying a value:\n\n\nCODE:\n\nINSERT INTO films VALUES\n    ('UA502', 'Bananas', 105, DEFAULT, 'Comedy', '82 minutes');\nINSERT INTO films (code, title, did, date_prod, kind)\n    VALUES ('T_601', 'Yojimbo', 106, DEFAULT, 'Drama');\n\nTo insert a row consisting entirely of default values:\n\n\nCODE:\n\nINSERT INTO films DEFAULT VALUES;\n\nTo insert multiple rows using the multirowVALUESsyntax:\n\n\nCODE:\n\nINSERT INTO films (code, title, did, date_prod, kind) VALUES\n    ('B6717', 'Tampopo', 110, '1985-02-10', 'Comedy'),\n    ('HG120', 'The Dinner Game', 140, DEFAULT, 'Comedy');\n\nThis example inserts some rows into tablefilmsfrom a tabletmp_filmswith the same column layout asfilms:\n\n\nCODE:\n\nINSERT INTO films SELECT * FROM tmp_films WHERE date_prod < '2004-05-07';\n\nThis example inserts into array columns:\n\n\nCODE:\n\n-- Create an empty 3x3 gameboard for noughts-and-crosses\nINSERT INTO tictactoe (game, board[1:3][1:3])\n    VALUES (1, '{{\" \",\" \",\" \"},{\" \",\" \",\" \"},{\" \",\" \",\" \"}}');\n-- The subscripts in the above example aren't really needed\nINSERT INTO tictactoe (game, board)\n    VALUES (2, '{{X,\" \",\" \"},{\" \",O,\" \"},{\" \",X,\" \"}}');\n\nInsert a single row into tabledistributors, returning the sequence number generated by theDEFAULTclause:\n\n\nCODE:\n\nINSERT INTO distributors (did, dname) VALUES (DEFAULT, 'XYZ Widgets')\n   RETURNING did;\n\nIncrement the sales count of the salesperson who manages the account for Acme Corporation, and record the whole updated row along with current time in a log table:\n\n\nCODE:\n\nWITH upd AS (\n  UPDATE employees SET sales_count = sales_count + 1 WHERE id =\n    (SELECT sales_person FROM accounts WHERE name = 'Acme Corporation')\n    RETURNING *\n)\nINSERT INTO employees_log SELECT *, current_timestamp FROM upd;\n\nInsert or update new distributors as appropriate. Assumes a unique index has been defined that constrains values appearing in thedidcolumn. Note that the specialexcludedtable is used to reference values originally proposed for insertion:\n\n\nCODE:\n\nINSERT INTO distributors (did, dname)\n    VALUES (5, 'Gizmo Transglobal'), (6, 'Associated Computing, Inc')\n    ON CONFLICT (did) DO UPDATE SET dname = EXCLUDED.dname;\n\nInsert a distributor, or do nothing for rows proposed for insertion when an existing, excluded row (a row with a matching constrained column or columns after before row insert triggers fire) exists. Example assumes a unique index has been defined that constrains values appearing in thedidcolumn:\n\n\nCODE:\n\nINSERT INTO distributors (did, dname) VALUES (7, 'Redline GmbH')\n    ON CONFLICT (did) DO NOTHING;\n\nInsert or update new distributors as appropriate. Example assumes a unique index has been defined that constrains values appearing in thedidcolumn.WHEREclause is used to limit the rows actually updated (any existing row not updated will still be locked, though):\n\n\nCODE:\n\n-- Don't update existing distributors based in a certain ZIP code\nINSERT INTO distributors AS d (did, dname) VALUES (8, 'Anvil Distribution')\n    ON CONFLICT (did) DO UPDATE\n    SET dname = EXCLUDED.dname || ' (formerly ' || d.dname || ')'\n    WHERE d.zipcode <> '21201';\n\n-- Name a constraint directly in the statement (uses associated\n-- index to arbitrate taking the DO NOTHING action)\nINSERT INTO distributors (did, dname) VALUES (9, 'Antwerp Design')\n    ON CONFLICT ON CONSTRAINT distributors_pkey DO NOTHING;\n\nInsert new distributor if possible; otherwiseDO NOTHING. Example assumes a unique index has been defined that constrains values appearing in thedidcolumn on a subset of rows where theis_activeBoolean column evaluates totrue:\n\n\nCODE:\n\n-- This statement could infer a partial unique index on \"did\"\n-- with a predicate of \"WHERE is_active\", but it could also\n-- just use a regular unique constraint on \"did\"\nINSERT INTO distributors (did, dname) VALUES (10, 'Conrad International')\n    ON CONFLICT (did) WHERE is_active DO NOTHING;\n\n"
    },
    {
      "title": "Compatibility",
      "text": "INSERTconforms to the SQL standard, except that theRETURNINGclause is aPostgreSQLextension, as is the ability to useWITHwithINSERT, and the ability to specify an alternative action withON CONFLICT. Also, the case in which a column name list is omitted, but not all the columns are filled from theVALUESclause orquery, is disallowed by the standard. If you prefer a more SQL standard conforming statement thanON CONFLICT, seeMERGE.\nThe SQL standard specifies thatOVERRIDING SYSTEM VALUEcan only be specified if an identity column that is generated always exists. PostgreSQL allows the clause in any case and ignores it if it is not applicable.\nPossible limitations of thequeryclause are documented underSELECT.\n"
    }
  ]
}