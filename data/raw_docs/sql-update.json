{
  "doc_name": "sql-update",
  "url": "https://www.postgresql.org/docs/16/sql-update.html",
  "sections": [
    {
      "title": "UPDATE",
      "text": "UPDATE — update rows of a table\n"
    },
    {
      "title": "Synopsis",
      "text": "\n\nCODE:\n\n[ WITH [ RECURSIVE ] with_query [, ...] ]\nUPDATE [ ONLY ] table_name [ * ] [ [ AS ] alias ]\n    SET { column_name = { expression | DEFAULT } |\n          ( column_name [, ...] ) = [ ROW ] ( { expression | DEFAULT } [, ...] ) |\n          ( column_name [, ...] ) = ( sub-SELECT )\n        } [, ...]\n    [ FROM from_item [, ...] ]\n    [ WHERE condition | WHERE CURRENT OF cursor_name ]\n    [ RETURNING { * | output_expression [ [ AS ] output_name ] } [, ...] ]\n\n"
    },
    {
      "title": "Description",
      "text": "UPDATEchanges the values of the specified columns in all rows that satisfy the condition. Only the columns to be modified need be mentioned in theSETclause; columns not explicitly modified retain their previous values.\nThere are two ways to modify a table using information contained in other tables in the database: using sub-selects, or specifying additional tables in theFROMclause. Which technique is more appropriate depends on the specific circumstances.\nThe optionalRETURNINGclause causesUPDATEto compute and return value(s) based on each row actually updated. Any expression using the table's columns, and/or columns of other tables mentioned inFROM, can be computed. The new (post-update) values of the table's columns are used. The syntax of theRETURNINGlist is identical to that of the output list ofSELECT.\nYou must have theUPDATEprivilege on the table, or at least on the column(s) that are listed to be updated. You must also have theSELECTprivilege on any column whose values are read in theexpressionsorcondition.\n"
    },
    {
      "title": "Parameters",
      "text": "TheWITHclause allows you to specify one or more subqueries that can be referenced by name in theUPDATEquery. SeeSection 7.8andSELECTfor details.\nThe name (optionally schema-qualified) of the table to update. IfONLYis specified before the table name, matching rows are updated in the named table only. IfONLYis not specified, matching rows are also updated in any tables inheriting from the named table. Optionally,*can be specified after the table name to explicitly indicate that descendant tables are included.\nA substitute name for the target table. When an alias is provided, it completely hides the actual name of the table. For example, givenUPDATE foo AS f, the remainder of theUPDATEstatement must refer to this table asfnotfoo.\nThe name of a column in the table named bytable_name. The column name can be qualified with a subfield name or array subscript, if needed. Do not include the table's name in the specification of a target column — for example,UPDATE table_name SET table_name.col = 1is invalid.\nAn expression to assign to the column. The expression can use the old values of this and other columns in the table.\nSet the column to its default value (which will be NULL if no specific default expression has been assigned to it). An identity column will be set to a new value generated by the associated sequence. For a generated column, specifying this is permitted but merely specifies the normal behavior of computing the column from its generation expression.\nASELECTsub-query that produces as many output columns as are listed in the parenthesized column list preceding it. The sub-query must yield no more than one row when executed. If it yields one row, its column values are assigned to the target columns; if it yields no rows, NULL values are assigned to the target columns. The sub-query can refer to old values of the current row of the table being updated.\nA table expression allowing columns from other tables to appear in theWHEREcondition and update expressions. This uses the same syntax as theFROMclause of aSELECTstatement; for example, an alias for the table name can be specified. Do not repeat the target table as afrom_itemunless you intend a self-join (in which case it must appear with an alias in thefrom_item).\nAn expression that returns a value of typeboolean. Only rows for which this expression returnstruewill be updated.\nThe name of the cursor to use in aWHERE CURRENT OFcondition. The row to be updated is the one most recently fetched from this cursor. The cursor must be a non-grouping query on theUPDATE's target table. Note thatWHERE CURRENT OFcannot be specified together with a Boolean condition. SeeDECLAREfor more information about using cursors withWHERE CURRENT OF.\nAn expression to be computed and returned by theUPDATEcommand after each row is updated. The expression can use any column names of the table named bytable_nameor table(s) listed inFROM. Write*to return all columns.\nA name to use for a returned column.\n"
    },
    {
      "title": "Outputs",
      "text": "On successful completion, anUPDATEcommand returns a command tag of the form\n\n\nCODE:\n\nUPDATE count\n\nThecountis the number of rows updated, including matched rows whose values did not change. Note that the number may be less than the number of rows that matched theconditionwhen updates were suppressed by aBEFORE UPDATEtrigger. Ifcountis 0, no rows were updated by the query (this is not considered an error).\nIf theUPDATEcommand contains aRETURNINGclause, the result will be similar to that of aSELECTstatement containing the columns and values defined in theRETURNINGlist, computed over the row(s) updated by the command.\n"
    },
    {
      "title": "Notes",
      "text": "When aFROMclause is present, what essentially happens is that the target table is joined to the tables mentioned in thefrom_itemlist, and each output row of the join represents an update operation for the target table. When usingFROMyou should ensure that the join produces at most one output row for each row to be modified. In other words, a target row shouldn't join to more than one row from the other table(s). If it does, then only one of the join rows will be used to update the target row, but which one will be used is not readily predictable.\nBecause of this indeterminacy, referencing other tables only within sub-selects is safer, though often harder to read and slower than using a join.\nIn the case of a partitioned table, updating a row might cause it to no longer satisfy the partition constraint of the containing partition. In that case, if there is some other partition in the partition tree for which this row satisfies its partition constraint, then the row is moved to that partition. If there is no such partition, an error will occur. Behind the scenes, the row movement is actually aDELETEandINSERToperation.\nThere is a possibility that a concurrentUPDATEorDELETEon the row being moved will get a serialization failure error. Suppose session 1 is performing anUPDATEon a partition key, and meanwhile a concurrent session 2 for which this row is visible performs anUPDATEorDELETEoperation on this row. In such case, session 2'sUPDATEorDELETEwill detect the row movement and raise a serialization failure error (which always returns with an SQLSTATE code '40001'). Applications may wish to retry the transaction if this occurs. In the usual case where the table is not partitioned, or where there is no row movement, session 2 would have identified the newly updated row and carried out theUPDATE/DELETEon this new row version.\nNote that while rows can be moved from local partitions to a foreign-table partition (provided the foreign data wrapper supports tuple routing), they cannot be moved from a foreign-table partition to another partition.\nAn attempt of moving a row from one partition to another will fail if a foreign key is found to directly reference an ancestor of the source partition that is not the same as the ancestor that's mentioned in theUPDATEquery.\n"
    },
    {
      "title": "Examples",
      "text": "Change the wordDramatoDramaticin the columnkindof the tablefilms:\n\n\nCODE:\n\nUPDATE films SET kind = 'Dramatic' WHERE kind = 'Drama';\n\nAdjust temperature entries and reset precipitation to its default value in one row of the tableweather:\n\n\nCODE:\n\nUPDATE weather SET temp_lo = temp_lo+1, temp_hi = temp_lo+15, prcp = DEFAULT\n  WHERE city = 'San Francisco' AND date = '2003-07-03';\n\nPerform the same operation and return the updated entries:\n\n\nCODE:\n\nUPDATE weather SET temp_lo = temp_lo+1, temp_hi = temp_lo+15, prcp = DEFAULT\n  WHERE city = 'San Francisco' AND date = '2003-07-03'\n  RETURNING temp_lo, temp_hi, prcp;\n\nUse the alternative column-list syntax to do the same update:\n\n\nCODE:\n\nUPDATE weather SET (temp_lo, temp_hi, prcp) = (temp_lo+1, temp_lo+15, DEFAULT)\n  WHERE city = 'San Francisco' AND date = '2003-07-03';\n\nIncrement the sales count of the salesperson who manages the account for Acme Corporation, using theFROMclause syntax:\n\n\nCODE:\n\nUPDATE employees SET sales_count = sales_count + 1 FROM accounts\n  WHERE accounts.name = 'Acme Corporation'\n  AND employees.id = accounts.sales_person;\n\nPerform the same operation, using a sub-select in theWHEREclause:\n\n\nCODE:\n\nUPDATE employees SET sales_count = sales_count + 1 WHERE id =\n  (SELECT sales_person FROM accounts WHERE name = 'Acme Corporation');\n\nUpdate contact names in an accounts table to match the currently assigned salespeople:\n\n\nCODE:\n\nUPDATE accounts SET (contact_first_name, contact_last_name) =\n    (SELECT first_name, last_name FROM employees\n     WHERE employees.id = accounts.sales_person);\n\nA similar result could be accomplished with a join:\n\n\nCODE:\n\nUPDATE accounts SET contact_first_name = first_name,\n                    contact_last_name = last_name\n  FROM employees WHERE employees.id = accounts.sales_person;\n\nHowever, the second query may give unexpected results ifemployees.idis not a unique key, whereas the first query is guaranteed to raise an error if there are multipleidmatches. Also, if there is no match for a particularaccounts.sales_personentry, the first query will set the corresponding name fields to NULL, whereas the second query will not update that row at all.\nUpdate statistics in a summary table to match the current data:\n\n\nCODE:\n\nUPDATE summary s SET (sum_x, sum_y, avg_x, avg_y) =\n    (SELECT sum(x), sum(y), avg(x), avg(y) FROM data d\n     WHERE d.group_id = s.group_id);\n\nAttempt to insert a new stock item along with the quantity of stock. If the item already exists, instead update the stock count of the existing item. To do this without failing the entire transaction, use savepoints:\n\n\nCODE:\n\nBEGIN;\n-- other operations\nSAVEPOINT sp1;\nINSERT INTO wines VALUES('Chateau Lafite 2003', '24');\n-- Assume the above fails because of a unique key violation,\n-- so now we issue these commands:\nROLLBACK TO sp1;\nUPDATE wines SET stock = stock + 24 WHERE winename = 'Chateau Lafite 2003';\n-- continue with other operations, and eventually\nCOMMIT;\n\nChange thekindcolumn of the tablefilmsin the row on which the cursorc_filmsis currently positioned:\n\n\nCODE:\n\nUPDATE films SET kind = 'Dramatic' WHERE CURRENT OF c_films;\n\n"
    },
    {
      "title": "Compatibility",
      "text": "This command conforms to theSQLstandard, except that theFROMandRETURNINGclauses arePostgreSQLextensions, as is the ability to useWITHwithUPDATE.\nSome other database systems offer aFROMoption in which the target table is supposed to be listed again withinFROM. That is not howPostgreSQLinterpretsFROM. Be careful when porting applications that use this extension.\nAccording to the standard, the source value for a parenthesized sub-list of target column names can be any row-valued expression yielding the correct number of columns.PostgreSQLonly allows the source value to be arow constructoror a sub-SELECT. An individual column's updated value can be specified asDEFAULTin the row-constructor case, but not inside a sub-SELECT.\n"
    }
  ]
}