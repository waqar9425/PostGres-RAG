{
  "doc_name": "sql-copy",
  "url": "https://www.postgresql.org/docs/16/sql-copy.html",
  "sections": [
    {
      "title": "COPY",
      "text": "COPY — copy data between a file and a table\n"
    },
    {
      "title": "Synopsis",
      "text": "\n\nCODE:\n\nCOPY table_name [ ( column_name [, ...] ) ]\n    FROM { 'filename' | PROGRAM 'command' | STDIN }\n    [ [ WITH ] ( option [, ...] ) ]\n    [ WHERE condition ]\n\nCOPY { table_name [ ( column_name [, ...] ) ] | ( query ) }\n    TO { 'filename' | PROGRAM 'command' | STDOUT }\n    [ [ WITH ] ( option [, ...] ) ]\n\nwhere option can be one of:\n\n    FORMAT format_name\n    FREEZE [ boolean ]\n    DELIMITER 'delimiter_character'\n    NULL 'null_string'\n    DEFAULT 'default_string'\n    HEADER [ boolean | MATCH ]\n    QUOTE 'quote_character'\n    ESCAPE 'escape_character'\n    FORCE_QUOTE { ( column_name [, ...] ) | * }\n    FORCE_NOT_NULL ( column_name [, ...] )\n    FORCE_NULL ( column_name [, ...] )\n    ENCODING 'encoding_name'\n\n"
    },
    {
      "title": "Description",
      "text": "COPYmoves data betweenPostgreSQLtables and standard file-system files.COPY TOcopies the contents of a tabletoa file, whileCOPY FROMcopies datafroma file to a table (appending the data to whatever is in the table already).COPY TOcan also copy the results of aSELECTquery.\nIf a column list is specified,COPY TOcopies only the data in the specified columns to the file. ForCOPY FROM, each field in the file is inserted, in order, into the specified column. Table columns not specified in theCOPY FROMcolumn list will receive their default values.\nCOPYwith a file name instructs thePostgreSQLserver to directly read from or write to a file. The file must be accessible by thePostgreSQLuser (the user ID the server runs as) and the name must be specified from the viewpoint of the server. WhenPROGRAMis specified, the server executes the given command and reads from the standard output of the program, or writes to the standard input of the program. The command must be specified from the viewpoint of the server, and be executable by thePostgreSQLuser. WhenSTDINorSTDOUTis specified, data is transmitted via the connection between the client and the server.\nEach backend runningCOPYwill report its progress in thepg_stat_progress_copyview. SeeSection 28.4.3for details.\n"
    },
    {
      "title": "Parameters",
      "text": "The name (optionally schema-qualified) of an existing table.\nAn optional list of columns to be copied. If no column list is specified, all columns of the table except generated columns will be copied.\nASELECT,VALUES,INSERT,UPDATE, orDELETEcommand whose results are to be copied. Note that parentheses are required around the query.\nForINSERT,UPDATEandDELETEqueries aRETURNINGclause must be provided, and the target relation must not have a conditional rule, nor anALSOrule, nor anINSTEADrule that expands to multiple statements.\nThe path name of the input or output file. An input file name can be an absolute or relative path, but an output file name must be an absolute path. Windows users might need to use anE''string and double any backslashes used in the path name.\nA command to execute. InCOPY FROM, the input is read from standard output of the command, and inCOPY TO, the output is written to the standard input of the command.\nNote that the command is invoked by the shell, so if you need to pass any arguments that come from an untrusted source, you must be careful to strip or escape any special characters that might have a special meaning for the shell. For security reasons, it is best to use a fixed command string, or at least avoid including any user input in it.\nSpecifies that input comes from the client application.\nSpecifies that output goes to the client application.\nSpecifies whether the selected option should be turned on or off. You can writeTRUE,ON, or1to enable the option, andFALSE,OFF, or0to disable it. Thebooleanvalue can also be omitted, in which caseTRUEis assumed.\nSelects the data format to be read or written:text,csv(Comma Separated Values), orbinary. The default istext.\nRequests copying the data with rows already frozen, just as they would be after running theVACUUM FREEZEcommand. This is intended as a performance option for initial data loading. Rows will be frozen only if the table being loaded has been created or truncated in the current subtransaction, there are no cursors open and there are no older snapshots held by this transaction. It is currently not possible to perform aCOPY FREEZEon a partitioned table.\nNote that all other sessions will immediately be able to see the data once it has been successfully loaded. This violates the normal rules of MVCC visibility and users should be aware of the potential problems this might cause.\nSpecifies the character that separates columns within each row (line) of the file. The default is a tab character in text format, a comma inCSVformat. This must be a single one-byte character. This option is not allowed when usingbinaryformat.\nSpecifies the string that represents a null value. The default is\\N(backslash-N) in text format, and an unquoted empty string inCSVformat. You might prefer an empty string even in text format for cases where you don't want to distinguish nulls from empty strings. This option is not allowed when usingbinaryformat.\n"
    },
    {
      "title": "Note",
      "text": "When usingCOPY FROM, any data item that matches this string will be stored as a null value, so you should make sure that you use the same string as you used withCOPY TO.\nSpecifies the string that represents a default value. Each time the string is found in the input file, the default value of the corresponding column will be used. This option is allowed only inCOPY FROM, and only when not usingbinaryformat.\nSpecifies that the file contains a header line with the names of each column in the file. On output, the first line contains the column names from the table. On input, the first line is discarded when this option is set totrue(or equivalent Boolean value). If this option is set toMATCH, the number and names of the columns in the header line must match the actual column names of the table, in order; otherwise an error is raised. This option is not allowed when usingbinaryformat. TheMATCHoption is only valid forCOPY FROMcommands.\nSpecifies the quoting character to be used when a data value is quoted. The default is double-quote. This must be a single one-byte character. This option is allowed only when usingCSVformat.\nSpecifies the character that should appear before a data character that matches theQUOTEvalue. The default is the same as theQUOTEvalue (so that the quoting character is doubled if it appears in the data). This must be a single one-byte character. This option is allowed only when usingCSVformat.\nForces quoting to be used for all non-NULLvalues in each specified column.NULLoutput is never quoted. If*is specified, non-NULLvalues will be quoted in all columns. This option is allowed only inCOPY TO, and only when usingCSVformat.\nDo not match the specified columns' values against the null string. In the default case where the null string is empty, this means that empty values will be read as zero-length strings rather than nulls, even when they are not quoted. This option is allowed only inCOPY FROM, and only when usingCSVformat.\nMatch the specified columns' values against the null string, even if it has been quoted, and if a match is found set the value toNULL. In the default case where the null string is empty, this converts a quoted empty string into NULL. This option is allowed only inCOPY FROM, and only when usingCSVformat.\nSpecifies that the file is encoded in theencoding_name. If this option is omitted, the current client encoding is used. See the Notes below for more details.\nThe optionalWHEREclause has the general form\n\n\nCODE:\n\nWHERE condition\n\nwhereconditionis any expression that evaluates to a result of typeboolean. Any row that does not satisfy this condition will not be inserted to the table. A row satisfies the condition if it returns true when the actual row values are substituted for any variable references.\nCurrently, subqueries are not allowed inWHEREexpressions, and the evaluation does not see any changes made by theCOPYitself (this matters when the expression contains calls toVOLATILEfunctions).\n"
    },
    {
      "title": "Outputs",
      "text": "On successful completion, aCOPYcommand returns a command tag of the form\n\n\nCODE:\n\nCOPY count\n\nThecountis the number of rows copied.\n"
    },
    {
      "title": "Note",
      "text": "psqlwill print this command tag only if the command was notCOPY ... TO STDOUT, or the equivalentpsqlmeta-command\\copy ... to stdout. This is to prevent confusing the command tag with the data that was just printed.\n"
    },
    {
      "title": "Notes",
      "text": "COPY TOcan be used only with plain tables, not views, and does not copy rows from child tables or child partitions. For example,COPYtableTOcopies the same rows asSELECT * FROM ONLYtable. The syntaxCOPY (SELECT * FROMtable) TO ...can be used to dump all of the rows in an inheritance hierarchy, partitioned table, or view.\nCOPY FROMcan be used with plain, foreign, or partitioned tables or with views that haveINSTEAD OF INSERTtriggers.\nYou must have select privilege on the table whose values are read byCOPY TO, and insert privilege on the table into which values are inserted byCOPY FROM. It is sufficient to have column privileges on the column(s) listed in the command.\nIf row-level security is enabled for the table, the relevantSELECTpolicies will apply toCOPYtableTOstatements. Currently,COPY FROMis not supported for tables with row-level security. Use equivalentINSERTstatements instead.\nFiles named in aCOPYcommand are read or written directly by the server, not by the client application. Therefore, they must reside on or be accessible to the database server machine, not the client. They must be accessible to and readable or writable by thePostgreSQLuser (the user ID the server runs as), not the client. Similarly, the command specified withPROGRAMis executed directly by the server, not by the client application, must be executable by thePostgreSQLuser.COPYnaming a file or command is only allowed to database superusers or users who are granted one of the rolespg_read_server_files,pg_write_server_files, orpg_execute_server_program, since it allows reading or writing any file or running a program that the server has privileges to access.\nDo not confuseCOPYwith thepsqlinstruction\\copy.\\copyinvokesCOPY FROM STDINorCOPY TO STDOUT, and then fetches/stores the data in a file accessible to thepsqlclient. Thus, file accessibility and access rights depend on the client rather than the server when\\copyis used.\nIt is recommended that the file name used inCOPYalways be specified as an absolute path. This is enforced by the server in the case ofCOPY TO, but forCOPY FROMyou do have the option of reading from a file specified by a relative path. The path will be interpreted relative to the working directory of the server process (normally the cluster's data directory), not the client's working directory.\nExecuting a command withPROGRAMmight be restricted by the operating system's access control mechanisms, such as SELinux.\nCOPY FROMwill invoke any triggers and check constraints on the destination table. However, it will not invoke rules.\nFor identity columns, theCOPY FROMcommand will always write the column values provided in the input data, like theINSERToptionOVERRIDING SYSTEM VALUE.\nCOPYinput and output is affected byDateStyle. To ensure portability to otherPostgreSQLinstallations that might use non-defaultDateStylesettings,DateStyleshould be set toISObefore usingCOPY TO. It is also a good idea to avoid dumping data withIntervalStyleset tosql_standard, because negative interval values might be misinterpreted by a server that has a different setting forIntervalStyle.\nInput data is interpreted according toENCODINGoption or the current client encoding, and output data is encoded inENCODINGor the current client encoding, even if the data does not pass through the client but is read from or written to a file directly by the server.\nCOPYstops operation at the first error. This should not lead to problems in the event of aCOPY TO, but the target table will already have received earlier rows in aCOPY FROM. These rows will not be visible or accessible, but they still occupy disk space. This might amount to a considerable amount of wasted disk space if the failure happened well into a large copy operation. You might wish to invokeVACUUMto recover the wasted space.\nFORCE_NULLandFORCE_NOT_NULLcan be used simultaneously on the same column. This results in converting quoted null strings to null values and unquoted null strings to empty strings.\n"
    },
    {
      "title": "Text Format",
      "text": "When thetextformat is used, the data read or written is a text file with one line per table row. Columns in a row are separated by the delimiter character. The column values themselves are strings generated by the output function, or acceptable to the input function, of each attribute's data type. The specified null string is used in place of columns that are null.COPY FROMwill raise an error if any line of the input file contains more or fewer columns than are expected.\nEnd of data can be represented by a single line containing just backslash-period (\\.). An end-of-data marker is not necessary when reading from a file, since the end of file serves perfectly well; it is needed only when copying data to or from client applications using pre-3.0 client protocol.\nBackslash characters (\\) can be used in theCOPYdata to quote data characters that might otherwise be taken as row or column delimiters. In particular, the following charactersmustbe preceded by a backslash if they appear as part of a column value: backslash itself, newline, carriage return, and the current delimiter character.\nThe specified null string is sent byCOPY TOwithout adding any backslashes; conversely,COPY FROMmatches the input against the null string before removing backslashes. Therefore, a null string such as\\Ncannot be confused with the actual data value\\N(which would be represented as\\\\N).\nThe following special backslash sequences are recognized byCOPY FROM:\nPresently,COPY TOwill never emit an octal or hex-digits backslash sequence, but it does use the other sequences listed above for those control characters.\nAny other backslashed character that is not mentioned in the above table will be taken to represent itself. However, beware of adding backslashes unnecessarily, since that might accidentally produce a string matching the end-of-data marker (\\.) or the null string (\\Nby default). These strings will be recognized before any other backslash processing is done.\nIt is strongly recommended that applications generatingCOPYdata convert data newlines and carriage returns to the\\nand\\rsequences respectively. At present it is possible to represent a data carriage return by a backslash and carriage return, and to represent a data newline by a backslash and newline. However, these representations might not be accepted in future releases. They are also highly vulnerable to corruption if theCOPYfile is transferred across different machines (for example, from Unix to Windows or vice versa).\nAll backslash sequences are interpreted after encoding conversion. The bytes specified with the octal and hex-digit backslash sequences must form valid characters in the database encoding.\nCOPY TOwill terminate each row with a Unix-style newline (“\\n”). Servers running on Microsoft Windows instead output carriage return/newline (“\\r\\n”), but only forCOPYto a server file; for consistency across platforms,COPY TO STDOUTalways sends“\\n”regardless of server platform.COPY FROMcan handle lines ending with newlines, carriage returns, or carriage return/newlines. To reduce the risk of error due to un-backslashed newlines or carriage returns that were meant as data,COPY FROMwill complain if the line endings in the input are not all alike.\n"
    },
    {
      "title": "CSV Format",
      "text": "This format option is used for importing and exporting the Comma Separated Value (CSV) file format used by many other programs, such as spreadsheets. Instead of the escaping rules used byPostgreSQL's standard text format, it produces and recognizes the commonCSVescaping mechanism.\nThe values in each record are separated by theDELIMITERcharacter. If the value contains the delimiter character, theQUOTEcharacter, theNULLstring, a carriage return, or line feed character, then the whole value is prefixed and suffixed by theQUOTEcharacter, and any occurrence within the value of aQUOTEcharacter or theESCAPEcharacter is preceded by the escape character. You can also useFORCE_QUOTEto force quotes when outputting non-NULLvalues in specific columns.\nTheCSVformat has no standard way to distinguish aNULLvalue from an empty string.PostgreSQL'sCOPYhandles this by quoting. ANULLis output as theNULLparameter string and is not quoted, while a non-NULLvalue matching theNULLparameter string is quoted. For example, with the default settings, aNULLis written as an unquoted empty string, while an empty string data value is written with double quotes (\"\"). Reading values follows similar rules. You can useFORCE_NOT_NULLto preventNULLinput comparisons for specific columns. You can also useFORCE_NULLto convert quoted null string data values toNULL.\nBecause backslash is not a special character in theCSVformat,\\., the end-of-data marker, could also appear as a data value. To avoid any misinterpretation, a\\.data value appearing as a lone entry on a line is automatically quoted on output, and on input, if quoted, is not interpreted as the end-of-data marker. If you are loading a file created by another application that has a single unquoted column and might have a value of\\., you might need to quote that value in the input file.\n"
    },
    {
      "title": "Note",
      "text": "InCSVformat, all characters are significant. A quoted value surrounded by white space, or any characters other thanDELIMITER, will include those characters. This can cause errors if you import data from a system that padsCSVlines with white space out to some fixed width. If such a situation arises you might need to preprocess theCSVfile to remove the trailing white space, before importing the data intoPostgreSQL.\n"
    },
    {
      "title": "Note",
      "text": "CSVformat will both recognize and produceCSVfiles with quoted values containing embedded carriage returns and line feeds. Thus the files are not strictly one line per table row like text-format files.\n"
    },
    {
      "title": "Note",
      "text": "Many programs produce strange and occasionally perverseCSVfiles, so the file format is more a convention than a standard. Thus you might encounter some files that cannot be imported using this mechanism, andCOPYmight produce files that other programs cannot process.\n"
    },
    {
      "title": "Binary Format",
      "text": "Thebinaryformat option causes all data to be stored/read as binary format rather than as text. It is somewhat faster than the text andCSVformats, but a binary-format file is less portable across machine architectures andPostgreSQLversions. Also, the binary format is very data type specific; for example it will not work to output binary data from asmallintcolumn and read it into anintegercolumn, even though that would work fine in text format.\nThebinaryfile format consists of a file header, zero or more tuples containing the row data, and a file trailer. Headers and data are in network byte order.\n"
    },
    {
      "title": "Note",
      "text": "PostgreSQLreleases before 7.4 used a different binary file format.\nThe file header consists of 15 bytes of fixed fields, followed by a variable-length header extension area. The fixed fields are:\n11-byte sequencePGCOPY\\n\\377\\r\\n\\0— note that the zero byte is a required part of the signature. (The signature is designed to allow easy identification of files that have been munged by a non-8-bit-clean transfer. This signature will be changed by end-of-line-translation filters, dropped zero bytes, dropped high bits, or parity changes.)\n32-bit integer bit mask to denote important aspects of the file format. Bits are numbered from 0 (LSB) to 31 (MSB). Note that this field is stored in network byte order (most significant byte first), as are all the integer fields used in the file format. Bits 16–31 are reserved to denote critical file format issues; a reader should abort if it finds an unexpected bit set in this range. Bits 0–15 are reserved to signal backwards-compatible format issues; a reader should simply ignore any unexpected bits set in this range. Currently only one flag bit is defined, and the rest must be zero:\nIf 1, OIDs are included in the data; if 0, not. Oid system columns are not supported inPostgreSQLanymore, but the format still contains the indicator.\n32-bit integer, length in bytes of remainder of header, not including self. Currently, this is zero, and the first tuple follows immediately. Future changes to the format might allow additional data to be present in the header. A reader should silently skip over any header extension data it does not know what to do with.\nThe header extension area is envisioned to contain a sequence of self-identifying chunks. The flags field is not intended to tell readers what is in the extension area. Specific design of header extension contents is left for a later release.\nThis design allows for both backwards-compatible header additions (add header extension chunks, or set low-order flag bits) and non-backwards-compatible changes (set high-order flag bits to signal such changes, and add supporting data to the extension area if needed).\nEach tuple begins with a 16-bit integer count of the number of fields in the tuple. (Presently, all tuples in a table will have the same count, but that might not always be true.) Then, repeated for each field in the tuple, there is a 32-bit length word followed by that many bytes of field data. (The length word does not include itself, and can be zero.) As a special case, -1 indicates a NULL field value. No value bytes follow in the NULL case.\nThere is no alignment padding or any other extra data between fields.\nPresently, all data values in a binary-format file are assumed to be in binary format (format code one). It is anticipated that a future extension might add a header field that allows per-column format codes to be specified.\nTo determine the appropriate binary format for the actual tuple data you should consult thePostgreSQLsource, in particular the*sendand*recvfunctions for each column's data type (typically these functions are found in thesrc/backend/utils/adt/directory of the source distribution).\nIf OIDs are included in the file, the OID field immediately follows the field-count word. It is a normal field except that it's not included in the field-count. Note that oid system columns are not supported in current versions ofPostgreSQL.\nThe file trailer consists of a 16-bit integer word containing -1. This is easily distinguished from a tuple's field-count word.\nA reader should report an error if a field-count word is neither -1 nor the expected number of columns. This provides an extra check against somehow getting out of sync with the data.\n"
    },
    {
      "title": "Examples",
      "text": "The following example copies a table to the client using the vertical bar (|) as the field delimiter:\n\n\nCODE:\n\nCOPY country TO STDOUT (DELIMITER '|');\n\nTo copy data from a file into thecountrytable:\n\n\nCODE:\n\nCOPY country FROM '/usr1/proj/bray/sql/country_data';\n\nTo copy into a file just the countries whose names start with 'A':\n\n\nCODE:\n\nCOPY (SELECT * FROM country WHERE country_name LIKE 'A%') TO '/usr1/proj/bray/sql/a_list_countries.copy';\n\nTo copy into a compressed file, you can pipe the output through an external compression program:\n\n\nCODE:\n\nCOPY country TO PROGRAM 'gzip > /usr1/proj/bray/sql/country_data.gz';\n\nHere is a sample of data suitable for copying into a table fromSTDIN:\n\n\nCODE:\n\nAF      AFGHANISTAN\nAL      ALBANIA\nDZ      ALGERIA\nZM      ZAMBIA\nZW      ZIMBABWE\n\nNote that the white space on each line is actually a tab character.\nThe following is the same data, output in binary format. The data is shown after filtering through the Unix utilityod -c. The table has three columns; the first has typechar(2), the second has typetext, and the third has typeinteger. All the rows have a null value in the third column.\n\n\nCODE:\n\n0000000   P   G   C   O   P   Y  \\n 377  \\r  \\n  \\0  \\0  \\0  \\0  \\0  \\0\n0000020  \\0  \\0  \\0  \\0 003  \\0  \\0  \\0 002   A   F  \\0  \\0  \\0 013   A\n0000040   F   G   H   A   N   I   S   T   A   N 377 377 377 377  \\0 003\n0000060  \\0  \\0  \\0 002   A   L  \\0  \\0  \\0 007   A   L   B   A   N   I\n0000100   A 377 377 377 377  \\0 003  \\0  \\0  \\0 002   D   Z  \\0  \\0  \\0\n0000120 007   A   L   G   E   R   I   A 377 377 377 377  \\0 003  \\0  \\0\n0000140  \\0 002   Z   M  \\0  \\0  \\0 006   Z   A   M   B   I   A 377 377\n0000160 377 377  \\0 003  \\0  \\0  \\0 002   Z   W  \\0  \\0  \\0  \\b   Z   I\n0000200   M   B   A   B   W   E 377 377 377 377 377 377\n\n"
    },
    {
      "title": "Compatibility",
      "text": "There is noCOPYstatement in the SQL standard.\nThe following syntax was used beforePostgreSQLversion 9.0 and is still supported:\n\n\nCODE:\n\nCOPY table_name [ ( column_name [, ...] ) ]\n    FROM { 'filename' | STDIN }\n    [ [ WITH ]\n          [ BINARY ]\n          [ DELIMITER [ AS ] 'delimiter_character' ]\n          [ NULL [ AS ] 'null_string' ]\n          [ CSV [ HEADER ]\n                [ QUOTE [ AS ] 'quote_character' ]\n                [ ESCAPE [ AS ] 'escape_character' ]\n                [ FORCE NOT NULL column_name [, ...] ] ] ]\n\nCOPY { table_name [ ( column_name [, ...] ) ] | ( query ) }\n    TO { 'filename' | STDOUT }\n    [ [ WITH ]\n          [ BINARY ]\n          [ DELIMITER [ AS ] 'delimiter_character' ]\n          [ NULL [ AS ] 'null_string' ]\n          [ CSV [ HEADER ]\n                [ QUOTE [ AS ] 'quote_character' ]\n                [ ESCAPE [ AS ] 'escape_character' ]\n                [ FORCE QUOTE { column_name [, ...] | * } ] ] ]\n\nNote that in this syntax,BINARYandCSVare treated as independent keywords, not as arguments of aFORMAToption.\nThe following syntax was used beforePostgreSQLversion 7.3 and is still supported:\n\n\nCODE:\n\nCOPY [ BINARY ] table_name\n    FROM { 'filename' | STDIN }\n    [ [USING] DELIMITERS 'delimiter_character' ]\n    [ WITH NULL AS 'null_string' ]\n\nCOPY [ BINARY ] table_name\n    TO { 'filename' | STDOUT }\n    [ [USING] DELIMITERS 'delimiter_character' ]\n    [ WITH NULL AS 'null_string' ]\n\n"
    }
  ]
}