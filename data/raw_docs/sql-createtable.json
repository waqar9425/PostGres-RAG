{
  "doc_name": "sql-createtable",
  "url": "https://www.postgresql.org/docs/16/sql-createtable.html",
  "sections": [
    {
      "title": "CREATE TABLE",
      "text": "CREATE TABLE — define a new table\n"
    },
    {
      "title": "Synopsis",
      "text": "\n\nCODE:\n\nCREATE [ [ GLOBAL | LOCAL ] { TEMPORARY | TEMP } | UNLOGGED ] TABLE [ IF NOT EXISTS ] table_name ( [\n  { column_name data_type [ STORAGE { PLAIN | EXTERNAL | EXTENDED | MAIN | DEFAULT } ] [ COMPRESSION compression_method ] [ COLLATE collation ] [ column_constraint [ ... ] ]\n    | table_constraint\n    | LIKE source_table [ like_option ... ] }\n    [, ... ]\n] )\n[ INHERITS ( parent_table [, ... ] ) ]\n[ PARTITION BY { RANGE | LIST | HASH } ( { column_name | ( expression ) } [ COLLATE collation ] [ opclass ] [, ... ] ) ]\n[ USING method ]\n[ WITH ( storage_parameter [= value] [, ... ] ) | WITHOUT OIDS ]\n[ ON COMMIT { PRESERVE ROWS | DELETE ROWS | DROP } ]\n[ TABLESPACE tablespace_name ]\n\nCREATE [ [ GLOBAL | LOCAL ] { TEMPORARY | TEMP } | UNLOGGED ] TABLE [ IF NOT EXISTS ] table_name\n    OF type_name [ (\n  { column_name [ WITH OPTIONS ] [ column_constraint [ ... ] ]\n    | table_constraint }\n    [, ... ]\n) ]\n[ PARTITION BY { RANGE | LIST | HASH } ( { column_name | ( expression ) } [ COLLATE collation ] [ opclass ] [, ... ] ) ]\n[ USING method ]\n[ WITH ( storage_parameter [= value] [, ... ] ) | WITHOUT OIDS ]\n[ ON COMMIT { PRESERVE ROWS | DELETE ROWS | DROP } ]\n[ TABLESPACE tablespace_name ]\n\nCREATE [ [ GLOBAL | LOCAL ] { TEMPORARY | TEMP } | UNLOGGED ] TABLE [ IF NOT EXISTS ] table_name\n    PARTITION OF parent_table [ (\n  { column_name [ WITH OPTIONS ] [ column_constraint [ ... ] ]\n    | table_constraint }\n    [, ... ]\n) ] { FOR VALUES partition_bound_spec | DEFAULT }\n[ PARTITION BY { RANGE | LIST | HASH } ( { column_name | ( expression ) } [ COLLATE collation ] [ opclass ] [, ... ] ) ]\n[ USING method ]\n[ WITH ( storage_parameter [= value] [, ... ] ) | WITHOUT OIDS ]\n[ ON COMMIT { PRESERVE ROWS | DELETE ROWS | DROP } ]\n[ TABLESPACE tablespace_name ]\n\nwhere column_constraint is:\n\n[ CONSTRAINT constraint_name ]\n{ NOT NULL |\n  NULL |\n  CHECK ( expression ) [ NO INHERIT ] |\n  DEFAULT default_expr |\n  GENERATED ALWAYS AS ( generation_expr ) STORED |\n  GENERATED { ALWAYS | BY DEFAULT } AS IDENTITY [ ( sequence_options ) ] |\n  UNIQUE [ NULLS [ NOT ] DISTINCT ] index_parameters |\n  PRIMARY KEY index_parameters |\n  REFERENCES reftable [ ( refcolumn ) ] [ MATCH FULL | MATCH PARTIAL | MATCH SIMPLE ]\n    [ ON DELETE referential_action ] [ ON UPDATE referential_action ] }\n[ DEFERRABLE | NOT DEFERRABLE ] [ INITIALLY DEFERRED | INITIALLY IMMEDIATE ]\n\nand table_constraint is:\n\n[ CONSTRAINT constraint_name ]\n{ CHECK ( expression ) [ NO INHERIT ] |\n  UNIQUE [ NULLS [ NOT ] DISTINCT ] ( column_name [, ... ] ) index_parameters |\n  PRIMARY KEY ( column_name [, ... ] ) index_parameters |\n  EXCLUDE [ USING index_method ] ( exclude_element WITH operator [, ... ] ) index_parameters [ WHERE ( predicate ) ] |\n  FOREIGN KEY ( column_name [, ... ] ) REFERENCES reftable [ ( refcolumn [, ... ] ) ]\n    [ MATCH FULL | MATCH PARTIAL | MATCH SIMPLE ] [ ON DELETE referential_action ] [ ON UPDATE referential_action ] }\n[ DEFERRABLE | NOT DEFERRABLE ] [ INITIALLY DEFERRED | INITIALLY IMMEDIATE ]\n\nand like_option is:\n\n{ INCLUDING | EXCLUDING } { COMMENTS | COMPRESSION | CONSTRAINTS | DEFAULTS | GENERATED | IDENTITY | INDEXES | STATISTICS | STORAGE | ALL }\n\nand partition_bound_spec is:\n\nIN ( partition_bound_expr [, ...] ) |\nFROM ( { partition_bound_expr | MINVALUE | MAXVALUE } [, ...] )\n  TO ( { partition_bound_expr | MINVALUE | MAXVALUE } [, ...] ) |\nWITH ( MODULUS numeric_literal, REMAINDER numeric_literal )\n\nindex_parameters in UNIQUE, PRIMARY KEY, and EXCLUDE constraints are:\n\n[ INCLUDE ( column_name [, ... ] ) ]\n[ WITH ( storage_parameter [= value] [, ... ] ) ]\n[ USING INDEX TABLESPACE tablespace_name ]\n\nexclude_element in an EXCLUDE constraint is:\n\n{ column_name | ( expression ) } [ COLLATE collation ] [ opclass [ ( opclass_parameter = value [, ... ] ) ] ] [ ASC | DESC ] [ NULLS { FIRST | LAST } ]\n\nreferential_action in a FOREIGN KEY/REFERENCES constraint is:\n\n{ NO ACTION | RESTRICT | CASCADE | SET NULL [ ( column_name [, ... ] ) ] | SET DEFAULT [ ( column_name [, ... ] ) ] }\n\n"
    },
    {
      "title": "Description",
      "text": "CREATE TABLEwill create a new, initially empty table in the current database. The table will be owned by the user issuing the command.\nIf a schema name is given (for example,CREATE TABLE myschema.mytable ...) then the table is created in the specified schema. Otherwise it is created in the current schema. Temporary tables exist in a special schema, so a schema name cannot be given when creating a temporary table. The name of the table must be distinct from the name of any other relation (table, sequence, index, view, materialized view, or foreign table) in the same schema.\nCREATE TABLEalso automatically creates a data type that represents the composite type corresponding to one row of the table. Therefore, tables cannot have the same name as any existing data type in the same schema.\nThe optional constraint clauses specify constraints (tests) that new or updated rows must satisfy for an insert or update operation to succeed. A constraint is an SQL object that helps define the set of valid values in the table in various ways.\nThere are two ways to define constraints: table constraints and column constraints. A column constraint is defined as part of a column definition. A table constraint definition is not tied to a particular column, and it can encompass more than one column. Every column constraint can also be written as a table constraint; a column constraint is only a notational convenience for use when the constraint only affects one column.\nTo be able to create a table, you must haveUSAGEprivilege on all column types or the type in theOFclause, respectively.\n"
    },
    {
      "title": "Parameters",
      "text": "If specified, the table is created as a temporary table. Temporary tables are automatically dropped at the end of a session, or optionally at the end of the current transaction (seeON COMMITbelow). The default search_path includes the temporary schema first and so identically named existing permanent tables are not chosen for new plans while the temporary table exists, unless they are referenced with schema-qualified names. Any indexes created on a temporary table are automatically temporary as well.\nTheautovacuum daemoncannot access and therefore cannot vacuum or analyze temporary tables. For this reason, appropriate vacuum and analyze operations should be performed via session SQL commands. For example, if a temporary table is going to be used in complex queries, it is wise to runANALYZEon the temporary table after it is populated.\nOptionally,GLOBALorLOCALcan be written beforeTEMPORARYorTEMP. This presently makes no difference inPostgreSQLand is deprecated; seeCompatibilitybelow.\nIf specified, the table is created as an unlogged table. Data written to unlogged tables is not written to the write-ahead log (seeChapter 30), which makes them considerably faster than ordinary tables. However, they are not crash-safe: an unlogged table is automatically truncated after a crash or unclean shutdown. The contents of an unlogged table are also not replicated to standby servers. Any indexes created on an unlogged table are automatically unlogged as well.\nIf this is specified, any sequences created together with the unlogged table (for identity or serial columns) are also created as unlogged.\nDo not throw an error if a relation with the same name already exists. A notice is issued in this case. Note that there is no guarantee that the existing relation is anything like the one that would have been created.\nThe name (optionally schema-qualified) of the table to be created.\nCreates atyped table, which takes its structure from the specified composite type (name optionally schema-qualified). A typed table is tied to its type; for example the table will be dropped if the type is dropped (withDROP TYPE ... CASCADE).\nWhen a typed table is created, then the data types of the columns are determined by the underlying composite type and are not specified by theCREATE TABLEcommand. But theCREATE TABLEcommand can add defaults and constraints to the table and can specify storage parameters.\nThe name of a column to be created in the new table.\nThe data type of the column. This can include array specifiers. For more information on the data types supported byPostgreSQL, refer toChapter 8.\nTheCOLLATEclause assigns a collation to the column (which must be of a collatable data type). If not specified, the column data type's default collation is used.\nThis form sets the storage mode for the column. This controls whether this column is held inline or in a secondaryTOASTtable, and whether the data should be compressed or not.PLAINmust be used for fixed-length values such asintegerand is inline, uncompressed.MAINis for inline, compressible data.EXTERNALis for external, uncompressed data, andEXTENDEDis for external, compressed data. WritingDEFAULTsets the storage mode to the default mode for the column's data type.EXTENDEDis the default for most data types that support non-PLAINstorage. Use ofEXTERNALwill make substring operations on very largetextandbyteavalues run faster, at the penalty of increased storage space. SeeSection 73.2for more information.\nTheCOMPRESSIONclause sets the compression method for the column. Compression is supported only for variable-width data types, and is used only when the column's storage mode ismainorextended. (SeeALTER TABLEfor information on column storage modes.) Setting this property for a partitioned table has no direct effect, because such tables have no storage of their own, but the configured value will be inherited by newly-created partitions. The supported compression methods arepglzandlz4. (lz4is available only if--with-lz4was used when buildingPostgreSQL.) In addition,compression_methodcan bedefaultto explicitly specify the default behavior, which is to consult thedefault_toast_compressionsetting at the time of data insertion to determine the method to use.\nThe optionalINHERITSclause specifies a list of tables from which the new table automatically inherits all columns. Parent tables can be plain tables or foreign tables.\nUse ofINHERITScreates a persistent relationship between the new child table and its parent table(s). Schema modifications to the parent(s) normally propagate to children as well, and by default the data of the child table is included in scans of the parent(s).\nIf the same column name exists in more than one parent table, an error is reported unless the data types of the columns match in each of the parent tables. If there is no conflict, then the duplicate columns are merged to form a single column in the new table. If the column name list of the new table contains a column name that is also inherited, the data type must likewise match the inherited column(s), and the column definitions are merged into one. If the new table explicitly specifies a default value for the column, this default overrides any defaults from inherited declarations of the column. Otherwise, any parents that specify default values for the column must all specify the same default, or an error will be reported.\nCHECKconstraints are merged in essentially the same way as columns: if multiple parent tables and/or the new table definition contain identically-namedCHECKconstraints, these constraints must all have the same check expression, or an error will be reported. Constraints having the same name and expression will be merged into one copy. A constraint markedNO INHERITin a parent will not be considered. Notice that an unnamedCHECKconstraint in the new table will never be merged, since a unique name will always be chosen for it.\nColumnSTORAGEsettings are also copied from parent tables.\nIf a column in the parent table is an identity column, that property is not inherited. A column in the child table can be declared identity column if desired.\nThe optionalPARTITION BYclause specifies a strategy of partitioning the table. The table thus created is called apartitionedtable. The parenthesized list of columns or expressions forms thepartition keyfor the table. When using range or hash partitioning, the partition key can include multiple columns or expressions (up to 32, but this limit can be altered when buildingPostgreSQL), but for list partitioning, the partition key must consist of a single column or expression.\nRange and list partitioning require a btree operator class, while hash partitioning requires a hash operator class. If no operator class is specified explicitly, the default operator class of the appropriate type will be used; if no default operator class exists, an error will be raised. When hash partitioning is used, the operator class used must implement support function 2 (seeSection 38.16.3for details).\nA partitioned table is divided into sub-tables (called partitions), which are created using separateCREATE TABLEcommands. The partitioned table is itself empty. A data row inserted into the table is routed to a partition based on the value of columns or expressions in the partition key. If no existing partition matches the values in the new row, an error will be reported.\nPartitioned tables do not supportEXCLUDEconstraints; however, you can define these constraints on individual partitions.\nSeeSection 5.11for more discussion on table partitioning.\nCreates the table as apartitionof the specified parent table. The table can be created either as a partition for specific values usingFOR VALUESor as a default partition usingDEFAULT. Any indexes, constraints and user-defined row-level triggers that exist in the parent table are cloned on the new partition.\nThepartition_bound_specmust correspond to the partitioning method and partition key of the parent table, and must not overlap with any existing partition of that parent. The form withINis used for list partitioning, the form withFROMandTOis used for range partitioning, and the form withWITHis used for hash partitioning.\npartition_bound_expris any variable-free expression (subqueries, window functions, aggregate functions, and set-returning functions are not allowed). Its data type must match the data type of the corresponding partition key column. The expression is evaluated once at table creation time, so it can even contain volatile expressions such asCURRENT_TIMESTAMP.\nWhen creating a list partition,NULLcan be specified to signify that the partition allows the partition key column to be null. However, there cannot be more than one such list partition for a given parent table.NULLcannot be specified for range partitions.\nWhen creating a range partition, the lower bound specified withFROMis an inclusive bound, whereas the upper bound specified withTOis an exclusive bound. That is, the values specified in theFROMlist are valid values of the corresponding partition key columns for this partition, whereas those in theTOlist are not. Note that this statement must be understood according to the rules of row-wise comparison (Section 9.24.5). For example, givenPARTITION BY RANGE (x,y), a partition boundFROM (1, 2) TO (3, 4)allowsx=1with anyy>=2,x=2with any non-nully, andx=3with anyy<4.\nThe special valuesMINVALUEandMAXVALUEmay be used when creating a range partition to indicate that there is no lower or upper bound on the column's value. For example, a partition defined usingFROM (MINVALUE) TO (10)allows any values less than 10, and a partition defined usingFROM (10) TO (MAXVALUE)allows any values greater than or equal to 10.\nWhen creating a range partition involving more than one column, it can also make sense to useMAXVALUEas part of the lower bound, andMINVALUEas part of the upper bound. For example, a partition defined usingFROM (0, MAXVALUE) TO (10, MAXVALUE)allows any rows where the first partition key column is greater than 0 and less than or equal to 10. Similarly, a partition defined usingFROM ('a', MINVALUE) TO ('b', MINVALUE)allows any rows where the first partition key column starts with \"a\".\nNote that ifMINVALUEorMAXVALUEis used for one column of a partitioning bound, the same value must be used for all subsequent columns. For example,(10, MINVALUE, 0)is not a valid bound; you should write(10, MINVALUE, MINVALUE).\nAlso note that some element types, such astimestamp, have a notion of \"infinity\", which is just another value that can be stored. This is different fromMINVALUEandMAXVALUE, which are not real values that can be stored, but rather they are ways of saying that the value is unbounded.MAXVALUEcan be thought of as being greater than any other value, including \"infinity\" andMINVALUEas being less than any other value, including \"minus infinity\". Thus the rangeFROM ('infinity') TO (MAXVALUE)is not an empty range; it allows precisely one value to be stored — \"infinity\".\nIfDEFAULTis specified, the table will be created as the default partition of the parent table. This option is not available for hash-partitioned tables. A partition key value not fitting into any other partition of the given parent will be routed to the default partition.\nWhen a table has an existingDEFAULTpartition and a new partition is added to it, the default partition must be scanned to verify that it does not contain any rows which properly belong in the new partition. If the default partition contains a large number of rows, this may be slow. The scan will be skipped if the default partition is a foreign table or if it has a constraint which proves that it cannot contain rows which should be placed in the new partition.\nWhen creating a hash partition, a modulus and remainder must be specified. The modulus must be a positive integer, and the remainder must be a non-negative integer less than the modulus. Typically, when initially setting up a hash-partitioned table, you should choose a modulus equal to the number of partitions and assign every table the same modulus and a different remainder (see examples, below). However, it is not required that every partition have the same modulus, only that every modulus which occurs among the partitions of a hash-partitioned table is a factor of the next larger modulus. This allows the number of partitions to be increased incrementally without needing to move all the data at once. For example, suppose you have a hash-partitioned table with 8 partitions, each of which has modulus 8, but find it necessary to increase the number of partitions to 16. You can detach one of the modulus-8 partitions, create two new modulus-16 partitions covering the same portion of the key space (one with a remainder equal to the remainder of the detached partition, and the other with a remainder equal to that value plus 8), and repopulate them with data. You can then repeat this -- perhaps at a later time -- for each modulus-8 partition until none remain. While this may still involve a large amount of data movement at each step, it is still better than having to create a whole new table and move all the data at once.\nA partition must have the same column names and types as the partitioned table to which it belongs. Modifications to the column names or types of a partitioned table will automatically propagate to all partitions.CHECKconstraints will be inherited automatically by every partition, but an individual partition may specify additionalCHECKconstraints; additional constraints with the same name and condition as in the parent will be merged with the parent constraint. Defaults may be specified separately for each partition. But note that a partition's default value is not applied when inserting a tuple through a partitioned table.\nRows inserted into a partitioned table will be automatically routed to the correct partition. If no suitable partition exists, an error will occur.\nOperations such asTRUNCATEwhich normally affect a table and all of its inheritance children will cascade to all partitions, but may also be performed on an individual partition.\nNote that creating a partition usingPARTITION OFrequires taking anACCESS EXCLUSIVElock on the parent partitioned table. Likewise, dropping a partition withDROP TABLErequires taking anACCESS EXCLUSIVElock on the parent table. It is possible to useALTER TABLE ATTACH/DETACH PARTITIONto perform these operations with a weaker lock, thus reducing interference with concurrent operations on the partitioned table.\nTheLIKEclause specifies a table from which the new table automatically copies all column names, their data types, and their not-null constraints.\nUnlikeINHERITS, the new table and original table are completely decoupled after creation is complete. Changes to the original table will not be applied to the new table, and it is not possible to include data of the new table in scans of the original table.\nAlso unlikeINHERITS, columns and constraints copied byLIKEare not merged with similarly named columns and constraints. If the same name is specified explicitly or in anotherLIKEclause, an error is signaled.\nThe optionallike_optionclauses specify which additional properties of the original table to copy. SpecifyingINCLUDINGcopies the property, specifyingEXCLUDINGomits the property.EXCLUDINGis the default. If multiple specifications are made for the same kind of object, the last one is used. The available options are:\nComments for the copied columns, constraints, and indexes will be copied. The default behavior is to exclude comments, resulting in the copied columns and constraints in the new table having no comments.\nCompression method of the columns will be copied. The default behavior is to exclude compression methods, resulting in columns having the default compression method.\nCHECKconstraints will be copied. No distinction is made between column constraints and table constraints. Not-null constraints are always copied to the new table.\nDefault expressions for the copied column definitions will be copied. Otherwise, default expressions are not copied, resulting in the copied columns in the new table having null defaults. Note that copying defaults that call database-modification functions, such asnextval, may create a functional linkage between the original and new tables.\nAny generation expressions of copied column definitions will be copied. By default, new columns will be regular base columns.\nAny identity specifications of copied column definitions will be copied. A new sequence is created for each identity column of the new table, separate from the sequences associated with the old table.\nIndexes,PRIMARY KEY,UNIQUE, andEXCLUDEconstraints on the original table will be created on the new table. Names for the new indexes and constraints are chosen according to the default rules, regardless of how the originals were named. (This behavior avoids possible duplicate-name failures for the new indexes.)\nExtended statistics are copied to the new table.\nSTORAGEsettings for the copied column definitions will be copied. The default behavior is to excludeSTORAGEsettings, resulting in the copied columns in the new table having type-specific default settings. For more onSTORAGEsettings, seeSection 73.2.\nINCLUDING ALLis an abbreviated form selecting all the available individual options. (It could be useful to write individualEXCLUDINGclauses afterINCLUDING ALLto select all but some specific options.)\nTheLIKEclause can also be used to copy column definitions from views, foreign tables, or composite types. Inapplicable options (e.g.,INCLUDING INDEXESfrom a view) are ignored.\nAn optional name for a column or table constraint. If the constraint is violated, the constraint name is present in error messages, so constraint names likecol must be positivecan be used to communicate helpful constraint information to client applications. (Double-quotes are needed to specify constraint names that contain spaces.) If a constraint name is not specified, the system generates a name.\nThe column is not allowed to contain null values.\nThe column is allowed to contain null values. This is the default.\nThis clause is only provided for compatibility with non-standard SQL databases. Its use is discouraged in new applications.\nTheCHECKclause specifies an expression producing a Boolean result which new or updated rows must satisfy for an insert or update operation to succeed. Expressions evaluating to TRUE or UNKNOWN succeed. Should any row of an insert or update operation produce a FALSE result, an error exception is raised and the insert or update does not alter the database. A check constraint specified as a column constraint should reference that column's value only, while an expression appearing in a table constraint can reference multiple columns.\nCurrently,CHECKexpressions cannot contain subqueries nor refer to variables other than columns of the current row (seeSection 5.4.1). The system columntableoidmay be referenced, but not any other system column.\nA constraint marked withNO INHERITwill not propagate to child tables.\nWhen a table has multipleCHECKconstraints, they will be tested for each row in alphabetical order by name, after checkingNOT NULLconstraints. (PostgreSQLversions before 9.5 did not honor any particular firing order forCHECKconstraints.)\nTheDEFAULTclause assigns a default data value for the column whose column definition it appears within. The value is any variable-free expression (in particular, cross-references to other columns in the current table are not allowed). Subqueries are not allowed either. The data type of the default expression must match the data type of the column.\nThe default expression will be used in any insert operation that does not specify a value for the column. If there is no default for a column, then the default is null.\nThis clause creates the column as agenerated column. The column cannot be written to, and when read the result of the specified expression will be returned.\nThe keywordSTOREDis required to signify that the column will be computed on write and will be stored on disk.\nThe generation expression can refer to other columns in the table, but not other generated columns. Any functions and operators used must be immutable. References to other tables are not allowed.\nThis clause creates the column as anidentity column. It will have an implicit sequence attached to it and in newly-inserted rows the column will automatically have values from the sequence assigned to it. Such a column is implicitlyNOT NULL.\nThe clausesALWAYSandBY DEFAULTdetermine how explicitly user-specified values are handled inINSERTandUPDATEcommands.\nIn anINSERTcommand, ifALWAYSis selected, a user-specified value is only accepted if theINSERTstatement specifiesOVERRIDING SYSTEM VALUE. IfBY DEFAULTis selected, then the user-specified value takes precedence. SeeINSERTfor details. (In theCOPYcommand, user-specified values are always used regardless of this setting.)\nIn anUPDATEcommand, ifALWAYSis selected, any update of the column to any value other thanDEFAULTwill be rejected. IfBY DEFAULTis selected, the column can be updated normally. (There is noOVERRIDINGclause for theUPDATEcommand.)\nThe optionalsequence_optionsclause can be used to override the parameters of the sequence. The available options include those shown forCREATE SEQUENCE, plusSEQUENCE NAMEname,LOGGED, andUNLOGGED, which allow selection of the name and persistence level of the sequence. WithoutSEQUENCE NAME, the system chooses an unused name for the sequence. WithoutLOGGEDorUNLOGGED, the sequence will have the same persistence level as the table.\nTheUNIQUEconstraint specifies that a group of one or more columns of a table can contain only unique values. The behavior of a unique table constraint is the same as that of a unique column constraint, with the additional capability to span multiple columns. The constraint therefore enforces that any two rows must differ in at least one of these columns.\nFor the purpose of a unique constraint, null values are not considered equal, unlessNULLS NOT DISTINCTis specified.\nEach unique constraint should name a set of columns that is different from the set of columns named by any other unique or primary key constraint defined for the table. (Otherwise, redundant unique constraints will be discarded.)\nWhen establishing a unique constraint for a multi-level partition hierarchy, all the columns in the partition key of the target partitioned table, as well as those of all its descendant partitioned tables, must be included in the constraint definition.\nAdding a unique constraint will automatically create a unique btree index on the column or group of columns used in the constraint.\nThe optionalINCLUDEclause adds to that index one or more columns that are simply“payload”: uniqueness is not enforced on them, and the index cannot be searched on the basis of those columns. However they can be retrieved by an index-only scan. Note that although the constraint is not enforced on included columns, it still depends on them. Consequently, some operations on such columns (e.g.,DROP COLUMN) can cause cascaded constraint and index deletion.\nThePRIMARY KEYconstraint specifies that a column or columns of a table can contain only unique (non-duplicate), nonnull values. Only one primary key can be specified for a table, whether as a column constraint or a table constraint.\nThe primary key constraint should name a set of columns that is different from the set of columns named by any unique constraint defined for the same table. (Otherwise, the unique constraint is redundant and will be discarded.)\nPRIMARY KEYenforces the same data constraints as a combination ofUNIQUEandNOT NULL. However, identifying a set of columns as the primary key also provides metadata about the design of the schema, since a primary key implies that other tables can rely on this set of columns as a unique identifier for rows.\nWhen placed on a partitioned table,PRIMARY KEYconstraints share the restrictions previously described forUNIQUEconstraints.\nAdding aPRIMARY KEYconstraint will automatically create a unique btree index on the column or group of columns used in the constraint.\nThe optionalINCLUDEclause adds to that index one or more columns that are simply“payload”: uniqueness is not enforced on them, and the index cannot be searched on the basis of those columns. However they can be retrieved by an index-only scan. Note that although the constraint is not enforced on included columns, it still depends on them. Consequently, some operations on such columns (e.g.,DROP COLUMN) can cause cascaded constraint and index deletion.\nTheEXCLUDEclause defines an exclusion constraint, which guarantees that if any two rows are compared on the specified column(s) or expression(s) using the specified operator(s), not all of these comparisons will returnTRUE. If all of the specified operators test for equality, this is equivalent to aUNIQUEconstraint, although an ordinary unique constraint will be faster. However, exclusion constraints can specify constraints that are more general than simple equality. For example, you can specify a constraint that no two rows in the table contain overlapping circles (seeSection 8.8) by using the&&operator. The operator(s) are required to be commutative.\nExclusion constraints are implemented using an index, so each specified operator must be associated with an appropriate operator class (seeSection 11.10) for the index access methodindex_method. Eachexclude_elementdefines a column of the index, so it can optionally specify a collation, an operator class, operator class parameters, and/or ordering options; these are described fully underCREATE INDEX.\nThe access method must supportamgettuple(seeChapter 64); at present this meansGINcannot be used. Although it's allowed, there is little point in using B-tree or hash indexes with an exclusion constraint, because this does nothing that an ordinary unique constraint doesn't do better. So in practice the access method will always beGiSTorSP-GiST.\nThepredicateallows you to specify an exclusion constraint on a subset of the table; internally this creates a partial index. Note that parentheses are required around the predicate.\nThese clauses specify a foreign key constraint, which requires that a group of one or more columns of the new table must only contain values that match values in the referenced column(s) of some row of the referenced table. If therefcolumnlist is omitted, the primary key of thereftableis used. Otherwise, therefcolumnlist must refer to the columns of a non-deferrable unique or primary key constraint or be the columns of a non-partial unique index. The user must haveREFERENCESpermission on the referenced table (either the whole table, or the specific referenced columns). The addition of a foreign key constraint requires aSHARE ROW EXCLUSIVElock on the referenced table. Note that foreign key constraints cannot be defined between temporary tables and permanent tables.\nA value inserted into the referencing column(s) is matched against the values of the referenced table and referenced columns using the given match type. There are three match types:MATCH FULL,MATCH PARTIAL, andMATCH SIMPLE(which is the default).MATCH FULLwill not allow one column of a multicolumn foreign key to be null unless all foreign key columns are null; if they are all null, the row is not required to have a match in the referenced table.MATCH SIMPLEallows any of the foreign key columns to be null; if any of them are null, the row is not required to have a match in the referenced table.MATCH PARTIALis not yet implemented. (Of course,NOT NULLconstraints can be applied to the referencing column(s) to prevent these cases from arising.)\nIn addition, when the data in the referenced columns is changed, certain actions are performed on the data in this table's columns. TheON DELETEclause specifies the action to perform when a referenced row in the referenced table is being deleted. Likewise, theON UPDATEclause specifies the action to perform when a referenced column in the referenced table is being updated to a new value. If the row is updated, but the referenced column is not actually changed, no action is done. Referential actions other than theNO ACTIONcheck cannot be deferred, even if the constraint is declared deferrable. There are the following possible actions for each clause:\nProduce an error indicating that the deletion or update would create a foreign key constraint violation. If the constraint is deferred, this error will be produced at constraint check time if there still exist any referencing rows. This is the default action.\nProduce an error indicating that the deletion or update would create a foreign key constraint violation. This is the same asNO ACTIONexcept that the check is not deferrable.\nDelete any rows referencing the deleted row, or update the values of the referencing column(s) to the new values of the referenced columns, respectively.\nSet all of the referencing columns, or a specified subset of the referencing columns, to null. A subset of columns can only be specified forON DELETEactions.\nSet all of the referencing columns, or a specified subset of the referencing columns, to their default values. A subset of columns can only be specified forON DELETEactions. (There must be a row in the referenced table matching the default values, if they are not null, or the operation will fail.)\nIf the referenced column(s) are changed frequently, it might be wise to add an index to the referencing column(s) so that referential actions associated with the foreign key constraint can be performed more efficiently.\nThis controls whether the constraint can be deferred. A constraint that is not deferrable will be checked immediately after every command. Checking of constraints that are deferrable can be postponed until the end of the transaction (using theSET CONSTRAINTScommand).NOT DEFERRABLEis the default. Currently, onlyUNIQUE,PRIMARY KEY,EXCLUDE, andREFERENCES(foreign key) constraints accept this clause.NOT NULLandCHECKconstraints are not deferrable. Note that deferrable constraints cannot be used as conflict arbitrators in anINSERTstatement that includes anON CONFLICT DO UPDATEclause.\nIf a constraint is deferrable, this clause specifies the default time to check the constraint. If the constraint isINITIALLY IMMEDIATE, it is checked after each statement. This is the default. If the constraint isINITIALLY DEFERRED, it is checked only at the end of the transaction. The constraint check time can be altered with theSET CONSTRAINTScommand.\nThis optional clause specifies the table access method to use to store the contents for the new table; the method needs be an access method of typeTABLE. SeeChapter 63for more information. If this option is not specified, the default table access method is chosen for the new table. Seedefault_table_access_methodfor more information.\nThis clause specifies optional storage parameters for a table or index; seeStorage Parametersbelow for more information. For backward-compatibility theWITHclause for a table can also includeOIDS=FALSEto specify that rows of the new table should not contain OIDs (object identifiers),OIDS=TRUEis not supported anymore.\nThis is backward-compatible syntax for declaring a tableWITHOUT OIDS, creating a tableWITH OIDSis not supported anymore.\nThe behavior of temporary tables at the end of a transaction block can be controlled usingON COMMIT. The three options are:\nNo special action is taken at the ends of transactions. This is the default behavior.\nAll rows in the temporary table will be deleted at the end of each transaction block. Essentially, an automaticTRUNCATEis done at each commit. When used on a partitioned table, this is not cascaded to its partitions.\nThe temporary table will be dropped at the end of the current transaction block. When used on a partitioned table, this action drops its partitions and when used on tables with inheritance children, it drops the dependent children.\nThetablespace_nameis the name of the tablespace in which the new table is to be created. If not specified,default_tablespaceis consulted, ortemp_tablespacesif the table is temporary. For partitioned tables, since no storage is required for the table itself, the tablespace specified overridesdefault_tablespaceas the default tablespace to use for any newly created partitions when no other tablespace is explicitly specified.\nThis clause allows selection of the tablespace in which the index associated with aUNIQUE,PRIMARY KEY, orEXCLUDEconstraint will be created. If not specified,default_tablespaceis consulted, ortemp_tablespacesif the table is temporary.\n"
    },
    {
      "title": "Storage Parameters",
      "text": "TheWITHclause can specifystorage parametersfor tables, and for indexes associated with aUNIQUE,PRIMARY KEY, orEXCLUDEconstraint. Storage parameters for indexes are documented inCREATE INDEX. The storage parameters currently available for tables are listed below. For many of these parameters, as shown, there is an additional parameter with the same name prefixed withtoast., which controls the behavior of the table's secondaryTOASTtable, if any (seeSection 73.2for more information about TOAST). If a table parameter value is set and the equivalenttoast.parameter is not, the TOAST table will use the table's parameter value. Specifying these parameters for partitioned tables is not supported, but you may specify them for individual leaf partitions.\nThe fillfactor for a table is a percentage between 10 and 100. 100 (complete packing) is the default. When a smaller fillfactor is specified,INSERToperations pack table pages only to the indicated percentage; the remaining space on each page is reserved for updating rows on that page. This givesUPDATEa chance to place the updated copy of a row on the same page as the original, which is more efficient than placing it on a different page, and makesheap-only tuple updatesmore likely. For a table whose entries are never updated, complete packing is the best choice, but in heavily updated tables smaller fillfactors are appropriate. This parameter cannot be set for TOAST tables.\nThe toast_tuple_target specifies the minimum tuple length required before we try to compress and/or move long column values into TOAST tables, and is also the target length we try to reduce the length below once toasting begins. This affects columns marked as External (for move), Main (for compression), or Extended (for both) and applies only to new tuples. There is no effect on existing rows. By default this parameter is set to allow at least 4 tuples per block, which with the default block size will be 2040 bytes. Valid values are between 128 bytes and the (block size - header), by default 8160 bytes. Changing this value may not be useful for very short or very long rows. Note that the default setting is often close to optimal, and it is possible that setting this parameter could have negative effects in some cases. This parameter cannot be set for TOAST tables.\nThis sets the number of workers that should be used to assist a parallel scan of this table. If not set, the system will determine a value based on the relation size. The actual number of workers chosen by the planner or by utility statements that use parallel scans may be less, for example due to the setting ofmax_worker_processes.\nEnables or disables the autovacuum daemon for a particular table. If true, the autovacuum daemon will perform automaticVACUUMand/orANALYZEoperations on this table following the rules discussed inSection 25.1.6. If false, this table will not be autovacuumed, except to prevent transaction ID wraparound. SeeSection 25.1.5for more about wraparound prevention. Note that the autovacuum daemon does not run at all (except to prevent transaction ID wraparound) if theautovacuumparameter is false; setting individual tables' storage parameters does not override that. Therefore there is seldom much point in explicitly setting this storage parameter totrue, only tofalse.\nForces or disables index cleanup whenVACUUMis run on this table. The default value isAUTO. WithOFF, index cleanup is disabled, withONit is enabled, and withAUTOa decision is made dynamically, each timeVACUUMruns. The dynamic behavior allowsVACUUMto avoid needlessly scanning indexes to remove very few dead tuples. Forcibly disabling all index cleanup can speed upVACUUMvery significantly, but may also lead to severely bloated indexes if table modifications are frequent. TheINDEX_CLEANUPparameter ofVACUUM, if specified, overrides the value of this option.\nEnables or disables vacuum to try to truncate off any empty pages at the end of this table. The default value istrue. Iftrue,VACUUMand autovacuum do the truncation and the disk space for the truncated pages is returned to the operating system. Note that the truncation requiresACCESS EXCLUSIVElock on the table. TheTRUNCATEparameter ofVACUUM, if specified, overrides the value of this option.\nPer-table value forautovacuum_vacuum_thresholdparameter.\nPer-table value forautovacuum_vacuum_scale_factorparameter.\nPer-table value forautovacuum_vacuum_insert_thresholdparameter. The special value of -1 may be used to disable insert vacuums on the table.\nPer-table value forautovacuum_vacuum_insert_scale_factorparameter.\nPer-table value forautovacuum_analyze_thresholdparameter.\nPer-table value forautovacuum_analyze_scale_factorparameter.\nPer-table value forautovacuum_vacuum_cost_delayparameter.\nPer-table value forautovacuum_vacuum_cost_limitparameter.\nPer-table value forvacuum_freeze_min_ageparameter. Note that autovacuum will ignore per-tableautovacuum_freeze_min_ageparameters that are larger than half the system-wideautovacuum_freeze_max_agesetting.\nPer-table value forautovacuum_freeze_max_ageparameter. Note that autovacuum will ignore per-tableautovacuum_freeze_max_ageparameters that are larger than the system-wide setting (it can only be set smaller).\nPer-table value forvacuum_freeze_table_ageparameter.\nPer-table value forvacuum_multixact_freeze_min_ageparameter. Note that autovacuum will ignore per-tableautovacuum_multixact_freeze_min_ageparameters that are larger than half the system-wideautovacuum_multixact_freeze_max_agesetting.\nPer-table value forautovacuum_multixact_freeze_max_ageparameter. Note that autovacuum will ignore per-tableautovacuum_multixact_freeze_max_ageparameters that are larger than the system-wide setting (it can only be set smaller).\nPer-table value forvacuum_multixact_freeze_table_ageparameter.\nPer-table value forlog_autovacuum_min_durationparameter.\nDeclare the table as an additional catalog table for purposes of logical replication. SeeSection 49.6.2for details. This parameter cannot be set for TOAST tables.\n"
    },
    {
      "title": "Notes",
      "text": "PostgreSQLautomatically creates an index for each unique constraint and primary key constraint to enforce uniqueness. Thus, it is not necessary to create an index explicitly for primary key columns. (SeeCREATE INDEXfor more information.)\nUnique constraints and primary keys are not inherited in the current implementation. This makes the combination of inheritance and unique constraints rather dysfunctional.\nA table cannot have more than 1600 columns. (In practice, the effective limit is usually lower because of tuple-length constraints.)\n"
    },
    {
      "title": "Examples",
      "text": "Create tablefilmsand tabledistributors:\n\n\nCODE:\n\nCREATE TABLE films (\n    code        char(5) CONSTRAINT firstkey PRIMARY KEY,\n    title       varchar(40) NOT NULL,\n    did         integer NOT NULL,\n    date_prod   date,\n    kind        varchar(10),\n    len         interval hour to minute\n);\n\nCREATE TABLE distributors (\n     did    integer PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,\n     name   varchar(40) NOT NULL CHECK (name <> '')\n);\n\nCreate a table with a 2-dimensional array:\n\n\nCODE:\n\nCREATE TABLE array_int (\n    vector  int[][]\n);\n\nDefine a unique table constraint for the tablefilms. Unique table constraints can be defined on one or more columns of the table:\n\n\nCODE:\n\nCREATE TABLE films (\n    code        char(5),\n    title       varchar(40),\n    did         integer,\n    date_prod   date,\n    kind        varchar(10),\n    len         interval hour to minute,\n    CONSTRAINT production UNIQUE(date_prod)\n);\n\nDefine a check column constraint:\n\n\nCODE:\n\nCREATE TABLE distributors (\n    did     integer CHECK (did > 100),\n    name    varchar(40)\n);\n\nDefine a check table constraint:\n\n\nCODE:\n\nCREATE TABLE distributors (\n    did     integer,\n    name    varchar(40),\n    CONSTRAINT con1 CHECK (did > 100 AND name <> '')\n);\n\nDefine a primary key table constraint for the tablefilms:\n\n\nCODE:\n\nCREATE TABLE films (\n    code        char(5),\n    title       varchar(40),\n    did         integer,\n    date_prod   date,\n    kind        varchar(10),\n    len         interval hour to minute,\n    CONSTRAINT code_title PRIMARY KEY(code,title)\n);\n\nDefine a primary key constraint for tabledistributors. The following two examples are equivalent, the first using the table constraint syntax, the second the column constraint syntax:\n\n\nCODE:\n\nCREATE TABLE distributors (\n    did     integer,\n    name    varchar(40),\n    PRIMARY KEY(did)\n);\n\nCREATE TABLE distributors (\n    did     integer PRIMARY KEY,\n    name    varchar(40)\n);\n\nAssign a literal constant default value for the columnname, arrange for the default value of columndidto be generated by selecting the next value of a sequence object, and make the default value ofmodtimebe the time at which the row is inserted:\n\n\nCODE:\n\nCREATE TABLE distributors (\n    name      varchar(40) DEFAULT 'Luso Films',\n    did       integer DEFAULT nextval('distributors_serial'),\n    modtime   timestamp DEFAULT current_timestamp\n);\n\nDefine twoNOT NULLcolumn constraints on the tabledistributors, one of which is explicitly given a name:\n\n\nCODE:\n\nCREATE TABLE distributors (\n    did     integer CONSTRAINT no_null NOT NULL,\n    name    varchar(40) NOT NULL\n);\n\nDefine a unique constraint for thenamecolumn:\n\n\nCODE:\n\nCREATE TABLE distributors (\n    did     integer,\n    name    varchar(40) UNIQUE\n);\n\nThe same, specified as a table constraint:\n\n\nCODE:\n\nCREATE TABLE distributors (\n    did     integer,\n    name    varchar(40),\n    UNIQUE(name)\n);\n\nCreate the same table, specifying 70% fill factor for both the table and its unique index:\n\n\nCODE:\n\nCREATE TABLE distributors (\n    did     integer,\n    name    varchar(40),\n    UNIQUE(name) WITH (fillfactor=70)\n)\nWITH (fillfactor=70);\n\nCreate tablecircleswith an exclusion constraint that prevents any two circles from overlapping:\n\n\nCODE:\n\nCREATE TABLE circles (\n    c circle,\n    EXCLUDE USING gist (c WITH &&)\n);\n\nCreate tablecinemasin tablespacediskvol1:\n\n\nCODE:\n\nCREATE TABLE cinemas (\n        id serial,\n        name text,\n        location text\n) TABLESPACE diskvol1;\n\nCreate a composite type and a typed table:\n\n\nCODE:\n\nCREATE TYPE employee_type AS (name text, salary numeric);\n\nCREATE TABLE employees OF employee_type (\n    PRIMARY KEY (name),\n    salary WITH OPTIONS DEFAULT 1000\n);\n\nCreate a range partitioned table:\n\n\nCODE:\n\nCREATE TABLE measurement (\n    logdate         date not null,\n    peaktemp        int,\n    unitsales       int\n) PARTITION BY RANGE (logdate);\n\nCreate a range partitioned table with multiple columns in the partition key:\n\n\nCODE:\n\nCREATE TABLE measurement_year_month (\n    logdate         date not null,\n    peaktemp        int,\n    unitsales       int\n) PARTITION BY RANGE (EXTRACT(YEAR FROM logdate), EXTRACT(MONTH FROM logdate));\n\nCreate a list partitioned table:\n\n\nCODE:\n\nCREATE TABLE cities (\n    city_id      bigserial not null,\n    name         text not null,\n    population   bigint\n) PARTITION BY LIST (left(lower(name), 1));\n\nCreate a hash partitioned table:\n\n\nCODE:\n\nCREATE TABLE orders (\n    order_id     bigint not null,\n    cust_id      bigint not null,\n    status       text\n) PARTITION BY HASH (order_id);\n\nCreate partition of a range partitioned table:\n\n\nCODE:\n\nCREATE TABLE measurement_y2016m07\n    PARTITION OF measurement (\n    unitsales DEFAULT 0\n) FOR VALUES FROM ('2016-07-01') TO ('2016-08-01');\n\nCreate a few partitions of a range partitioned table with multiple columns in the partition key:\n\n\nCODE:\n\nCREATE TABLE measurement_ym_older\n    PARTITION OF measurement_year_month\n    FOR VALUES FROM (MINVALUE, MINVALUE) TO (2016, 11);\n\nCREATE TABLE measurement_ym_y2016m11\n    PARTITION OF measurement_year_month\n    FOR VALUES FROM (2016, 11) TO (2016, 12);\n\nCREATE TABLE measurement_ym_y2016m12\n    PARTITION OF measurement_year_month\n    FOR VALUES FROM (2016, 12) TO (2017, 01);\n\nCREATE TABLE measurement_ym_y2017m01\n    PARTITION OF measurement_year_month\n    FOR VALUES FROM (2017, 01) TO (2017, 02);\n\nCreate partition of a list partitioned table:\n\n\nCODE:\n\nCREATE TABLE cities_ab\n    PARTITION OF cities (\n    CONSTRAINT city_id_nonzero CHECK (city_id != 0)\n) FOR VALUES IN ('a', 'b');\n\nCreate partition of a list partitioned table that is itself further partitioned and then add a partition to it:\n\n\nCODE:\n\nCREATE TABLE cities_ab\n    PARTITION OF cities (\n    CONSTRAINT city_id_nonzero CHECK (city_id != 0)\n) FOR VALUES IN ('a', 'b') PARTITION BY RANGE (population);\n\nCREATE TABLE cities_ab_10000_to_100000\n    PARTITION OF cities_ab FOR VALUES FROM (10000) TO (100000);\n\nCreate partitions of a hash partitioned table:\n\n\nCODE:\n\nCREATE TABLE orders_p1 PARTITION OF orders\n    FOR VALUES WITH (MODULUS 4, REMAINDER 0);\nCREATE TABLE orders_p2 PARTITION OF orders\n    FOR VALUES WITH (MODULUS 4, REMAINDER 1);\nCREATE TABLE orders_p3 PARTITION OF orders\n    FOR VALUES WITH (MODULUS 4, REMAINDER 2);\nCREATE TABLE orders_p4 PARTITION OF orders\n    FOR VALUES WITH (MODULUS 4, REMAINDER 3);\n\nCreate a default partition:\n\n\nCODE:\n\nCREATE TABLE cities_partdef\n    PARTITION OF cities DEFAULT;\n\n"
    },
    {
      "title": "Compatibility",
      "text": "TheCREATE TABLEcommand conforms to theSQLstandard, with exceptions listed below.\n"
    },
    {
      "title": "Temporary Tables",
      "text": "Although the syntax ofCREATE TEMPORARY TABLEresembles that of the SQL standard, the effect is not the same. In the standard, temporary tables are defined just once and automatically exist (starting with empty contents) in every session that needs them.PostgreSQLinstead requires each session to issue its ownCREATE TEMPORARY TABLEcommand for each temporary table to be used. This allows different sessions to use the same temporary table name for different purposes, whereas the standard's approach constrains all instances of a given temporary table name to have the same table structure.\nThe standard's definition of the behavior of temporary tables is widely ignored.PostgreSQL's behavior on this point is similar to that of several other SQL databases.\nThe SQL standard also distinguishes between global and local temporary tables, where a local temporary table has a separate set of contents for each SQL module within each session, though its definition is still shared across sessions. SincePostgreSQLdoes not support SQL modules, this distinction is not relevant inPostgreSQL.\nFor compatibility's sake,PostgreSQLwill accept theGLOBALandLOCALkeywords in a temporary table declaration, but they currently have no effect. Use of these keywords is discouraged, since future versions ofPostgreSQLmight adopt a more standard-compliant interpretation of their meaning.\nTheON COMMITclause for temporary tables also resembles the SQL standard, but has some differences. If theON COMMITclause is omitted, SQL specifies that the default behavior isON COMMIT DELETE ROWS. However, the default behavior inPostgreSQLisON COMMIT PRESERVE ROWS. TheON COMMIT DROPoption does not exist in SQL.\n"
    },
    {
      "title": "Non-Deferred Uniqueness Constraints",
      "text": "When aUNIQUEorPRIMARY KEYconstraint is not deferrable,PostgreSQLchecks for uniqueness immediately whenever a row is inserted or modified. The SQL standard says that uniqueness should be enforced only at the end of the statement; this makes a difference when, for example, a single command updates multiple key values. To obtain standard-compliant behavior, declare the constraint asDEFERRABLEbut not deferred (i.e.,INITIALLY IMMEDIATE). Be aware that this can be significantly slower than immediate uniqueness checking.\n"
    },
    {
      "title": "Column Check Constraints",
      "text": "The SQL standard says thatCHECKcolumn constraints can only refer to the column they apply to; onlyCHECKtable constraints can refer to multiple columns.PostgreSQLdoes not enforce this restriction; it treats column and table check constraints alike.\n"
    },
    {
      "title": "EXCLUDEConstraint",
      "text": "TheEXCLUDEconstraint type is aPostgreSQLextension.\n"
    },
    {
      "title": "Foreign Key Constraints",
      "text": "The ability to specify column lists in the foreign key actionsSET DEFAULTandSET NULLis aPostgreSQLextension.\nIt is aPostgreSQLextension that a foreign key constraint may reference columns of a unique index instead of columns of a primary key or unique constraint.\n"
    },
    {
      "title": "NULL“Constraint”",
      "text": "TheNULL“constraint”(actually a non-constraint) is aPostgreSQLextension to the SQL standard that is included for compatibility with some other database systems (and for symmetry with theNOT NULLconstraint). Since it is the default for any column, its presence is simply noise.\n"
    },
    {
      "title": "Constraint Naming",
      "text": "The SQL standard says that table and domain constraints must have names that are unique across the schema containing the table or domain.PostgreSQLis laxer: it only requires constraint names to be unique across the constraints attached to a particular table or domain. However, this extra freedom does not exist for index-based constraints (UNIQUE,PRIMARY KEY, andEXCLUDEconstraints), because the associated index is named the same as the constraint, and index names must be unique across all relations within the same schema.\nCurrently,PostgreSQLdoes not record names forNOT NULLconstraints at all, so they are not subject to the uniqueness restriction. This might change in a future release.\n"
    },
    {
      "title": "Inheritance",
      "text": "Multiple inheritance via theINHERITSclause is aPostgreSQLlanguage extension. SQL:1999 and later define single inheritance using a different syntax and different semantics. SQL:1999-style inheritance is not yet supported byPostgreSQL.\n"
    },
    {
      "title": "Zero-Column Tables",
      "text": "PostgreSQLallows a table of no columns to be created (for example,CREATE TABLE foo();). This is an extension from the SQL standard, which does not allow zero-column tables. Zero-column tables are not in themselves very useful, but disallowing them creates odd special cases forALTER TABLE DROP COLUMN, so it seems cleaner to ignore this spec restriction.\n"
    },
    {
      "title": "Multiple Identity Columns",
      "text": "PostgreSQLallows a table to have more than one identity column. The standard specifies that a table can have at most one identity column. This is relaxed mainly to give more flexibility for doing schema changes or migrations. Note that theINSERTcommand supports only one override clause that applies to the entire statement, so having multiple identity columns with different behaviors is not well supported.\n"
    },
    {
      "title": "Generated Columns",
      "text": "The optionSTOREDis not standard but is also used by other SQL implementations. The SQL standard does not specify the storage of generated columns.\n"
    },
    {
      "title": "LIKEClause",
      "text": "While aLIKEclause exists in the SQL standard, many of the options thatPostgreSQLaccepts for it are not in the standard, and some of the standard's options are not implemented byPostgreSQL.\n"
    },
    {
      "title": "WITHClause",
      "text": "TheWITHclause is aPostgreSQLextension; storage parameters are not in the standard.\n"
    },
    {
      "title": "Tablespaces",
      "text": "ThePostgreSQLconcept of tablespaces is not part of the standard. Hence, the clausesTABLESPACEandUSING INDEX TABLESPACEare extensions.\n"
    },
    {
      "title": "Typed Tables",
      "text": "Typed tables implement a subset of the SQL standard. According to the standard, a typed table has columns corresponding to the underlying composite type as well as one other column that is the“self-referencing column”.PostgreSQLdoes not support self-referencing columns explicitly.\n"
    },
    {
      "title": "PARTITION BYClause",
      "text": "ThePARTITION BYclause is aPostgreSQLextension.\n"
    },
    {
      "title": "PARTITION OFClause",
      "text": "ThePARTITION OFclause is aPostgreSQLextension.\n"
    }
  ]
}