{
  "doc_name": "sql-altertable",
  "url": "https://www.postgresql.org/docs/16/sql-altertable.html",
  "sections": [
    {
      "title": "ALTER TABLE",
      "text": "ALTER TABLE — change the definition of a table\n"
    },
    {
      "title": "Synopsis",
      "text": "\n\nCODE:\n\nALTER TABLE [ IF EXISTS ] [ ONLY ] name [ * ]\n    action [, ... ]\nALTER TABLE [ IF EXISTS ] [ ONLY ] name [ * ]\n    RENAME [ COLUMN ] column_name TO new_column_name\nALTER TABLE [ IF EXISTS ] [ ONLY ] name [ * ]\n    RENAME CONSTRAINT constraint_name TO new_constraint_name\nALTER TABLE [ IF EXISTS ] name\n    RENAME TO new_name\nALTER TABLE [ IF EXISTS ] name\n    SET SCHEMA new_schema\nALTER TABLE ALL IN TABLESPACE name [ OWNED BY role_name [, ... ] ]\n    SET TABLESPACE new_tablespace [ NOWAIT ]\nALTER TABLE [ IF EXISTS ] name\n    ATTACH PARTITION partition_name { FOR VALUES partition_bound_spec | DEFAULT }\nALTER TABLE [ IF EXISTS ] name\n    DETACH PARTITION partition_name [ CONCURRENTLY | FINALIZE ]\n\nwhere action is one of:\n\n    ADD [ COLUMN ] [ IF NOT EXISTS ] column_name data_type [ COLLATE collation ] [ column_constraint [ ... ] ]\n    DROP [ COLUMN ] [ IF EXISTS ] column_name [ RESTRICT | CASCADE ]\n    ALTER [ COLUMN ] column_name [ SET DATA ] TYPE data_type [ COLLATE collation ] [ USING expression ]\n    ALTER [ COLUMN ] column_name SET DEFAULT expression\n    ALTER [ COLUMN ] column_name DROP DEFAULT\n    ALTER [ COLUMN ] column_name { SET | DROP } NOT NULL\n    ALTER [ COLUMN ] column_name DROP EXPRESSION [ IF EXISTS ]\n    ALTER [ COLUMN ] column_name ADD GENERATED { ALWAYS | BY DEFAULT } AS IDENTITY [ ( sequence_options ) ]\n    ALTER [ COLUMN ] column_name { SET GENERATED { ALWAYS | BY DEFAULT } | SET sequence_option | RESTART [ [ WITH ] restart ] } [...]\n    ALTER [ COLUMN ] column_name DROP IDENTITY [ IF EXISTS ]\n    ALTER [ COLUMN ] column_name SET STATISTICS integer\n    ALTER [ COLUMN ] column_name SET ( attribute_option = value [, ... ] )\n    ALTER [ COLUMN ] column_name RESET ( attribute_option [, ... ] )\n    ALTER [ COLUMN ] column_name SET STORAGE { PLAIN | EXTERNAL | EXTENDED | MAIN | DEFAULT }\n    ALTER [ COLUMN ] column_name SET COMPRESSION compression_method\n    ADD table_constraint [ NOT VALID ]\n    ADD table_constraint_using_index\n    ALTER CONSTRAINT constraint_name [ DEFERRABLE | NOT DEFERRABLE ] [ INITIALLY DEFERRED | INITIALLY IMMEDIATE ]\n    VALIDATE CONSTRAINT constraint_name\n    DROP CONSTRAINT [ IF EXISTS ]  constraint_name [ RESTRICT | CASCADE ]\n    DISABLE TRIGGER [ trigger_name | ALL | USER ]\n    ENABLE TRIGGER [ trigger_name | ALL | USER ]\n    ENABLE REPLICA TRIGGER trigger_name\n    ENABLE ALWAYS TRIGGER trigger_name\n    DISABLE RULE rewrite_rule_name\n    ENABLE RULE rewrite_rule_name\n    ENABLE REPLICA RULE rewrite_rule_name\n    ENABLE ALWAYS RULE rewrite_rule_name\n    DISABLE ROW LEVEL SECURITY\n    ENABLE ROW LEVEL SECURITY\n    FORCE ROW LEVEL SECURITY\n    NO FORCE ROW LEVEL SECURITY\n    CLUSTER ON index_name\n    SET WITHOUT CLUSTER\n    SET WITHOUT OIDS\n    SET ACCESS METHOD new_access_method\n    SET TABLESPACE new_tablespace\n    SET { LOGGED | UNLOGGED }\n    SET ( storage_parameter [= value] [, ... ] )\n    RESET ( storage_parameter [, ... ] )\n    INHERIT parent_table\n    NO INHERIT parent_table\n    OF type_name\n    NOT OF\n    OWNER TO { new_owner | CURRENT_ROLE | CURRENT_USER | SESSION_USER }\n    REPLICA IDENTITY { DEFAULT | USING INDEX index_name | FULL | NOTHING }\n\nand partition_bound_spec is:\n\nIN ( partition_bound_expr [, ...] ) |\nFROM ( { partition_bound_expr | MINVALUE | MAXVALUE } [, ...] )\n  TO ( { partition_bound_expr | MINVALUE | MAXVALUE } [, ...] ) |\nWITH ( MODULUS numeric_literal, REMAINDER numeric_literal )\n\nand column_constraint is:\n\n[ CONSTRAINT constraint_name ]\n{ NOT NULL |\n  NULL |\n  CHECK ( expression ) [ NO INHERIT ] |\n  DEFAULT default_expr |\n  GENERATED ALWAYS AS ( generation_expr ) STORED |\n  GENERATED { ALWAYS | BY DEFAULT } AS IDENTITY [ ( sequence_options ) ] |\n  UNIQUE [ NULLS [ NOT ] DISTINCT ] index_parameters |\n  PRIMARY KEY index_parameters |\n  REFERENCES reftable [ ( refcolumn ) ] [ MATCH FULL | MATCH PARTIAL | MATCH SIMPLE ]\n    [ ON DELETE referential_action ] [ ON UPDATE referential_action ] }\n[ DEFERRABLE | NOT DEFERRABLE ] [ INITIALLY DEFERRED | INITIALLY IMMEDIATE ]\n\nand table_constraint is:\n\n[ CONSTRAINT constraint_name ]\n{ CHECK ( expression ) [ NO INHERIT ] |\n  UNIQUE [ NULLS [ NOT ] DISTINCT ] ( column_name [, ... ] ) index_parameters |\n  PRIMARY KEY ( column_name [, ... ] ) index_parameters |\n  EXCLUDE [ USING index_method ] ( exclude_element WITH operator [, ... ] ) index_parameters [ WHERE ( predicate ) ] |\n  FOREIGN KEY ( column_name [, ... ] ) REFERENCES reftable [ ( refcolumn [, ... ] ) ]\n    [ MATCH FULL | MATCH PARTIAL | MATCH SIMPLE ] [ ON DELETE referential_action ] [ ON UPDATE referential_action ] }\n[ DEFERRABLE | NOT DEFERRABLE ] [ INITIALLY DEFERRED | INITIALLY IMMEDIATE ]\n\nand table_constraint_using_index is:\n\n    [ CONSTRAINT constraint_name ]\n    { UNIQUE | PRIMARY KEY } USING INDEX index_name\n    [ DEFERRABLE | NOT DEFERRABLE ] [ INITIALLY DEFERRED | INITIALLY IMMEDIATE ]\n\nindex_parameters in UNIQUE, PRIMARY KEY, and EXCLUDE constraints are:\n\n[ INCLUDE ( column_name [, ... ] ) ]\n[ WITH ( storage_parameter [= value] [, ... ] ) ]\n[ USING INDEX TABLESPACE tablespace_name ]\n\nexclude_element in an EXCLUDE constraint is:\n\n{ column_name | ( expression ) } [ COLLATE collation ] [ opclass [ ( opclass_parameter = value [, ... ] ) ] ] [ ASC | DESC ] [ NULLS { FIRST | LAST } ]\n\nreferential_action in a FOREIGN KEY/REFERENCES constraint is:\n\n{ NO ACTION | RESTRICT | CASCADE | SET NULL [ ( column_name [, ... ] ) ] | SET DEFAULT [ ( column_name [, ... ] ) ] }\n\n"
    },
    {
      "title": "Description",
      "text": "ALTER TABLEchanges the definition of an existing table. There are several subforms described below. Note that the lock level required may differ for each subform. AnACCESS EXCLUSIVElock is acquired unless explicitly noted. When multiple subcommands are given, the lock acquired will be the strictest one required by any subcommand.\nThis form adds a new column to the table, using the same syntax asCREATE TABLE. IfIF NOT EXISTSis specified and a column already exists with this name, no error is thrown.\nThis form drops a column from a table. Indexes and table constraints involving the column will be automatically dropped as well. Multivariate statistics referencing the dropped column will also be removed if the removal of the column would cause the statistics to contain data for only a single column. You will need to sayCASCADEif anything outside the table depends on the column, for example, foreign key references or views. IfIF EXISTSis specified and the column does not exist, no error is thrown. In this case a notice is issued instead.\nThis form changes the type of a column of a table. Indexes and simple table constraints involving the column will be automatically converted to use the new column type by reparsing the originally supplied expression. The optionalCOLLATEclause specifies a collation for the new column; if omitted, the collation is the default for the new column type. The optionalUSINGclause specifies how to compute the new column value from the old; if omitted, the default conversion is the same as an assignment cast from old data type to new. AUSINGclause must be provided if there is no implicit or assignment cast from old to new type.\nWhen this form is used, the column's statistics are removed, so runningANALYZEon the table afterwards is recommended.\nThese forms set or remove the default value for a column (where removal is equivalent to setting the default value to NULL). The new default value will only apply in subsequentINSERTorUPDATEcommands; it does not cause rows already in the table to change.\nThese forms change whether a column is marked to allow null values or to reject null values.\nSET NOT NULLmay only be applied to a column provided none of the records in the table contain aNULLvalue for the column. Ordinarily this is checked during theALTER TABLEby scanning the entire table; however, if a validCHECKconstraint exists (and is not dropped in the same command) which proves noNULLcan exist, then the table scan is skipped.\nIf this table is a partition, one cannot performDROP NOT NULLon a column if it is markedNOT NULLin the parent table. To drop theNOT NULLconstraint from all the partitions, performDROP NOT NULLon the parent table. Even if there is noNOT NULLconstraint on the parent, such a constraint can still be added to individual partitions, if desired; that is, the children can disallow nulls even if the parent allows them, but not the other way around.\nThis form turns a stored generated column into a normal base column. Existing data in the columns is retained, but future changes will no longer apply the generation expression.\nIfDROP EXPRESSION IF EXISTSis specified and the column is not a stored generated column, no error is thrown. In this case a notice is issued instead.\nThese forms change whether a column is an identity column or change the generation attribute of an existing identity column. SeeCREATE TABLEfor details. LikeSET DEFAULT, these forms only affect the behavior of subsequentINSERTandUPDATEcommands; they do not cause rows already in the table to change.\nIfDROP IDENTITY IF EXISTSis specified and the column is not an identity column, no error is thrown. In this case a notice is issued instead.\nThese forms alter the sequence that underlies an existing identity column.sequence_optionis an option supported byALTER SEQUENCEsuch asINCREMENT BY.\nThis form sets the per-column statistics-gathering target for subsequentANALYZEoperations. The target can be set in the range 0 to 10000; alternatively, set it to -1 to revert to using the system default statistics target (default_statistics_target). For more information on the use of statistics by thePostgreSQLquery planner, refer toSection 14.2.\nSET STATISTICSacquires aSHARE UPDATE EXCLUSIVElock.\nThis form sets or resets per-attribute options. Currently, the only defined per-attribute options aren_distinctandn_distinct_inherited, which override the number-of-distinct-values estimates made by subsequentANALYZEoperations.n_distinctaffects the statistics for the table itself, whilen_distinct_inheritedaffects the statistics gathered for the table plus its inheritance children, and for the statistics gathered for partitioned tables. When the value specified is a positive value, the query planner will assume that the column contains exactly the specified number of distinct nonnull values. Fractional values may also be specified by using values below 0 and above or equal to -1. This instructs the query planner to estimate the number of distinct values by multiplying the absolute value of the specified number by the estimated number of rows in the table. For example, a value of -1 implies that all values in the column are distinct, while a value of -0.5 implies that each value appears twice on average. This can be useful when the size of the table changes over time. For more information on the use of statistics by thePostgreSQLquery planner, refer toSection 14.2.\nChanging per-attribute options acquires aSHARE UPDATE EXCLUSIVElock.\nThis form sets the storage mode for a column. This controls whether this column is held inline or in a secondaryTOASTtable, and whether the data should be compressed or not.PLAINmust be used for fixed-length values such asintegerand is inline, uncompressed.MAINis for inline, compressible data.EXTERNALis for external, uncompressed data, andEXTENDEDis for external, compressed data. WritingDEFAULTsets the storage mode to the default mode for the column's data type.EXTENDEDis the default for most data types that support non-PLAINstorage. Use ofEXTERNALwill make substring operations on very largetextandbyteavalues run faster, at the penalty of increased storage space. Note thatALTER TABLE ... SET STORAGEdoesn't itself change anything in the table; it just sets the strategy to be pursued during future table updates. SeeSection 73.2for more information.\nThis form sets the compression method for a column, determining how values inserted in future will be compressed (if the storage mode permits compression at all). This does not cause the table to be rewritten, so existing data may still be compressed with other compression methods. If the table is restored withpg_restore, then all values are rewritten with the configured compression method. However, when data is inserted from another relation (for example, byINSERT ... SELECT), values from the source table are not necessarily detoasted, so any previously compressed data may retain its existing compression method, rather than being recompressed with the compression method of the target column. The supported compression methods arepglzandlz4. (lz4is available only if--with-lz4was used when buildingPostgreSQL.) In addition,compression_methodcan bedefault, which selects the default behavior of consulting thedefault_toast_compressionsetting at the time of data insertion to determine the method to use.\nThis form adds a new constraint to a table using the same constraint syntax asCREATE TABLE, plus the optionNOT VALID, which is currently only allowed for foreign key and CHECK constraints.\nNormally, this form will cause a scan of the table to verify that all existing rows in the table satisfy the new constraint. But if theNOT VALIDoption is used, this potentially-lengthy scan is skipped. The constraint will still be enforced against subsequent inserts or updates (that is, they'll fail unless there is a matching row in the referenced table, in the case of foreign keys, or they'll fail unless the new row matches the specified check condition). But the database will not assume that the constraint holds for all rows in the table, until it is validated by using theVALIDATE CONSTRAINToption. SeeNotesbelow for more information about using theNOT VALIDoption.\nAlthough most forms ofADDtable_constraintrequire anACCESS EXCLUSIVElock,ADD FOREIGN KEYrequires only aSHARE ROW EXCLUSIVElock. Note thatADD FOREIGN KEYalso acquires aSHARE ROW EXCLUSIVElock on the referenced table, in addition to the lock on the table on which the constraint is declared.\nAdditional restrictions apply when unique or primary key constraints are added to partitioned tables; seeCREATE TABLE. Also, foreign key constraints on partitioned tables may not be declaredNOT VALIDat present.\nThis form adds a newPRIMARY KEYorUNIQUEconstraint to a table based on an existing unique index. All the columns of the index will be included in the constraint.\nThe index cannot have expression columns nor be a partial index. Also, it must be a b-tree index with default sort ordering. These restrictions ensure that the index is equivalent to one that would be built by a regularADD PRIMARY KEYorADD UNIQUEcommand.\nIfPRIMARY KEYis specified, and the index's columns are not already markedNOT NULL, then this command will attempt to doALTER COLUMN SET NOT NULLagainst each such column. That requires a full table scan to verify the column(s) contain no nulls. In all other cases, this is a fast operation.\nIf a constraint name is provided then the index will be renamed to match the constraint name. Otherwise the constraint will be named the same as the index.\nAfter this command is executed, the index is“owned”by the constraint, in the same way as if the index had been built by a regularADD PRIMARY KEYorADD UNIQUEcommand. In particular, dropping the constraint will make the index disappear too.\nThis form is not currently supported on partitioned tables.\n"
    },
    {
      "title": "Note",
      "text": "Adding a constraint using an existing index can be helpful in situations where a new constraint needs to be added without blocking table updates for a long time. To do that, create the index usingCREATE INDEX CONCURRENTLY, and then install it as an official constraint using this syntax. See the example below.\nThis form alters the attributes of a constraint that was previously created. Currently only foreign key constraints may be altered.\nThis form validates a foreign key or check constraint that was previously created asNOT VALID, by scanning the table to ensure there are no rows for which the constraint is not satisfied. Nothing happens if the constraint is already marked valid. (SeeNotesbelow for an explanation of the usefulness of this command.)\nThis command acquires aSHARE UPDATE EXCLUSIVElock.\nThis form drops the specified constraint on a table, along with any index underlying the constraint. IfIF EXISTSis specified and the constraint does not exist, no error is thrown. In this case a notice is issued instead.\nThese forms configure the firing of trigger(s) belonging to the table. A disabled trigger is still known to the system, but is not executed when its triggering event occurs. (For a deferred trigger, the enable status is checked when the event occurs, not when the trigger function is actually executed.) One can disable or enable a single trigger specified by name, or all triggers on the table, or only user triggers (this option excludes internally generated constraint triggers, such as those that are used to implement foreign key constraints or deferrable uniqueness and exclusion constraints). Disabling or enabling internally generated constraint triggers requires superuser privileges; it should be done with caution since of course the integrity of the constraint cannot be guaranteed if the triggers are not executed.\nThe trigger firing mechanism is also affected by the configuration variablesession_replication_role. Simply enabled triggers (the default) will fire when the replication role is“origin”(the default) or“local”. Triggers configured asENABLE REPLICAwill only fire if the session is in“replica”mode, and triggers configured asENABLE ALWAYSwill fire regardless of the current replication role.\nThe effect of this mechanism is that in the default configuration, triggers do not fire on replicas. This is useful because if a trigger is used on the origin to propagate data between tables, then the replication system will also replicate the propagated data; so the trigger should not fire a second time on the replica, because that would lead to duplication. However, if a trigger is used for another purpose such as creating external alerts, then it might be appropriate to set it toENABLE ALWAYSso that it is also fired on replicas.\nWhen this command is applied to a partitioned table, the states of corresponding clone triggers in the partitions are updated too, unlessONLYis specified.\nThis command acquires aSHARE ROW EXCLUSIVElock.\nThese forms configure the firing of rewrite rules belonging to the table. A disabled rule is still known to the system, but is not applied during query rewriting. The semantics are as for disabled/enabled triggers. This configuration is ignored forON SELECTrules, which are always applied in order to keep views working even if the current session is in a non-default replication role.\nThe rule firing mechanism is also affected by the configuration variablesession_replication_role, analogous to triggers as described above.\nThese forms control the application of row security policies belonging to the table. If enabled and no policies exist for the table, then a default-deny policy is applied. Note that policies can exist for a table even if row-level security is disabled. In this case, the policies willnotbe applied and the policies will be ignored. See alsoCREATE POLICY.\nThese forms control the application of row security policies belonging to the table when the user is the table owner. If enabled, row-level security policies will be applied when the user is the table owner. If disabled (the default) then row-level security will not be applied when the user is the table owner. See alsoCREATE POLICY.\nThis form selects the default index for futureCLUSTERoperations. It does not actually re-cluster the table.\nChanging cluster options acquires aSHARE UPDATE EXCLUSIVElock.\nThis form removes the most recently usedCLUSTERindex specification from the table. This affects future cluster operations that don't specify an index.\nChanging cluster options acquires aSHARE UPDATE EXCLUSIVElock.\nBackward-compatible syntax for removing theoidsystem column. Asoidsystem columns cannot be added anymore, this never has an effect.\nThis form changes the access method of the table by rewriting it. SeeChapter 63for more information.\nThis form changes the table's tablespace to the specified tablespace and moves the data file(s) associated with the table to the new tablespace. Indexes on the table, if any, are not moved; but they can be moved separately with additionalSET TABLESPACEcommands. When applied to a partitioned table, nothing is moved, but any partitions created afterwards withCREATE TABLE PARTITION OFwill use that tablespace, unless overridden by aTABLESPACEclause.\nAll tables in the current database in a tablespace can be moved by using theALL IN TABLESPACEform, which will lock all tables to be moved first and then move each one. This form also supportsOWNED BY, which will only move tables owned by the roles specified. If theNOWAIToption is specified then the command will fail if it is unable to acquire all of the locks required immediately. Note that system catalogs are not moved by this command; useALTER DATABASEor explicitALTER TABLEinvocations instead if desired. Theinformation_schemarelations are not considered part of the system catalogs and will be moved. See alsoCREATE TABLESPACE.\nThis form changes the table from unlogged to logged or vice-versa (seeUNLOGGED). It cannot be applied to a temporary table.\nThis also changes the persistence of any sequences linked to the table (for identity or serial columns). However, it is also possible to change the persistence of such sequences separately.\nThis form changes one or more storage parameters for the table. SeeStorage Parametersin theCREATE TABLEdocumentation for details on the available parameters. Note that the table contents will not be modified immediately by this command; depending on the parameter you might need to rewrite the table to get the desired effects. That can be done withVACUUM FULL,CLUSTERor one of the forms ofALTER TABLEthat forces a table rewrite. For planner related parameters, changes will take effect from the next time the table is locked so currently executing queries will not be affected.\nSHARE UPDATE EXCLUSIVElock will be taken for fillfactor, toast and autovacuum storage parameters, as well as the planner parameterparallel_workers.\nThis form resets one or more storage parameters to their defaults. As withSET, a table rewrite might be needed to update the table entirely.\nThis form adds the target table as a new child of the specified parent table. Subsequently, queries against the parent will include records of the target table. To be added as a child, the target table must already contain all the same columns as the parent (it could have additional columns, too). The columns must have matching data types, and if they haveNOT NULLconstraints in the parent then they must also haveNOT NULLconstraints in the child.\nThere must also be matching child-table constraints for allCHECKconstraints of the parent, except those marked non-inheritable (that is, created withALTER TABLE ... ADD CONSTRAINT ... NO INHERIT) in the parent, which are ignored; all child-table constraints matched must not be marked non-inheritable. CurrentlyUNIQUE,PRIMARY KEY, andFOREIGN KEYconstraints are not considered, but this might change in the future.\nThis form removes the target table from the list of children of the specified parent table. Queries against the parent table will no longer include records drawn from the target table.\nThis form links the table to a composite type as thoughCREATE TABLE OFhad formed it. The table's list of column names and types must precisely match that of the composite type. The table must not inherit from any other table. These restrictions ensure thatCREATE TABLE OFwould permit an equivalent table definition.\nThis form dissociates a typed table from its type.\nThis form changes the owner of the table, sequence, view, materialized view, or foreign table to the specified user.\nThis form changes the information which is written to the write-ahead log to identify rows which are updated or deleted. In most cases, the old value of each column is only logged if it differs from the new value; however, if the old value is stored externally, it is always logged regardless of whether it changed. This option has no effect except when logical replication is in use.\nRecords the old values of the columns of the primary key, if any. This is the default for non-system tables.\nRecords the old values of the columns covered by the named index, that must be unique, not partial, not deferrable, and include only columns markedNOT NULL. If this index is dropped, the behavior is the same asNOTHING.\nRecords the old values of all columns in the row.\nRecords no information about the old row. This is the default for system tables.\nTheRENAMEforms change the name of a table (or an index, sequence, view, materialized view, or foreign table), the name of an individual column in a table, or the name of a constraint of the table. When renaming a constraint that has an underlying index, the index is renamed as well. There is no effect on the stored data.\nThis form moves the table into another schema. Associated indexes, constraints, and sequences owned by table columns are moved as well.\nThis form attaches an existing table (which might itself be partitioned) as a partition of the target table. The table can be attached as a partition for specific values usingFOR VALUESor as a default partition by usingDEFAULT. For each index in the target table, a corresponding one will be created in the attached table; or, if an equivalent index already exists, it will be attached to the target table's index, as ifALTER INDEX ATTACH PARTITIONhad been executed. Note that if the existing table is a foreign table, it is currently not allowed to attach the table as a partition of the target table if there areUNIQUEindexes on the target table. (See alsoCREATE FOREIGN TABLE.) For each user-defined row-level trigger that exists in the target table, a corresponding one is created in the attached table.\nA partition usingFOR VALUESuses same syntax forpartition_bound_specasCREATE TABLE. The partition bound specification must correspond to the partitioning strategy and partition key of the target table. The table to be attached must have all the same columns as the target table and no more; moreover, the column types must also match. Also, it must have all theNOT NULLandCHECKconstraints of the target table, not markedNO INHERIT. CurrentlyFOREIGN KEYconstraints are not considered.UNIQUEandPRIMARY KEYconstraints from the parent table will be created in the partition, if they don't already exist.\nIf the new partition is a regular table, a full table scan is performed to check that existing rows in the table do not violate the partition constraint. It is possible to avoid this scan by adding a validCHECKconstraint to the table that allows only rows satisfying the desired partition constraint before running this command. TheCHECKconstraint will be used to determine that the table need not be scanned to validate the partition constraint. This does not work, however, if any of the partition keys is an expression and the partition does not acceptNULLvalues. If attaching a list partition that will not acceptNULLvalues, also add aNOT NULLconstraint to the partition key column, unless it's an expression.\nIf the new partition is a foreign table, nothing is done to verify that all the rows in the foreign table obey the partition constraint. (See the discussion inCREATE FOREIGN TABLEabout constraints on the foreign table.)\nWhen a table has a default partition, defining a new partition changes the partition constraint for the default partition. The default partition can't contain any rows that would need to be moved to the new partition, and will be scanned to verify that none are present. This scan, like the scan of the new partition, can be avoided if an appropriateCHECKconstraint is present. Also like the scan of the new partition, it is always skipped when the default partition is a foreign table.\nAttaching a partition acquires aSHARE UPDATE EXCLUSIVElock on the parent table, in addition to theACCESS EXCLUSIVElocks on the table being attached and on the default partition (if any).\nFurther locks must also be held on all sub-partitions if the table being attached is itself a partitioned table. Likewise if the default partition is itself a partitioned table. The locking of the sub-partitions can be avoided by adding aCHECKconstraint as described inSection 5.11.2.2.\nThis form detaches the specified partition of the target table. The detached partition continues to exist as a standalone table, but no longer has any ties to the table from which it was detached. Any indexes that were attached to the target table's indexes are detached. Any triggers that were created as clones of those in the target table are removed.SHARElock is obtained on any tables that reference this partitioned table in foreign key constraints.\nIfCONCURRENTLYis specified, it runs using a reduced lock level to avoid blocking other sessions that might be accessing the partitioned table. In this mode, two transactions are used internally. During the first transaction, aSHARE UPDATE EXCLUSIVElock is taken on both parent table and partition, and the partition is marked as undergoing detach; at that point, the transaction is committed and all other transactions using the partitioned table are waited for. Once all those transactions have completed, the second transaction acquiresSHARE UPDATE EXCLUSIVEon the partitioned table andACCESS EXCLUSIVEon the partition, and the detach process completes. ACHECKconstraint that duplicates the partition constraint is added to the partition.CONCURRENTLYcannot be run in a transaction block and is not allowed if the partitioned table contains a default partition.\nIfFINALIZEis specified, a previousDETACH CONCURRENTLYinvocation that was canceled or interrupted is completed. At most one partition in a partitioned table can be pending detach at a time.\nAll the forms of ALTER TABLE that act on a single table, exceptRENAME,SET SCHEMA,ATTACH PARTITION, andDETACH PARTITIONcan be combined into a list of multiple alterations to be applied together. For example, it is possible to add several columns and/or alter the type of several columns in a single command. This is particularly useful with large tables, since only one pass over the table need be made.\nYou must own the table to useALTER TABLE. To change the schema or tablespace of a table, you must also haveCREATEprivilege on the new schema or tablespace. To add the table as a new child of a parent table, you must own the parent table as well. Also, to attach a table as a new partition of the table, you must own the table being attached. To alter the owner, you must be able toSET ROLEto the new owning role, and that role must haveCREATEprivilege on the table's schema. (These restrictions enforce that altering the owner doesn't do anything you couldn't do by dropping and recreating the table. However, a superuser can alter ownership of any table anyway.) To add a column or alter a column type or use theOFclause, you must also haveUSAGEprivilege on the data type.\n"
    },
    {
      "title": "Parameters",
      "text": "Do not throw an error if the table does not exist. A notice is issued in this case.\nThe name (optionally schema-qualified) of an existing table to alter. IfONLYis specified before the table name, only that table is altered. IfONLYis not specified, the table and all its descendant tables (if any) are altered. Optionally,*can be specified after the table name to explicitly indicate that descendant tables are included.\nName of a new or existing column.\nNew name for an existing column.\nNew name for the table.\nData type of the new column, or new data type for an existing column.\nNew table constraint for the table.\nName of a new or existing constraint.\nAutomatically drop objects that depend on the dropped column or constraint (for example, views referencing the column), and in turn all objects that depend on those objects (seeSection 5.14).\nRefuse to drop the column or constraint if there are any dependent objects. This is the default behavior.\nName of a single trigger to disable or enable.\nDisable or enable all triggers belonging to the table. (This requires superuser privilege if any of the triggers are internally generated constraint triggers, such as those that are used to implement foreign key constraints or deferrable uniqueness and exclusion constraints.)\nDisable or enable all triggers belonging to the table except for internally generated constraint triggers, such as those that are used to implement foreign key constraints or deferrable uniqueness and exclusion constraints.\nThe name of an existing index.\nThe name of a table storage parameter.\nThe new value for a table storage parameter. This might be a number or a word depending on the parameter.\nA parent table to associate or de-associate with this table.\nThe user name of the new owner of the table.\nThe name of the access method to which the table will be converted.\nThe name of the tablespace to which the table will be moved.\nThe name of the schema to which the table will be moved.\nThe name of the table to attach as a new partition or to detach from this table.\nThe partition bound specification for a new partition. Refer toCREATE TABLEfor more details on the syntax of the same.\n"
    },
    {
      "title": "Notes",
      "text": "The key wordCOLUMNis noise and can be omitted.\nWhen a column is added withADD COLUMNand a non-volatileDEFAULTis specified, the default is evaluated at the time of the statement and the result stored in the table's metadata. That value will be used for the column for all existing rows. If noDEFAULTis specified, NULL is used. In neither case is a rewrite of the table required.\nAdding a column with a volatileDEFAULTor changing the type of an existing column will require the entire table and its indexes to be rewritten. As an exception, when changing the type of an existing column, if theUSINGclause does not change the column contents and the old type is either binary coercible to the new type or an unconstrained domain over the new type, a table rewrite is not needed. However, indexes must always be rebuilt unless the system can verify that the new index would be logically equivalent to the existing one. For example, if the collation for a column has been changed, an index rebuild is always required because the new sort order might be different. However, in the absence of a collation change, a column can be changed fromtexttovarchar(or vice versa) without rebuilding the indexes because these data types sort identically. Table and/or index rebuilds may take a significant amount of time for a large table; and will temporarily require as much as double the disk space.\nAdding aCHECKorNOT NULLconstraint requires scanning the table to verify that existing rows meet the constraint, but does not require a table rewrite.\nSimilarly, when attaching a new partition it may be scanned to verify that existing rows meet the partition constraint.\nThe main reason for providing the option to specify multiple changes in a singleALTER TABLEis that multiple table scans or rewrites can thereby be combined into a single pass over the table.\nScanning a large table to verify a new foreign key or check constraint can take a long time, and other updates to the table are locked out until theALTER TABLE ADD CONSTRAINTcommand is committed. The main purpose of theNOT VALIDconstraint option is to reduce the impact of adding a constraint on concurrent updates. WithNOT VALID, theADD CONSTRAINTcommand does not scan the table and can be committed immediately. After that, aVALIDATE CONSTRAINTcommand can be issued to verify that existing rows satisfy the constraint. The validation step does not need to lock out concurrent updates, since it knows that other transactions will be enforcing the constraint for rows that they insert or update; only pre-existing rows need to be checked. Hence, validation acquires only aSHARE UPDATE EXCLUSIVElock on the table being altered. (If the constraint is a foreign key then aROW SHARElock is also required on the table referenced by the constraint.) In addition to improving concurrency, it can be useful to useNOT VALIDandVALIDATE CONSTRAINTin cases where the table is known to contain pre-existing violations. Once the constraint is in place, no new violations can be inserted, and the existing problems can be corrected at leisure untilVALIDATE CONSTRAINTfinally succeeds.\nTheDROP COLUMNform does not physically remove the column, but simply makes it invisible to SQL operations. Subsequent insert and update operations in the table will store a null value for the column. Thus, dropping a column is quick but it will not immediately reduce the on-disk size of your table, as the space occupied by the dropped column is not reclaimed. The space will be reclaimed over time as existing rows are updated.\nTo force immediate reclamation of space occupied by a dropped column, you can execute one of the forms ofALTER TABLEthat performs a rewrite of the whole table. This results in reconstructing each row with the dropped column replaced by a null value.\nThe rewriting forms ofALTER TABLEare not MVCC-safe. After a table rewrite, the table will appear empty to concurrent transactions, if they are using a snapshot taken before the rewrite occurred. SeeSection 13.6for more details.\nTheUSINGoption ofSET DATA TYPEcan actually specify any expression involving the old values of the row; that is, it can refer to other columns as well as the one being converted. This allows very general conversions to be done with theSET DATA TYPEsyntax. Because of this flexibility, theUSINGexpression is not applied to the column's default value (if any); the result might not be a constant expression as required for a default. This means that when there is no implicit or assignment cast from old to new type,SET DATA TYPEmight fail to convert the default even though aUSINGclause is supplied. In such cases, drop the default withDROP DEFAULT, perform theALTER TYPE, and then useSET DEFAULTto add a suitable new default. Similar considerations apply to indexes and constraints involving the column.\nIf a table has any descendant tables, it is not permitted to add, rename, or change the type of a column in the parent table without doing the same to the descendants. This ensures that the descendants always have columns matching the parent. Similarly, aCHECKconstraint cannot be renamed in the parent without also renaming it in all descendants, so thatCHECKconstraints also match between the parent and its descendants. (That restriction does not apply to index-based constraints, however.) Also, because selecting from the parent also selects from its descendants, a constraint on the parent cannot be marked valid unless it is also marked valid for those descendants. In all of these cases,ALTER TABLE ONLYwill be rejected.\nA recursiveDROP COLUMNoperation will remove a descendant table's column only if the descendant does not inherit that column from any other parents and never had an independent definition of the column. A nonrecursiveDROP COLUMN(i.e.,ALTER TABLE ONLY ... DROP COLUMN) never removes any descendant columns, but instead marks them as independently defined rather than inherited. A nonrecursiveDROP COLUMNcommand will fail for a partitioned table, because all partitions of a table must have the same columns as the partitioning root.\nThe actions for identity columns (ADD GENERATED,SETetc.,DROP IDENTITY), as well as the actionsCLUSTER,OWNER, andTABLESPACEnever recurse to descendant tables; that is, they always act as thoughONLYwere specified. Actions affecting trigger states recurse to partitions of partitioned tables (unlessONLYis specified), but never to traditional-inheritance descendants. Adding a constraint recurses only forCHECKconstraints that are not markedNO INHERIT.\nChanging any part of a system catalog table is not permitted.\nRefer toCREATE TABLEfor a further description of valid parameters.Chapter 5has further information on inheritance.\n"
    },
    {
      "title": "Examples",
      "text": "To add a column of typevarcharto a table:\n\n\nCODE:\n\nALTER TABLE distributors ADD COLUMN address varchar(30);\n\nThat will cause all existing rows in the table to be filled with null values for the new column.\nTo add a column with a non-null default:\n\n\nCODE:\n\nALTER TABLE measurements\n  ADD COLUMN mtime timestamp with time zone DEFAULT now();\n\nExisting rows will be filled with the current time as the value of the new column, and then new rows will receive the time of their insertion.\nTo add a column and fill it with a value different from the default to be used later:\n\n\nCODE:\n\nALTER TABLE transactions\n  ADD COLUMN status varchar(30) DEFAULT 'old',\n  ALTER COLUMN status SET default 'current';\n\nExisting rows will be filled withold, but then the default for subsequent commands will becurrent. The effects are the same as if the two sub-commands had been issued in separateALTER TABLEcommands.\nTo drop a column from a table:\n\n\nCODE:\n\nALTER TABLE distributors DROP COLUMN address RESTRICT;\n\nTo change the types of two existing columns in one operation:\n\n\nCODE:\n\nALTER TABLE distributors\n    ALTER COLUMN address TYPE varchar(80),\n    ALTER COLUMN name TYPE varchar(100);\n\nTo change an integer column containing Unix timestamps totimestamp with time zonevia aUSINGclause:\n\n\nCODE:\n\nALTER TABLE foo\n    ALTER COLUMN foo_timestamp SET DATA TYPE timestamp with time zone\n    USING\n        timestamp with time zone 'epoch' + foo_timestamp * interval '1 second';\n\nThe same, when the column has a default expression that won't automatically cast to the new data type:\n\n\nCODE:\n\nALTER TABLE foo\n    ALTER COLUMN foo_timestamp DROP DEFAULT,\n    ALTER COLUMN foo_timestamp TYPE timestamp with time zone\n    USING\n        timestamp with time zone 'epoch' + foo_timestamp * interval '1 second',\n    ALTER COLUMN foo_timestamp SET DEFAULT now();\n\nTo rename an existing column:\n\n\nCODE:\n\nALTER TABLE distributors RENAME COLUMN address TO city;\n\nTo rename an existing table:\n\n\nCODE:\n\nALTER TABLE distributors RENAME TO suppliers;\n\nTo rename an existing constraint:\n\n\nCODE:\n\nALTER TABLE distributors RENAME CONSTRAINT zipchk TO zip_check;\n\nTo add a not-null constraint to a column:\n\n\nCODE:\n\nALTER TABLE distributors ALTER COLUMN street SET NOT NULL;\n\nTo remove a not-null constraint from a column:\n\n\nCODE:\n\nALTER TABLE distributors ALTER COLUMN street DROP NOT NULL;\n\nTo add a check constraint to a table and all its children:\n\n\nCODE:\n\nALTER TABLE distributors ADD CONSTRAINT zipchk CHECK (char_length(zipcode) = 5);\n\nTo add a check constraint only to a table and not to its children:\n\n\nCODE:\n\nALTER TABLE distributors ADD CONSTRAINT zipchk CHECK (char_length(zipcode) = 5) NO INHERIT;\n\n(The check constraint will not be inherited by future children, either.)\nTo remove a check constraint from a table and all its children:\n\n\nCODE:\n\nALTER TABLE distributors DROP CONSTRAINT zipchk;\n\nTo remove a check constraint from one table only:\n\n\nCODE:\n\nALTER TABLE ONLY distributors DROP CONSTRAINT zipchk;\n\n(The check constraint remains in place for any child tables.)\nTo add a foreign key constraint to a table:\n\n\nCODE:\n\nALTER TABLE distributors ADD CONSTRAINT distfk FOREIGN KEY (address) REFERENCES addresses (address);\n\nTo add a foreign key constraint to a table with the least impact on other work:\n\n\nCODE:\n\nALTER TABLE distributors ADD CONSTRAINT distfk FOREIGN KEY (address) REFERENCES addresses (address) NOT VALID;\nALTER TABLE distributors VALIDATE CONSTRAINT distfk;\n\nTo add a (multicolumn) unique constraint to a table:\n\n\nCODE:\n\nALTER TABLE distributors ADD CONSTRAINT dist_id_zipcode_key UNIQUE (dist_id, zipcode);\n\nTo add an automatically named primary key constraint to a table, noting that a table can only ever have one primary key:\n\n\nCODE:\n\nALTER TABLE distributors ADD PRIMARY KEY (dist_id);\n\nTo move a table to a different tablespace:\n\n\nCODE:\n\nALTER TABLE distributors SET TABLESPACE fasttablespace;\n\nTo move a table to a different schema:\n\n\nCODE:\n\nALTER TABLE myschema.distributors SET SCHEMA yourschema;\n\nTo recreate a primary key constraint, without blocking updates while the index is rebuilt:\n\n\nCODE:\n\nCREATE UNIQUE INDEX CONCURRENTLY dist_id_temp_idx ON distributors (dist_id);\nALTER TABLE distributors DROP CONSTRAINT distributors_pkey,\n    ADD CONSTRAINT distributors_pkey PRIMARY KEY USING INDEX dist_id_temp_idx;\n\nTo attach a partition to a range-partitioned table:\n\n\nCODE:\n\nALTER TABLE measurement\n    ATTACH PARTITION measurement_y2016m07 FOR VALUES FROM ('2016-07-01') TO ('2016-08-01');\n\nTo attach a partition to a list-partitioned table:\n\n\nCODE:\n\nALTER TABLE cities\n    ATTACH PARTITION cities_ab FOR VALUES IN ('a', 'b');\n\nTo attach a partition to a hash-partitioned table:\n\n\nCODE:\n\nALTER TABLE orders\n    ATTACH PARTITION orders_p4 FOR VALUES WITH (MODULUS 4, REMAINDER 3);\n\nTo attach a default partition to a partitioned table:\n\n\nCODE:\n\nALTER TABLE cities\n    ATTACH PARTITION cities_partdef DEFAULT;\n\nTo detach a partition from a partitioned table:\n\n\nCODE:\n\nALTER TABLE measurement\n    DETACH PARTITION measurement_y2015m12;\n\n"
    },
    {
      "title": "Compatibility",
      "text": "The formsADD(withoutUSING INDEX),DROP [COLUMN],DROP IDENTITY,RESTART,SET DEFAULT,SET DATA TYPE(withoutUSING),SET GENERATED, andSETsequence_optionconform with the SQL standard. The other forms arePostgreSQLextensions of the SQL standard. Also, the ability to specify more than one manipulation in a singleALTER TABLEcommand is an extension.\nALTER TABLE DROP COLUMNcan be used to drop the only column of a table, leaving a zero-column table. This is an extension of SQL, which disallows zero-column tables.\n"
    }
  ]
}