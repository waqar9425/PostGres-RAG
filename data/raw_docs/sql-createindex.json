{
  "doc_name": "sql-createindex",
  "url": "https://www.postgresql.org/docs/16/sql-createindex.html",
  "sections": [
    {
      "title": "CREATE INDEX",
      "text": "CREATE INDEX — define a new index\n"
    },
    {
      "title": "Synopsis",
      "text": "\n\nCODE:\n\nCREATE [ UNIQUE ] INDEX [ CONCURRENTLY ] [ [ IF NOT EXISTS ] name ] ON [ ONLY ] table_name [ USING method ]\n    ( { column_name | ( expression ) } [ COLLATE collation ] [ opclass [ ( opclass_parameter = value [, ... ] ) ] ] [ ASC | DESC ] [ NULLS { FIRST | LAST } ] [, ...] )\n    [ INCLUDE ( column_name [, ...] ) ]\n    [ NULLS [ NOT ] DISTINCT ]\n    [ WITH ( storage_parameter [= value] [, ... ] ) ]\n    [ TABLESPACE tablespace_name ]\n    [ WHERE predicate ]\n\n"
    },
    {
      "title": "Description",
      "text": "CREATE INDEXconstructs an index on the specified column(s) of the specified relation, which can be a table or a materialized view. Indexes are primarily used to enhance database performance (though inappropriate use can result in slower performance).\nThe key field(s) for the index are specified as column names, or alternatively as expressions written in parentheses. Multiple fields can be specified if the index method supports multicolumn indexes.\nAn index field can be an expression computed from the values of one or more columns of the table row. This feature can be used to obtain fast access to data based on some transformation of the basic data. For example, an index computed onupper(col)would allow the clauseWHERE upper(col) = 'JIM'to use an index.\nPostgreSQLprovides the index methods B-tree, hash, GiST, SP-GiST, GIN, and BRIN. Users can also define their own index methods, but that is fairly complicated.\nWhen theWHEREclause is present, apartial indexis created. A partial index is an index that contains entries for only a portion of a table, usually a portion that is more useful for indexing than the rest of the table. For example, if you have a table that contains both billed and unbilled orders where the unbilled orders take up a small fraction of the total table and yet that is an often used section, you can improve performance by creating an index on just that portion. Another possible application is to useWHEREwithUNIQUEto enforce uniqueness over a subset of a table. SeeSection 11.8for more discussion.\nThe expression used in theWHEREclause can refer only to columns of the underlying table, but it can use all columns, not just the ones being indexed. Presently, subqueries and aggregate expressions are also forbidden inWHERE. The same restrictions apply to index fields that are expressions.\nAll functions and operators used in an index definition must be“immutable”, that is, their results must depend only on their arguments and never on any outside influence (such as the contents of another table or the current time). This restriction ensures that the behavior of the index is well-defined. To use a user-defined function in an index expression orWHEREclause, remember to mark the function immutable when you create it.\n"
    },
    {
      "title": "Parameters",
      "text": "Causes the system to check for duplicate values in the table when the index is created (if data already exist) and each time data is added. Attempts to insert or update data which would result in duplicate entries will generate an error.\nAdditional restrictions apply when unique indexes are applied to partitioned tables; seeCREATE TABLE.\nWhen this option is used,PostgreSQLwill build the index without taking any locks that prevent concurrent inserts, updates, or deletes on the table; whereas a standard index build locks out writes (but not reads) on the table until it's done. There are several caveats to be aware of when using this option — seeBuilding Indexes Concurrentlybelow.\nFor temporary tables,CREATE INDEXis always non-concurrent, as no other session can access them, and non-concurrent index creation is cheaper.\nDo not throw an error if a relation with the same name already exists. A notice is issued in this case. Note that there is no guarantee that the existing index is anything like the one that would have been created. Index name is required whenIF NOT EXISTSis specified.\nThe optionalINCLUDEclause specifies a list of columns which will be included in the index asnon-keycolumns. A non-key column cannot be used in an index scan search qualification, and it is disregarded for purposes of any uniqueness or exclusion constraint enforced by the index. However, an index-only scan can return the contents of non-key columns without having to visit the index's table, since they are available directly from the index entry. Thus, addition of non-key columns allows index-only scans to be used for queries that otherwise could not use them.\nIt's wise to be conservative about adding non-key columns to an index, especially wide columns. If an index tuple exceeds the maximum size allowed for the index type, data insertion will fail. In any case, non-key columns duplicate data from the index's table and bloat the size of the index, thus potentially slowing searches. Furthermore, B-tree deduplication is never used with indexes that have a non-key column.\nColumns listed in theINCLUDEclause don't need appropriate operator classes; the clause can include columns whose data types don't have operator classes defined for a given access method.\nExpressions are not supported as included columns since they cannot be used in index-only scans.\nCurrently, the B-tree, GiST and SP-GiST index access methods support this feature. In these indexes, the values of columns listed in theINCLUDEclause are included in leaf tuples which correspond to heap tuples, but are not included in upper-level index entries used for tree navigation.\nThe name of the index to be created. No schema name can be included here; the index is always created in the same schema as its parent table. The name of the index must be distinct from the name of any other relation (table, sequence, index, view, materialized view, or foreign table) in that schema. If the name is omitted,PostgreSQLchooses a suitable name based on the parent table's name and the indexed column name(s).\nIndicates not to recurse creating indexes on partitions, if the table is partitioned. The default is to recurse.\nThe name (possibly schema-qualified) of the table to be indexed.\nThe name of the index method to be used. Choices arebtree,hash,gist,spgist,gin,brin, or user-installed access methods likebloom. The default method isbtree.\nThe name of a column of the table.\nAn expression based on one or more columns of the table. The expression usually must be written with surrounding parentheses, as shown in the syntax. However, the parentheses can be omitted if the expression has the form of a function call.\nThe name of the collation to use for the index. By default, the index uses the collation declared for the column to be indexed or the result collation of the expression to be indexed. Indexes with non-default collations can be useful for queries that involve expressions using non-default collations.\nThe name of an operator class. See below for details.\nThe name of an operator class parameter. See below for details.\nSpecifies ascending sort order (which is the default).\nSpecifies descending sort order.\nSpecifies that nulls sort before non-nulls. This is the default whenDESCis specified.\nSpecifies that nulls sort after non-nulls. This is the default whenDESCis not specified.\nSpecifies whether for a unique index, null values should be considered distinct (not equal). The default is that they are distinct, so that a unique index could contain multiple null values in a column.\nThe name of an index-method-specific storage parameter. SeeIndex Storage Parametersbelow for details.\nThe tablespace in which to create the index. If not specified,default_tablespaceis consulted, ortemp_tablespacesfor indexes on temporary tables.\nThe constraint expression for a partial index.\n"
    },
    {
      "title": "Index Storage Parameters",
      "text": "The optionalWITHclause specifiesstorage parametersfor the index. Each index method has its own set of allowed storage parameters. The B-tree, hash, GiST and SP-GiST index methods all accept this parameter:\nThe fillfactor for an index is a percentage that determines how full the index method will try to pack index pages. For B-trees, leaf pages are filled to this percentage during initial index builds, and also when extending the index at the right (adding new largest key values). If pages subsequently become completely full, they will be split, leading to fragmentation of the on-disk index structure. B-trees use a default fillfactor of 90, but any integer value from 10 to 100 can be selected.\nB-tree indexes on tables where many inserts and/or updates are anticipated can benefit from lower fillfactor settings atCREATE INDEXtime (following bulk loading into the table). Values in the range of 50 - 90 can usefully“smooth out”therateof page splits during the early life of the B-tree index (lowering fillfactor like this may even lower the absolute number of page splits, though this effect is highly workload dependent). The B-tree bottom-up index deletion technique described inSection 67.4.2is dependent on having some“extra”space on pages to store“extra”tuple versions, and so can be affected by fillfactor (though the effect is usually not significant).\nIn other specific cases it might be useful to increase fillfactor to 100 atCREATE INDEXtime as a way of maximizing space utilization. You should only consider this when you are completely sure that the table is static (i.e. that it will never be affected by either inserts or updates). A fillfactor setting of 100 otherwise risksharmingperformance: even a few updates or inserts will cause a sudden flood of page splits.\nThe other index methods use fillfactor in different but roughly analogous ways; the default fillfactor varies between methods.\nB-tree indexes additionally accept this parameter:\nControls usage of the B-tree deduplication technique described inSection 67.4.3. Set toONorOFFto enable or disable the optimization. (Alternative spellings ofONandOFFare allowed as described inSection 20.1.) The default isON.\n"
    },
    {
      "title": "Note",
      "text": "Turningdeduplicate_itemsoff viaALTER INDEXprevents future insertions from triggering deduplication, but does not in itself make existing posting list tuples use the standard tuple representation.\nGiST indexes additionally accept this parameter:\nDetermines whether the buffered build technique described inSection 68.4.1is used to build the index. WithOFFbuffering is disabled, withONit is enabled, and withAUTOit is initially disabled, but is turned on on-the-fly once the index size reacheseffective_cache_size. The default isAUTO. Note that if sorted build is possible, it will be used instead of buffered build unlessbuffering=ONis specified.\nGIN indexes accept different parameters:\nThis setting controls usage of the fast update technique described inSection 70.4.1. It is a Boolean parameter:ONenables fast update,OFFdisables it. The default isON.\n"
    },
    {
      "title": "Note",
      "text": "Turningfastupdateoff viaALTER INDEXprevents future insertions from going into the list of pending index entries, but does not in itself flush previous entries. You might want toVACUUMthe table or callgin_clean_pending_listfunction afterward to ensure the pending list is emptied.\nCustomgin_pending_list_limitparameter. This value is specified in kilobytes.\nBRINindexes accept different parameters:\nDefines the number of table blocks that make up one block range for each entry of aBRINindex (seeSection 71.1for more details). The default is128.\nDefines whether a summarization run is queued for the previous page range whenever an insertion is detected on the next one. SeeSection 71.1.1for more details. The default isoff.\n"
    },
    {
      "title": "Building Indexes Concurrently",
      "text": "Creating an index can interfere with regular operation of a database. NormallyPostgreSQLlocks the table to be indexed against writes and performs the entire index build with a single scan of the table. Other transactions can still read the table, but if they try to insert, update, or delete rows in the table they will block until the index build is finished. This could have a severe effect if the system is a live production database. Very large tables can take many hours to be indexed, and even for smaller tables, an index build can lock out writers for periods that are unacceptably long for a production system.\nPostgreSQLsupports building indexes without locking out writes. This method is invoked by specifying theCONCURRENTLYoption ofCREATE INDEX. When this option is used,PostgreSQLmust perform two scans of the table, and in addition it must wait for all existing transactions that could potentially modify or use the index to terminate. Thus this method requires more total work than a standard index build and takes significantly longer to complete. However, since it allows normal operations to continue while the index is built, this method is useful for adding new indexes in a production environment. Of course, the extra CPU and I/O load imposed by the index creation might slow other operations.\nIn a concurrent index build, the index is actually entered as an“invalid”index into the system catalogs in one transaction, then two table scans occur in two more transactions. Before each table scan, the index build must wait for existing transactions that have modified the table to terminate. After the second scan, the index build must wait for any transactions that have a snapshot (seeChapter 13) predating the second scan to terminate, including transactions used by any phase of concurrent index builds on other tables, if the indexes involved are partial or have columns that are not simple column references. Then finally the index can be marked“valid”and ready for use, and theCREATE INDEXcommand terminates. Even then, however, the index may not be immediately usable for queries: in the worst case, it cannot be used as long as transactions exist that predate the start of the index build.\nIf a problem arises while scanning the table, such as a deadlock or a uniqueness violation in a unique index, theCREATE INDEXcommand will fail but leave behind an“invalid”index. This index will be ignored for querying purposes because it might be incomplete; however it will still consume update overhead. Thepsql\\dcommand will report such an index asINVALID:\n\n\nCODE:\n\npostgres=# \\d tab\n       Table \"public.tab\"\n Column |  Type   | Collation | Nullable | Default\n--------+---------+-----------+----------+---------\n col    | integer |           |          |\nIndexes:\n    \"idx\" btree (col) INVALID\n\nThe recommended recovery method in such cases is to drop the index and try again to performCREATE INDEX CONCURRENTLY. (Another possibility is to rebuild the index withREINDEX INDEX CONCURRENTLY).\nAnother caveat when building a unique index concurrently is that the uniqueness constraint is already being enforced against other transactions when the second table scan begins. This means that constraint violations could be reported in other queries prior to the index becoming available for use, or even in cases where the index build eventually fails. Also, if a failure does occur in the second scan, the“invalid”index continues to enforce its uniqueness constraint afterwards.\nConcurrent builds of expression indexes and partial indexes are supported. Errors occurring in the evaluation of these expressions could cause behavior similar to that described above for unique constraint violations.\nRegular index builds permit other regular index builds on the same table to occur simultaneously, but only one concurrent index build can occur on a table at a time. In either case, schema modification of the table is not allowed while the index is being built. Another difference is that a regularCREATE INDEXcommand can be performed within a transaction block, butCREATE INDEX CONCURRENTLYcannot.\nConcurrent builds for indexes on partitioned tables are currently not supported. However, you may concurrently build the index on each partition individually and then finally create the partitioned index non-concurrently in order to reduce the time where writes to the partitioned table will be locked out. In this case, building the partitioned index is a metadata only operation.\n"
    },
    {
      "title": "Notes",
      "text": "SeeChapter 11for information about when indexes can be used, when they are not used, and in which particular situations they can be useful.\nCurrently, only the B-tree, GiST, GIN, and BRIN index methods support multiple-key-column indexes. Whether there can be multiple key columns is independent of whetherINCLUDEcolumns can be added to the index. Indexes can have up to 32 columns, includingINCLUDEcolumns. (This limit can be altered when buildingPostgreSQL.) Only B-tree currently supports unique indexes.\nAnoperator classwith optional parameters can be specified for each column of an index. The operator class identifies the operators to be used by the index for that column. For example, a B-tree index on four-byte integers would use theint4_opsclass; this operator class includes comparison functions for four-byte integers. In practice the default operator class for the column's data type is usually sufficient. The main point of having operator classes is that for some data types, there could be more than one meaningful ordering. For example, we might want to sort a complex-number data type either by absolute value or by real part. We could do this by defining two operator classes for the data type and then selecting the proper class when creating an index. More information about operator classes is inSection 11.10and inSection 38.16.\nWhenCREATE INDEXis invoked on a partitioned table, the default behavior is to recurse to all partitions to ensure they all have matching indexes. Each partition is first checked to determine whether an equivalent index already exists, and if so, that index will become attached as a partition index to the index being created, which will become its parent index. If no matching index exists, a new index will be created and automatically attached; the name of the new index in each partition will be determined as if no index name had been specified in the command. If theONLYoption is specified, no recursion is done, and the index is marked invalid. (ALTER INDEX ... ATTACH PARTITIONmarks the index valid, once all partitions acquire matching indexes.) Note, however, that any partition that is created in the future usingCREATE TABLE ... PARTITION OFwill automatically have a matching index, regardless of whetherONLYis specified.\nFor index methods that support ordered scans (currently, only B-tree), the optional clausesASC,DESC,NULLS FIRST, and/orNULLS LASTcan be specified to modify the sort ordering of the index. Since an ordered index can be scanned either forward or backward, it is not normally useful to create a single-columnDESCindex — that sort ordering is already available with a regular index. The value of these options is that multicolumn indexes can be created that match the sort ordering requested by a mixed-ordering query, such asSELECT ... ORDER BY x ASC, y DESC. TheNULLSoptions are useful if you need to support“nulls sort low”behavior, rather than the default“nulls sort high”, in queries that depend on indexes to avoid sorting steps.\nThe system regularly collects statistics on all of a table's columns. Newly-created non-expression indexes can immediately use these statistics to determine an index's usefulness. For new expression indexes, it is necessary to runANALYZEor wait for theautovacuum daemonto analyze the table to generate statistics for these indexes.\nFor most index methods, the speed of creating an index is dependent on the setting ofmaintenance_work_mem. Larger values will reduce the time needed for index creation, so long as you don't make it larger than the amount of memory really available, which would drive the machine into swapping.\nPostgreSQLcan build indexes while leveraging multiple CPUs in order to process the table rows faster. This feature is known asparallel index build. For index methods that support building indexes in parallel (currently, only B-tree),maintenance_work_memspecifies the maximum amount of memory that can be used by each index build operation as a whole, regardless of how many worker processes were started. Generally, a cost model automatically determines how many worker processes should be requested, if any.\nParallel index builds may benefit from increasingmaintenance_work_memwhere an equivalent serial index build will see little or no benefit. Note thatmaintenance_work_memmay influence the number of worker processes requested, since parallel workers must have at least a32MBshare of the totalmaintenance_work_membudget. There must also be a remaining32MBshare for the leader process. Increasingmax_parallel_maintenance_workersmay allow more workers to be used, which will reduce the time needed for index creation, so long as the index build is not already I/O bound. Of course, there should also be sufficient CPU capacity that would otherwise lie idle.\nSetting a value forparallel_workersviaALTER TABLEdirectly controls how many parallel worker processes will be requested by aCREATE INDEXagainst the table. This bypasses the cost model completely, and preventsmaintenance_work_memfrom affecting how many parallel workers are requested. Settingparallel_workersto 0 viaALTER TABLEwill disable parallel index builds on the table in all cases.\n"
    },
    {
      "title": "Tip",
      "text": "You might want to resetparallel_workersafter setting it as part of tuning an index build. This avoids inadvertent changes to query plans, sinceparallel_workersaffectsallparallel table scans.\nWhileCREATE INDEXwith theCONCURRENTLYoption supports parallel builds without special restrictions, only the first table scan is actually performed in parallel.\nUseDROP INDEXto remove an index.\nLike any long-running transaction,CREATE INDEXon a table can affect which tuples can be removed by concurrentVACUUMon any other table.\nPrior releases ofPostgreSQLalso had an R-tree index method. This method has been removed because it had no significant advantages over the GiST method. IfUSING rtreeis specified,CREATE INDEXwill interpret it asUSING gist, to simplify conversion of old databases to GiST.\nEach backend runningCREATE INDEXwill report its progress in thepg_stat_progress_create_indexview. SeeSection 28.4.4for details.\n"
    },
    {
      "title": "Examples",
      "text": "To create a unique B-tree index on the columntitlein the tablefilms:\n\n\nCODE:\n\nCREATE UNIQUE INDEX title_idx ON films (title);\n\nTo create a unique B-tree index on the columntitlewith included columnsdirectorandratingin the tablefilms:\n\n\nCODE:\n\nCREATE UNIQUE INDEX title_idx ON films (title) INCLUDE (director, rating);\n\nTo create a B-Tree index with deduplication disabled:\n\n\nCODE:\n\nCREATE INDEX title_idx ON films (title) WITH (deduplicate_items = off);\n\nTo create an index on the expressionlower(title), allowing efficient case-insensitive searches:\n\n\nCODE:\n\nCREATE INDEX ON films ((lower(title)));\n\n(In this example we have chosen to omit the index name, so the system will choose a name, typicallyfilms_lower_idx.)\nTo create an index with non-default collation:\n\n\nCODE:\n\nCREATE INDEX title_idx_german ON films (title COLLATE \"de_DE\");\n\nTo create an index with non-default sort ordering of nulls:\n\n\nCODE:\n\nCREATE INDEX title_idx_nulls_low ON films (title NULLS FIRST);\n\nTo create an index with non-default fill factor:\n\n\nCODE:\n\nCREATE UNIQUE INDEX title_idx ON films (title) WITH (fillfactor = 70);\n\nTo create aGINindex with fast updates disabled:\n\n\nCODE:\n\nCREATE INDEX gin_idx ON documents_table USING GIN (locations) WITH (fastupdate = off);\n\nTo create an index on the columncodein the tablefilmsand have the index reside in the tablespaceindexspace:\n\n\nCODE:\n\nCREATE INDEX code_idx ON films (code) TABLESPACE indexspace;\n\nTo create a GiST index on a point attribute so that we can efficiently use box operators on the result of the conversion function:\n\n\nCODE:\n\nCREATE INDEX pointloc\n    ON points USING gist (box(location,location));\nSELECT * FROM points\n    WHERE box(location,location) && '(0,0),(1,1)'::box;\n\nTo create an index without locking out writes to the table:\n\n\nCODE:\n\nCREATE INDEX CONCURRENTLY sales_quantity_index ON sales_table (quantity);\n\n"
    },
    {
      "title": "Compatibility",
      "text": "CREATE INDEXis aPostgreSQLlanguage extension. There are no provisions for indexes in the SQL standard.\n"
    }
  ]
}