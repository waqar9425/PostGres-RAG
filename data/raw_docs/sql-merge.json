{
  "doc_name": "sql-merge",
  "url": "https://www.postgresql.org/docs/16/sql-merge.html",
  "sections": [
    {
      "title": "MERGE",
      "text": "MERGE — conditionally insert, update, or delete rows of a table\n"
    },
    {
      "title": "Synopsis",
      "text": "\n\nCODE:\n\n[ WITH with_query [, ...] ]\nMERGE INTO [ ONLY ] target_table_name [ * ] [ [ AS ] target_alias ]\n    USING data_source ON join_condition\n    when_clause [...]\n\nwhere data_source is:\n\n    { [ ONLY ] source_table_name [ * ] | ( source_query ) } [ [ AS ] source_alias ]\n\nand when_clause is:\n\n    { WHEN MATCHED [ AND condition ] THEN { merge_update | merge_delete | DO NOTHING } |\n      WHEN NOT MATCHED [ AND condition ] THEN { merge_insert | DO NOTHING } }\n\nand merge_insert is:\n\n    INSERT [( column_name [, ...] )]\n        [ OVERRIDING { SYSTEM | USER } VALUE ]\n        { VALUES ( { expression | DEFAULT } [, ...] ) | DEFAULT VALUES }\n\nand merge_update is:\n\n    UPDATE SET { column_name = { expression | DEFAULT } |\n                 ( column_name [, ...] ) = [ ROW ] ( { expression | DEFAULT } [, ...] ) |\n                 ( column_name [, ...] ) = ( sub-SELECT )\n               } [, ...]\n\nand merge_delete is:\n\n    DELETE\n\n"
    },
    {
      "title": "Description",
      "text": "MERGEperforms actions that modify rows in the target table identified astarget_table_name, using thedata_source.MERGEprovides a singleSQLstatement that can conditionallyINSERT,UPDATEorDELETErows, a task that would otherwise require multiple procedural language statements.\nFirst, theMERGEcommand performs a join fromdata_sourceto the target table producing zero or more candidate change rows. For each candidate change row, the status ofMATCHEDorNOT MATCHEDis set just once, after whichWHENclauses are evaluated in the order specified. For each candidate change row, the first clause to evaluate as true is executed. No more than oneWHENclause is executed for any candidate change row.\nMERGEactions have the same effect as regularUPDATE,INSERT, orDELETEcommands of the same names. The syntax of those commands is different, notably that there is noWHEREclause and no table name is specified. All actions refer to the target table, though modifications to other tables may be made using triggers.\nWhenDO NOTHINGis specified, the source row is skipped. Since actions are evaluated in their specified order,DO NOTHINGcan be handy to skip non-interesting source rows before more fine-grained handling.\nThere is no separateMERGEprivilege. If you specify an update action, you must have theUPDATEprivilege on the column(s) of the target table that are referred to in theSETclause. If you specify an insert action, you must have theINSERTprivilege on the target table. If you specify a delete action, you must have theDELETEprivilege on the target table. If you specify aDO NOTHINGaction, you must have theSELECTprivilege on at least one column of the target table. You will also needSELECTprivilege on any column(s) of thedata_sourceand of the target table referred to in anycondition(includingjoin_condition) orexpression. Privileges are tested once at statement start and are checked whether or not particularWHENclauses are executed.\nMERGEis not supported if the target table is a materialized view, foreign table, or if it has any rules defined on it.\n"
    },
    {
      "title": "Parameters",
      "text": "TheWITHclause allows you to specify one or more subqueries that can be referenced by name in theMERGEquery. SeeSection 7.8andSELECTfor details. Note thatWITH RECURSIVEis not supported byMERGE.\nThe name (optionally schema-qualified) of the target table to merge into. IfONLYis specified before the table name, matching rows are updated or deleted in the named table only. IfONLYis not specified, matching rows are also updated or deleted in any tables inheriting from the named table. Optionally,*can be specified after the table name to explicitly indicate that descendant tables are included. TheONLYkeyword and*option do not affect insert actions, which always insert into the named table only.\nA substitute name for the target table. When an alias is provided, it completely hides the actual name of the table. For example, givenMERGE INTO foo AS f, the remainder of theMERGEstatement must refer to this table asfnotfoo.\nThe name (optionally schema-qualified) of the source table, view, or transition table. IfONLYis specified before the table name, matching rows are included from the named table only. IfONLYis not specified, matching rows are also included from any tables inheriting from the named table. Optionally,*can be specified after the table name to explicitly indicate that descendant tables are included.\nA query (SELECTstatement orVALUESstatement) that supplies the rows to be merged into the target table. Refer to theSELECTstatement orVALUESstatement for a description of the syntax.\nA substitute name for the data source. When an alias is provided, it completely hides the actual name of the table or the fact that a query was issued.\njoin_conditionis an expression resulting in a value of typeboolean(similar to aWHEREclause) that specifies which rows in thedata_sourcematch rows in the target table.\n"
    },
    {
      "title": "Warning",
      "text": "Only columns from the target table that attempt to matchdata_sourcerows should appear injoin_condition.join_conditionsubexpressions that only reference the target table's columns can affect which action is taken, often in surprising ways.\nAt least oneWHENclause is required.\nIf theWHENclause specifiesWHEN MATCHEDand the candidate change row matches a row in the target table, theWHENclause is executed if theconditionis absent or it evaluates totrue.\nConversely, if theWHENclause specifiesWHEN NOT MATCHEDand the candidate change row does not match a row in the target table, theWHENclause is executed if theconditionis absent or it evaluates totrue.\nAn expression that returns a value of typeboolean. If this expression for aWHENclause returnstrue, then the action for that clause is executed for that row.\nA condition on aWHEN MATCHEDclause can refer to columns in both the source and the target relations. A condition on aWHEN NOT MATCHEDclause can only refer to columns from the source relation, since by definition there is no matching target row. Only the system attributes from the target table are accessible.\nThe specification of anINSERTaction that inserts one row into the target table. The target column names can be listed in any order. If no list of column names is given at all, the default is all the columns of the table in their declared order.\nEach column not present in the explicit or implicit column list will be filled with a default value, either its declared default value or null if there is none.\nIf the target table is a partitioned table, each row is routed to the appropriate partition and inserted into it. If the target table is a partition, an error will occur if any input row violates the partition constraint.\nColumn names may not be specified more than once.INSERTactions cannot contain sub-selects.\nOnly oneVALUESclause can be specified. TheVALUESclause can only refer to columns from the source relation, since by definition there is no matching target row.\nThe specification of anUPDATEaction that updates the current row of the target table. Column names may not be specified more than once.\nNeither a table name nor aWHEREclause are allowed.\nSpecifies aDELETEaction that deletes the current row of the target table. Do not include the table name or any other clauses, as you would normally do with aDELETEcommand.\nThe name of a column in the target table. The column name can be qualified with a subfield name or array subscript, if needed. (Inserting into only some fields of a composite column leaves the other fields null.) Do not include the table's name in the specification of a target column.\nWithout this clause, it is an error to specify an explicit value (other thanDEFAULT) for an identity column defined asGENERATED ALWAYS. This clause overrides that restriction.\nIf this clause is specified, then any values supplied for identity columns defined asGENERATED BY DEFAULTare ignored and the default sequence-generated values are applied.\nAll columns will be filled with their default values. (AnOVERRIDINGclause is not permitted in this form.)\nAn expression to assign to the column. If used in aWHEN MATCHEDclause, the expression can use values from the original row in the target table, and values from thedata_sourcerow. If used in aWHEN NOT MATCHEDclause, the expression can use values from thedata_sourcerow.\nSet the column to its default value (which will beNULLif no specific default expression has been assigned to it).\nASELECTsub-query that produces as many output columns as are listed in the parenthesized column list preceding it. The sub-query must yield no more than one row when executed. If it yields one row, its column values are assigned to the target columns; if it yields no rows, NULL values are assigned to the target columns. The sub-query can refer to values from the original row in the target table, and values from thedata_sourcerow.\n"
    },
    {
      "title": "Outputs",
      "text": "On successful completion, aMERGEcommand returns a command tag of the form\n\n\nCODE:\n\nMERGE total_count\n\nThetotal_countis the total number of rows changed (whether inserted, updated, or deleted). Iftotal_countis 0, no rows were changed in any way.\n"
    },
    {
      "title": "Notes",
      "text": "The following steps take place during the execution ofMERGE.\nPerform anyBEFORE STATEMENTtriggers for all actions specified, whether or not theirWHENclauses match.\nPerform a join from source to target table. The resulting query will be optimized normally and will produce a set of candidate change rows. For each candidate change row,\nEvaluate whether each row isMATCHEDorNOT MATCHED.\nTest eachWHENcondition in the order specified until one returns true.\nWhen a condition returns true, perform the following actions:\nPerform anyBEFORE ROWtriggers that fire for the action's event type.\nPerform the specified action, invoking any check constraints on the target table.\nPerform anyAFTER ROWtriggers that fire for the action's event type.\nPerform anyAFTER STATEMENTtriggers for actions specified, whether or not they actually occur. This is similar to the behavior of anUPDATEstatement that modifies no rows.\nIn summary, statement triggers for an event type (say,INSERT) will be fired whenever wespecifyan action of that kind. In contrast, row-level triggers will fire only for the specific event type beingexecuted. So aMERGEcommand might fire statement triggers for bothUPDATEandINSERT, even though onlyUPDATErow triggers were fired.\nYou should ensure that the join produces at most one candidate change row for each target row. In other words, a target row shouldn't join to more than one data source row. If it does, then only one of the candidate change rows will be used to modify the target row; later attempts to modify the row will cause an error. This can also occur if row triggers make changes to the target table and the rows so modified are then subsequently also modified byMERGE. If the repeated action is anINSERT, this will cause a uniqueness violation, while a repeatedUPDATEorDELETEwill cause a cardinality violation; the latter behavior is required by theSQLstandard. This differs from historicalPostgreSQLbehavior of joins inUPDATEandDELETEstatements where second and subsequent attempts to modify the same row are simply ignored.\nIf aWHENclause omits anANDsub-clause, it becomes the final reachable clause of that kind (MATCHEDorNOT MATCHED). If a laterWHENclause of that kind is specified it would be provably unreachable and an error is raised. If no final reachable clause is specified of either kind, it is possible that no action will be taken for a candidate change row.\nThe order in which rows are generated from the data source is indeterminate by default. Asource_querycan be used to specify a consistent ordering, if required, which might be needed to avoid deadlocks between concurrent transactions.\nThere is noRETURNINGclause withMERGE. Actions ofINSERT,UPDATEandDELETEcannot containRETURNINGorWITHclauses.\nWhenMERGEis run concurrently with other commands that modify the target table, the usual transaction isolation rules apply; seeSection 13.2for an explanation on the behavior at each isolation level. You may also wish to consider usingINSERT ... ON CONFLICTas an alternative statement which offers the ability to run anUPDATEif a concurrentINSERToccurs. There are a variety of differences and restrictions between the two statement types and they are not interchangeable.\n"
    },
    {
      "title": "Examples",
      "text": "Perform maintenance oncustomer_accountsbased upon newrecent_transactions.\n\n\nCODE:\n\nMERGE INTO customer_account ca\nUSING recent_transactions t\nON t.customer_id = ca.customer_id\nWHEN MATCHED THEN\n  UPDATE SET balance = balance + transaction_value\nWHEN NOT MATCHED THEN\n  INSERT (customer_id, balance)\n  VALUES (t.customer_id, t.transaction_value);\n\nNotice that this would be exactly equivalent to the following statement because theMATCHEDresult does not change during execution.\n\n\nCODE:\n\nMERGE INTO customer_account ca\nUSING (SELECT customer_id, transaction_value FROM recent_transactions) AS t\nON t.customer_id = ca.customer_id\nWHEN MATCHED THEN\n  UPDATE SET balance = balance + transaction_value\nWHEN NOT MATCHED THEN\n  INSERT (customer_id, balance)\n  VALUES (t.customer_id, t.transaction_value);\n\nAttempt to insert a new stock item along with the quantity of stock. If the item already exists, instead update the stock count of the existing item. Don't allow entries that have zero stock.\n\n\nCODE:\n\nMERGE INTO wines w\nUSING wine_stock_changes s\nON s.winename = w.winename\nWHEN NOT MATCHED AND s.stock_delta > 0 THEN\n  INSERT VALUES(s.winename, s.stock_delta)\nWHEN MATCHED AND w.stock + s.stock_delta > 0 THEN\n  UPDATE SET stock = w.stock + s.stock_delta\nWHEN MATCHED THEN\n  DELETE;\n\nThewine_stock_changestable might be, for example, a temporary table recently loaded into the database.\n"
    },
    {
      "title": "Compatibility",
      "text": "This command conforms to theSQLstandard.\nTheWITHclause andDO NOTHINGaction are extensions to theSQLstandard.\n"
    }
  ]
}