{
  "doc_name": "sql-select",
  "url": "https://www.postgresql.org/docs/16/sql-select.html",
  "sections": [
    {
      "title": "SELECT",
      "text": "SELECT, TABLE, WITH — retrieve rows from a table or view\n"
    },
    {
      "title": "Synopsis",
      "text": "\n\nCODE:\n\n[ WITH [ RECURSIVE ] with_query [, ...] ]\nSELECT [ ALL | DISTINCT [ ON ( expression [, ...] ) ] ]\n    [ { * | expression [ [ AS ] output_name ] } [, ...] ]\n    [ FROM from_item [, ...] ]\n    [ WHERE condition ]\n    [ GROUP BY [ ALL | DISTINCT ] grouping_element [, ...] ]\n    [ HAVING condition ]\n    [ WINDOW window_name AS ( window_definition ) [, ...] ]\n    [ { UNION | INTERSECT | EXCEPT } [ ALL | DISTINCT ] select ]\n    [ ORDER BY expression [ ASC | DESC | USING operator ] [ NULLS { FIRST | LAST } ] [, ...] ]\n    [ LIMIT { count | ALL } ]\n    [ OFFSET start [ ROW | ROWS ] ]\n    [ FETCH { FIRST | NEXT } [ count ] { ROW | ROWS } { ONLY | WITH TIES } ]\n    [ FOR { UPDATE | NO KEY UPDATE | SHARE | KEY SHARE } [ OF table_name [, ...] ] [ NOWAIT | SKIP LOCKED ] [...] ]\n\nwhere from_item can be one of:\n\n    [ ONLY ] table_name [ * ] [ [ AS ] alias [ ( column_alias [, ...] ) ] ]\n                [ TABLESAMPLE sampling_method ( argument [, ...] ) [ REPEATABLE ( seed ) ] ]\n    [ LATERAL ] ( select ) [ [ AS ] alias [ ( column_alias [, ...] ) ] ]\n    with_query_name [ [ AS ] alias [ ( column_alias [, ...] ) ] ]\n    [ LATERAL ] function_name ( [ argument [, ...] ] )\n                [ WITH ORDINALITY ] [ [ AS ] alias [ ( column_alias [, ...] ) ] ]\n    [ LATERAL ] function_name ( [ argument [, ...] ] ) [ AS ] alias ( column_definition [, ...] )\n    [ LATERAL ] function_name ( [ argument [, ...] ] ) AS ( column_definition [, ...] )\n    [ LATERAL ] ROWS FROM( function_name ( [ argument [, ...] ] ) [ AS ( column_definition [, ...] ) ] [, ...] )\n                [ WITH ORDINALITY ] [ [ AS ] alias [ ( column_alias [, ...] ) ] ]\n    from_item join_type from_item { ON join_condition | USING ( join_column [, ...] ) [ AS join_using_alias ] }\n    from_item NATURAL join_type from_item\n    from_item CROSS JOIN from_item\n\nand grouping_element can be one of:\n\n    ( )\n    expression\n    ( expression [, ...] )\n    ROLLUP ( { expression | ( expression [, ...] ) } [, ...] )\n    CUBE ( { expression | ( expression [, ...] ) } [, ...] )\n    GROUPING SETS ( grouping_element [, ...] )\n\nand with_query is:\n\n    with_query_name [ ( column_name [, ...] ) ] AS [ [ NOT ] MATERIALIZED ] ( select | values | insert | update | delete )\n        [ SEARCH { BREADTH | DEPTH } FIRST BY column_name [, ...] SET search_seq_col_name ]\n        [ CYCLE column_name [, ...] SET cycle_mark_col_name [ TO cycle_mark_value DEFAULT cycle_mark_default ] USING cycle_path_col_name ]\n\nTABLE [ ONLY ] table_name [ * ]\n\n"
    },
    {
      "title": "Description",
      "text": "SELECTretrieves rows from zero or more tables. The general processing ofSELECTis as follows:\nAll queries in theWITHlist are computed. These effectively serve as temporary tables that can be referenced in theFROMlist. AWITHquery that is referenced more than once inFROMis computed only once, unless specified otherwise withNOT MATERIALIZED. (SeeWITH Clausebelow.)\nAll elements in theFROMlist are computed. (Each element in theFROMlist is a real or virtual table.) If more than one element is specified in theFROMlist, they are cross-joined together. (SeeFROM Clausebelow.)\nIf theWHEREclause is specified, all rows that do not satisfy the condition are eliminated from the output. (SeeWHERE Clausebelow.)\nIf theGROUP BYclause is specified, or if there are aggregate function calls, the output is combined into groups of rows that match on one or more values, and the results of aggregate functions are computed. If theHAVINGclause is present, it eliminates groups that do not satisfy the given condition. (SeeGROUP BY ClauseandHAVING Clausebelow.) Although query output columns are nominally computed in the next step, they can also be referenced (by name or ordinal number) in theGROUP BYclause.\nThe actual output rows are computed using theSELECToutput expressions for each selected row or row group. (SeeSELECT Listbelow.)\nSELECT DISTINCTeliminates duplicate rows from the result.SELECT DISTINCT ONeliminates rows that match on all the specified expressions.SELECT ALL(the default) will return all candidate rows, including duplicates. (SeeDISTINCT Clausebelow.)\nUsing the operatorsUNION,INTERSECT, andEXCEPT, the output of more than oneSELECTstatement can be combined to form a single result set. TheUNIONoperator returns all rows that are in one or both of the result sets. TheINTERSECToperator returns all rows that are strictly in both result sets. TheEXCEPToperator returns the rows that are in the first result set but not in the second. In all three cases, duplicate rows are eliminated unlessALLis specified. The noise wordDISTINCTcan be added to explicitly specify eliminating duplicate rows. Notice thatDISTINCTis the default behavior here, even thoughALLis the default forSELECTitself. (SeeUNION Clause,INTERSECT Clause, andEXCEPT Clausebelow.)\nIf theORDER BYclause is specified, the returned rows are sorted in the specified order. IfORDER BYis not given, the rows are returned in whatever order the system finds fastest to produce. (SeeORDER BY Clausebelow.)\nIf theLIMIT(orFETCH FIRST) orOFFSETclause is specified, theSELECTstatement only returns a subset of the result rows. (SeeLIMIT Clausebelow.)\nIfFOR UPDATE,FOR NO KEY UPDATE,FOR SHAREorFOR KEY SHAREis specified, theSELECTstatement locks the selected rows against concurrent updates. (SeeThe Locking Clausebelow.)\nYou must haveSELECTprivilege on each column used in aSELECTcommand. The use ofFOR NO KEY UPDATE,FOR UPDATE,FOR SHAREorFOR KEY SHARErequiresUPDATEprivilege as well (for at least one column of each table so selected).\n"
    },
    {
      "title": "WITHClause",
      "text": "TheWITHclause allows you to specify one or more subqueries that can be referenced by name in the primary query. The subqueries effectively act as temporary tables or views for the duration of the primary query. Each subquery can be aSELECT,TABLE,VALUES,INSERT,UPDATEorDELETEstatement. When writing a data-modifying statement (INSERT,UPDATEorDELETE) inWITH, it is usual to include aRETURNINGclause. It is the output ofRETURNING,notthe underlying table that the statement modifies, that forms the temporary table that is read by the primary query. IfRETURNINGis omitted, the statement is still executed, but it produces no output so it cannot be referenced as a table by the primary query.\nA name (without schema qualification) must be specified for eachWITHquery. Optionally, a list of column names can be specified; if this is omitted, the column names are inferred from the subquery.\nIfRECURSIVEis specified, it allows aSELECTsubquery to reference itself by name. Such a subquery must have the form\n\n\nCODE:\n\nnon_recursive_term UNION [ ALL | DISTINCT ] recursive_term\n\nwhere the recursive self-reference must appear on the right-hand side of theUNION. Only one recursive self-reference is permitted per query. Recursive data-modifying statements are not supported, but you can use the results of a recursiveSELECTquery in a data-modifying statement. SeeSection 7.8for an example.\nAnother effect ofRECURSIVEis thatWITHqueries need not be ordered: a query can reference another one that is later in the list. (However, circular references, or mutual recursion, are not implemented.) WithoutRECURSIVE,WITHqueries can only reference siblingWITHqueries that are earlier in theWITHlist.\nWhen there are multiple queries in theWITHclause,RECURSIVEshould be written only once, immediately afterWITH. It applies to all queries in theWITHclause, though it has no effect on queries that do not use recursion or forward references.\nThe optionalSEARCHclause computes asearch sequence columnthat can be used for ordering the results of a recursive query in either breadth-first or depth-first order. The supplied column name list specifies the row key that is to be used for keeping track of visited rows. A column namedsearch_seq_col_namewill be added to the result column list of theWITHquery. This column can be ordered by in the outer query to achieve the respective ordering. SeeSection 7.8.2.1for examples.\nThe optionalCYCLEclause is used to detect cycles in recursive queries. The supplied column name list specifies the row key that is to be used for keeping track of visited rows. A column namedcycle_mark_col_namewill be added to the result column list of theWITHquery. This column will be set tocycle_mark_valuewhen a cycle has been detected, else tocycle_mark_default. Furthermore, processing of the recursive union will stop when a cycle has been detected.cycle_mark_valueandcycle_mark_defaultmust be constants and they must be coercible to a common data type, and the data type must have an inequality operator. (The SQL standard requires that they be Boolean constants or character strings, but PostgreSQL does not require that.) By default,TRUEandFALSE(of typeboolean) are used. Furthermore, a column namedcycle_path_col_namewill be added to the result column list of theWITHquery. This column is used internally for tracking visited rows. SeeSection 7.8.2.2for examples.\nBoth theSEARCHand theCYCLEclause are only valid for recursiveWITHqueries. Thewith_querymust be aUNION(orUNION ALL) of twoSELECT(or equivalent) commands (no nestedUNIONs). If both clauses are used, the column added by theSEARCHclause appears before the columns added by theCYCLEclause.\nThe primary query and theWITHqueries are all (notionally) executed at the same time. This implies that the effects of a data-modifying statement inWITHcannot be seen from other parts of the query, other than by reading itsRETURNINGoutput. If two such data-modifying statements attempt to modify the same row, the results are unspecified.\nA key property ofWITHqueries is that they are normally evaluated only once per execution of the primary query, even if the primary query refers to them more than once. In particular, data-modifying statements are guaranteed to be executed once and only once, regardless of whether the primary query reads all or any of their output.\nHowever, aWITHquery can be markedNOT MATERIALIZEDto remove this guarantee. In that case, theWITHquery can be folded into the primary query much as though it were a simple sub-SELECTin the primary query'sFROMclause. This results in duplicate computations if the primary query refers to thatWITHquery more than once; but if each such use requires only a few rows of theWITHquery's total output,NOT MATERIALIZEDcan provide a net savings by allowing the queries to be optimized jointly.NOT MATERIALIZEDis ignored if it is attached to aWITHquery that is recursive or is not side-effect-free (i.e., is not a plainSELECTcontaining no volatile functions).\nBy default, a side-effect-freeWITHquery is folded into the primary query if it is used exactly once in the primary query'sFROMclause. This allows joint optimization of the two query levels in situations where that should be semantically invisible. However, such folding can be prevented by marking theWITHquery asMATERIALIZED. That might be useful, for example, if theWITHquery is being used as an optimization fence to prevent the planner from choosing a bad plan.PostgreSQLversions before v12 never did such folding, so queries written for older versions might rely onWITHto act as an optimization fence.\nSeeSection 7.8for additional information.\n"
    },
    {
      "title": "FROMClause",
      "text": "TheFROMclause specifies one or more source tables for theSELECT. If multiple sources are specified, the result is the Cartesian product (cross join) of all the sources. But usually qualification conditions are added (viaWHERE) to restrict the returned rows to a small subset of the Cartesian product.\nTheFROMclause can contain the following elements:\nThe name (optionally schema-qualified) of an existing table or view. IfONLYis specified before the table name, only that table is scanned. IfONLYis not specified, the table and all its descendant tables (if any) are scanned. Optionally,*can be specified after the table name to explicitly indicate that descendant tables are included.\nA substitute name for theFROMitem containing the alias. An alias is used for brevity or to eliminate ambiguity for self-joins (where the same table is scanned multiple times). When an alias is provided, it completely hides the actual name of the table or function; for example givenFROM foo AS f, the remainder of theSELECTmust refer to thisFROMitem asfnotfoo. If an alias is written, a column alias list can also be written to provide substitute names for one or more columns of the table.\nATABLESAMPLEclause after atable_nameindicates that the specifiedsampling_methodshould be used to retrieve a subset of the rows in that table. This sampling precedes the application of any other filters such asWHEREclauses. The standardPostgreSQLdistribution includes two sampling methods,BERNOULLIandSYSTEM, and other sampling methods can be installed in the database via extensions.\nTheBERNOULLIandSYSTEMsampling methods each accept a singleargumentwhich is the fraction of the table to sample, expressed as a percentage between 0 and 100. This argument can be anyreal-valued expression. (Other sampling methods might accept more or different arguments.) These two methods each return a randomly-chosen sample of the table that will contain approximately the specified percentage of the table's rows. TheBERNOULLImethod scans the whole table and selects or ignores individual rows independently with the specified probability. TheSYSTEMmethod does block-level sampling with each block having the specified chance of being selected; all rows in each selected block are returned. TheSYSTEMmethod is significantly faster than theBERNOULLImethod when small sampling percentages are specified, but it may return a less-random sample of the table as a result of clustering effects.\nThe optionalREPEATABLEclause specifies aseednumber or expression to use for generating random numbers within the sampling method. The seed value can be any non-null floating-point value. Two queries that specify the same seed andargumentvalues will select the same sample of the table, if the table has not been changed meanwhile. But different seed values will usually produce different samples. IfREPEATABLEis not given then a new random sample is selected for each query, based upon a system-generated seed. Note that some add-on sampling methods do not acceptREPEATABLE, and will always produce new samples on each use.\nA sub-SELECTcan appear in theFROMclause. This acts as though its output were created as a temporary table for the duration of this singleSELECTcommand. Note that the sub-SELECTmust be surrounded by parentheses, and an alias can be provided in the same way as for a table. AVALUEScommand can also be used here.\nAWITHquery is referenced by writing its name, just as though the query's name were a table name. (In fact, theWITHquery hides any real table of the same name for the purposes of the primary query. If necessary, you can refer to a real table of the same name by schema-qualifying the table's name.) An alias can be provided in the same way as for a table.\nFunction calls can appear in theFROMclause. (This is especially useful for functions that return result sets, but any function can be used.) This acts as though the function's output were created as a temporary table for the duration of this singleSELECTcommand. If the function's result type is composite (including the case of a function with multipleOUTparameters), each attribute becomes a separate column in the implicit table.\nWhen the optionalWITH ORDINALITYclause is added to the function call, an additional column of typebigintwill be appended to the function's result column(s). This column numbers the rows of the function's result set, starting from 1. By default, this column is namedordinality.\nAn alias can be provided in the same way as for a table. If an alias is written, a column alias list can also be written to provide substitute names for one or more attributes of the function's composite return type, including the ordinality column if present.\nMultiple function calls can be combined into a singleFROM-clause item by surrounding them withROWS FROM( ... ). The output of such an item is the concatenation of the first row from each function, then the second row from each function, etc. If some of the functions produce fewer rows than others, null values are substituted for the missing data, so that the total number of rows returned is always the same as for the function that produced the most rows.\nIf the function has been defined as returning therecorddata type, then an alias or the key wordASmust be present, followed by a column definition list in the form(column_namedata_type[, ...]). The column definition list must match the actual number and types of columns returned by the function.\nWhen using theROWS FROM( ... )syntax, if one of the functions requires a column definition list, it's preferred to put the column definition list after the function call insideROWS FROM( ... ). A column definition list can be placed after theROWS FROM( ... )construct only if there's just a single function and noWITH ORDINALITYclause.\nTo useORDINALITYtogether with a column definition list, you must use theROWS FROM( ... )syntax and put the column definition list insideROWS FROM( ... ).\nOne of\n[ INNER ] JOIN\nLEFT [ OUTER ] JOIN\nRIGHT [ OUTER ] JOIN\nFULL [ OUTER ] JOIN\nFor theINNERandOUTERjoin types, a join condition must be specified, namely exactly one ofONjoin_condition,USING (join_column[, ...]), orNATURAL. See below for the meaning.\nAJOINclause combines twoFROMitems, which for convenience we will refer to as“tables”, though in reality they can be any type ofFROMitem. Use parentheses if necessary to determine the order of nesting. In the absence of parentheses,JOINs nest left-to-right. In any caseJOINbinds more tightly than the commas separatingFROM-list items. All theJOINoptions are just a notational convenience, since they do nothing you couldn't do with plainFROMandWHERE.\nLEFT OUTER JOINreturns all rows in the qualified Cartesian product (i.e., all combined rows that pass its join condition), plus one copy of each row in the left-hand table for which there was no right-hand row that passed the join condition. This left-hand row is extended to the full width of the joined table by inserting null values for the right-hand columns. Note that only theJOINclause's own condition is considered while deciding which rows have matches. Outer conditions are applied afterwards.\nConversely,RIGHT OUTER JOINreturns all the joined rows, plus one row for each unmatched right-hand row (extended with nulls on the left). This is just a notational convenience, since you could convert it to aLEFT OUTER JOINby switching the left and right tables.\nFULL OUTER JOINreturns all the joined rows, plus one row for each unmatched left-hand row (extended with nulls on the right), plus one row for each unmatched right-hand row (extended with nulls on the left).\njoin_conditionis an expression resulting in a value of typeboolean(similar to aWHEREclause) that specifies which rows in a join are considered to match.\nA clause of the formUSING ( a, b, ... )is shorthand forON left_table.a = right_table.a AND left_table.b = right_table.b .... Also,USINGimplies that only one of each pair of equivalent columns will be included in the join output, not both.\nIf ajoin_using_aliasname is specified, it provides a table alias for the join columns. Only the join columns listed in theUSINGclause are addressable by this name. Unlike a regularalias, this does not hide the names of the joined tables from the rest of the query. Also unlike a regularalias, you cannot write a column alias list — the output names of the join columns are the same as they appear in theUSINGlist.\nNATURALis shorthand for aUSINGlist that mentions all columns in the two tables that have matching names. If there are no common column names,NATURALis equivalent toON TRUE.\nCROSS JOINis equivalent toINNER JOIN ON (TRUE), that is, no rows are removed by qualification. They produce a simple Cartesian product, the same result as you get from listing the two tables at the top level ofFROM, but restricted by the join condition (if any).\nTheLATERALkey word can precede a sub-SELECTFROMitem. This allows the sub-SELECTto refer to columns ofFROMitems that appear before it in theFROMlist. (WithoutLATERAL, each sub-SELECTis evaluated independently and so cannot cross-reference any otherFROMitem.)\nLATERALcan also precede a function-callFROMitem, but in this case it is a noise word, because the function expression can refer to earlierFROMitems in any case.\nALATERALitem can appear at top level in theFROMlist, or within aJOINtree. In the latter case it can also refer to any items that are on the left-hand side of aJOINthat it is on the right-hand side of.\nWhen aFROMitem containsLATERALcross-references, evaluation proceeds as follows: for each row of theFROMitem providing the cross-referenced column(s), or set of rows of multipleFROMitems providing the columns, theLATERALitem is evaluated using that row or row set's values of the columns. The resulting row(s) are joined as usual with the rows they were computed from. This is repeated for each row or set of rows from the column source table(s).\nThe column source table(s) must beINNERorLEFTjoined to theLATERALitem, else there would not be a well-defined set of rows from which to compute each set of rows for theLATERALitem. Thus, although a construct such asXRIGHT JOIN LATERALYis syntactically valid, it is not actually allowed forYto referenceX.\n"
    },
    {
      "title": "WHEREClause",
      "text": "The optionalWHEREclause has the general form\n\n\nCODE:\n\nWHERE condition\n\nwhereconditionis any expression that evaluates to a result of typeboolean. Any row that does not satisfy this condition will be eliminated from the output. A row satisfies the condition if it returns true when the actual row values are substituted for any variable references.\n"
    },
    {
      "title": "GROUP BYClause",
      "text": "The optionalGROUP BYclause has the general form\n\n\nCODE:\n\nGROUP BY [ ALL | DISTINCT ] grouping_element [, ...]\n\nGROUP BYwill condense into a single row all selected rows that share the same values for the grouped expressions. Anexpressionused inside agrouping_elementcan be an input column name, or the name or ordinal number of an output column (SELECTlist item), or an arbitrary expression formed from input-column values. In case of ambiguity, aGROUP BYname will be interpreted as an input-column name rather than an output column name.\nIf any ofGROUPING SETS,ROLLUPorCUBEare present as grouping elements, then theGROUP BYclause as a whole defines some number of independentgrouping sets. The effect of this is equivalent to constructing aUNION ALLbetween subqueries with the individual grouping sets as theirGROUP BYclauses. The optionalDISTINCTclause removes duplicate sets before processing; it doesnottransform theUNION ALLinto aUNION DISTINCT. For further details on the handling of grouping sets seeSection 7.2.4.\nAggregate functions, if any are used, are computed across all rows making up each group, producing a separate value for each group. (If there are aggregate functions but noGROUP BYclause, the query is treated as having a single group comprising all the selected rows.) The set of rows fed to each aggregate function can be further filtered by attaching aFILTERclause to the aggregate function call; seeSection 4.2.7for more information. When aFILTERclause is present, only those rows matching it are included in the input to that aggregate function.\nWhenGROUP BYis present, or any aggregate functions are present, it is not valid for theSELECTlist expressions to refer to ungrouped columns except within aggregate functions or when the ungrouped column is functionally dependent on the grouped columns, since there would otherwise be more than one possible value to return for an ungrouped column. A functional dependency exists if the grouped columns (or a subset thereof) are the primary key of the table containing the ungrouped column.\nKeep in mind that all aggregate functions are evaluated before evaluating any“scalar”expressions in theHAVINGclause orSELECTlist. This means that, for example, aCASEexpression cannot be used to skip evaluation of an aggregate function; seeSection 4.2.14.\nCurrently,FOR NO KEY UPDATE,FOR UPDATE,FOR SHAREandFOR KEY SHAREcannot be specified withGROUP BY.\n"
    },
    {
      "title": "HAVINGClause",
      "text": "The optionalHAVINGclause has the general form\n\n\nCODE:\n\nHAVING condition\n\nwhereconditionis the same as specified for theWHEREclause.\nHAVINGeliminates group rows that do not satisfy the condition.HAVINGis different fromWHERE:WHEREfilters individual rows before the application ofGROUP BY, whileHAVINGfilters group rows created byGROUP BY. Each column referenced inconditionmust unambiguously reference a grouping column, unless the reference appears within an aggregate function or the ungrouped column is functionally dependent on the grouping columns.\nThe presence ofHAVINGturns a query into a grouped query even if there is noGROUP BYclause. This is the same as what happens when the query contains aggregate functions but noGROUP BYclause. All the selected rows are considered to form a single group, and theSELECTlist andHAVINGclause can only reference table columns from within aggregate functions. Such a query will emit a single row if theHAVINGcondition is true, zero rows if it is not true.\nCurrently,FOR NO KEY UPDATE,FOR UPDATE,FOR SHAREandFOR KEY SHAREcannot be specified withHAVING.\n"
    },
    {
      "title": "WINDOWClause",
      "text": "The optionalWINDOWclause has the general form\n\n\nCODE:\n\nWINDOW window_name AS ( window_definition ) [, ...]\n\nwherewindow_nameis a name that can be referenced fromOVERclauses or subsequent window definitions, andwindow_definitionis\n\n\nCODE:\n\n[ existing_window_name ]\n[ PARTITION BY expression [, ...] ]\n[ ORDER BY expression [ ASC | DESC | USING operator ] [ NULLS { FIRST | LAST } ] [, ...] ]\n[ frame_clause ]\n\nIf anexisting_window_nameis specified it must refer to an earlier entry in theWINDOWlist; the new window copies its partitioning clause from that entry, as well as its ordering clause if any. In this case the new window cannot specify its ownPARTITION BYclause, and it can specifyORDER BYonly if the copied window does not have one. The new window always uses its own frame clause; the copied window must not specify a frame clause.\nThe elements of thePARTITION BYlist are interpreted in much the same fashion as elements of aGROUP BYclause, except that they are always simple expressions and never the name or number of an output column. Another difference is that these expressions can contain aggregate function calls, which are not allowed in a regularGROUP BYclause. They are allowed here because windowing occurs after grouping and aggregation.\nSimilarly, the elements of theORDER BYlist are interpreted in much the same fashion as elements of a statement-levelORDER BYclause, except that the expressions are always taken as simple expressions and never the name or number of an output column.\nThe optionalframe_clausedefines thewindow framefor window functions that depend on the frame (not all do). The window frame is a set of related rows for each row of the query (called thecurrent row). Theframe_clausecan be one of\n\n\nCODE:\n\n{ RANGE | ROWS | GROUPS } frame_start [ frame_exclusion ]\n{ RANGE | ROWS | GROUPS } BETWEEN frame_start AND frame_end [ frame_exclusion ]\n\nwhereframe_startandframe_endcan be one of\n\n\nCODE:\n\nUNBOUNDED PRECEDING\noffset PRECEDING\nCURRENT ROW\noffset FOLLOWING\nUNBOUNDED FOLLOWING\n\nandframe_exclusioncan be one of\n\n\nCODE:\n\nEXCLUDE CURRENT ROW\nEXCLUDE GROUP\nEXCLUDE TIES\nEXCLUDE NO OTHERS\n\nIfframe_endis omitted it defaults toCURRENT ROW. Restrictions are thatframe_startcannot beUNBOUNDED FOLLOWING,frame_endcannot beUNBOUNDED PRECEDING, and theframe_endchoice cannot appear earlier in the above list offrame_startandframe_endoptions than theframe_startchoice does — for exampleRANGE BETWEEN CURRENT ROW ANDoffsetPRECEDINGis not allowed.\nThe default framing option isRANGE UNBOUNDED PRECEDING, which is the same asRANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW; it sets the frame to be all rows from the partition start up through the current row's lastpeer(a row that the window'sORDER BYclause considers equivalent to the current row; all rows are peers if there is noORDER BY). In general,UNBOUNDED PRECEDINGmeans that the frame starts with the first row of the partition, and similarlyUNBOUNDED FOLLOWINGmeans that the frame ends with the last row of the partition, regardless ofRANGE,ROWSorGROUPSmode. InROWSmode,CURRENT ROWmeans that the frame starts or ends with the current row; but inRANGEorGROUPSmode it means that the frame starts or ends with the current row's first or last peer in theORDER BYordering. TheoffsetPRECEDINGandoffsetFOLLOWINGoptions vary in meaning depending on the frame mode. InROWSmode, theoffsetis an integer indicating that the frame starts or ends that many rows before or after the current row. InGROUPSmode, theoffsetis an integer indicating that the frame starts or ends that many peer groups before or after the current row's peer group, where apeer groupis a group of rows that are equivalent according to the window'sORDER BYclause. InRANGEmode, use of anoffsetoption requires that there be exactly oneORDER BYcolumn in the window definition. Then the frame contains those rows whose ordering column value is no more thanoffsetless than (forPRECEDING) or more than (forFOLLOWING) the current row's ordering column value. In these cases the data type of theoffsetexpression depends on the data type of the ordering column. For numeric ordering columns it is typically of the same type as the ordering column, but for datetime ordering columns it is aninterval. In all these cases, the value of theoffsetmust be non-null and non-negative. Also, while theoffsetdoes not have to be a simple constant, it cannot contain variables, aggregate functions, or window functions.\nTheframe_exclusionoption allows rows around the current row to be excluded from the frame, even if they would be included according to the frame start and frame end options.EXCLUDE CURRENT ROWexcludes the current row from the frame.EXCLUDE GROUPexcludes the current row and its ordering peers from the frame.EXCLUDE TIESexcludes any peers of the current row from the frame, but not the current row itself.EXCLUDE NO OTHERSsimply specifies explicitly the default behavior of not excluding the current row or its peers.\nBeware that theROWSmode can produce unpredictable results if theORDER BYordering does not order the rows uniquely. TheRANGEandGROUPSmodes are designed to ensure that rows that are peers in theORDER BYordering are treated alike: all rows of a given peer group will be in the frame or excluded from it.\nThe purpose of aWINDOWclause is to specify the behavior ofwindow functionsappearing in the query'sSELECTlistorORDER BYclause. These functions can reference theWINDOWclause entries by name in theirOVERclauses. AWINDOWclause entry does not have to be referenced anywhere, however; if it is not used in the query it is simply ignored. It is possible to use window functions without anyWINDOWclause at all, since a window function call can specify its window definition directly in itsOVERclause. However, theWINDOWclause saves typing when the same window definition is needed for more than one window function.\nCurrently,FOR NO KEY UPDATE,FOR UPDATE,FOR SHAREandFOR KEY SHAREcannot be specified withWINDOW.\nWindow functions are described in detail inSection 3.5,Section 4.2.8, andSection 7.2.5.\n"
    },
    {
      "title": "SELECTList",
      "text": "TheSELECTlist (between the key wordsSELECTandFROM) specifies expressions that form the output rows of theSELECTstatement. The expressions can (and usually do) refer to columns computed in theFROMclause.\nJust as in a table, every output column of aSELECThas a name. In a simpleSELECTthis name is just used to label the column for display, but when theSELECTis a sub-query of a larger query, the name is seen by the larger query as the column name of the virtual table produced by the sub-query. To specify the name to use for an output column, writeASoutput_nameafter the column's expression. (You can omitAS, but only if the desired output name does not match anyPostgreSQLkeyword (seeAppendix C). For protection against possible future keyword additions, it is recommended that you always either writeASor double-quote the output name.) If you do not specify a column name, a name is chosen automatically byPostgreSQL. If the column's expression is a simple column reference then the chosen name is the same as that column's name. In more complex cases a function or type name may be used, or the system may fall back on a generated name such as?column?.\nAn output column's name can be used to refer to the column's value inORDER BYandGROUP BYclauses, but not in theWHEREorHAVINGclauses; there you must write out the expression instead.\nInstead of an expression,*can be written in the output list as a shorthand for all the columns of the selected rows. Also, you can writetable_name.*as a shorthand for the columns coming from just that table. In these cases it is not possible to specify new names withAS; the output column names will be the same as the table columns' names.\nAccording to the SQL standard, the expressions in the output list should be computed before applyingDISTINCT,ORDER BY, orLIMIT. This is obviously necessary when usingDISTINCT, since otherwise it's not clear what values are being made distinct. However, in many cases it is convenient if output expressions are computed afterORDER BYandLIMIT; particularly if the output list contains any volatile or expensive functions. With that behavior, the order of function evaluations is more intuitive and there will not be evaluations corresponding to rows that never appear in the output.PostgreSQLwill effectively evaluate output expressions after sorting and limiting, so long as those expressions are not referenced inDISTINCT,ORDER BYorGROUP BY. (As a counterexample,SELECT f(x) FROM tab ORDER BY 1clearly must evaluatef(x)before sorting.) Output expressions that contain set-returning functions are effectively evaluated after sorting and before limiting, so thatLIMITwill act to cut off the output from a set-returning function.\n"
    },
    {
      "title": "Note",
      "text": "PostgreSQLversions before 9.6 did not provide any guarantees about the timing of evaluation of output expressions versus sorting and limiting; it depended on the form of the chosen query plan.\n"
    },
    {
      "title": "DISTINCTClause",
      "text": "IfSELECT DISTINCTis specified, all duplicate rows are removed from the result set (one row is kept from each group of duplicates).SELECT ALLspecifies the opposite: all rows are kept; that is the default.\nSELECT DISTINCT ON (expression[, ...] )keeps only the first row of each set of rows where the given expressions evaluate to equal. TheDISTINCT ONexpressions are interpreted using the same rules as forORDER BY(see above). Note that the“first row”of each set is unpredictable unlessORDER BYis used to ensure that the desired row appears first. For example:\n\n\nCODE:\n\nSELECT DISTINCT ON (location) location, time, report\n    FROM weather_reports\n    ORDER BY location, time DESC;\n\nretrieves the most recent weather report for each location. But if we had not usedORDER BYto force descending order of time values for each location, we'd have gotten a report from an unpredictable time for each location.\nTheDISTINCT ONexpression(s) must match the leftmostORDER BYexpression(s). TheORDER BYclause will normally contain additional expression(s) that determine the desired precedence of rows within eachDISTINCT ONgroup.\nCurrently,FOR NO KEY UPDATE,FOR UPDATE,FOR SHAREandFOR KEY SHAREcannot be specified withDISTINCT.\n"
    },
    {
      "title": "UNIONClause",
      "text": "TheUNIONclause has this general form:\n\n\nCODE:\n\nselect_statement UNION [ ALL | DISTINCT ] select_statement\n\nselect_statementis anySELECTstatement without anORDER BY,LIMIT,FOR NO KEY UPDATE,FOR UPDATE,FOR SHARE, orFOR KEY SHAREclause. (ORDER BYandLIMITcan be attached to a subexpression if it is enclosed in parentheses. Without parentheses, these clauses will be taken to apply to the result of theUNION, not to its right-hand input expression.)\nTheUNIONoperator computes the set union of the rows returned by the involvedSELECTstatements. A row is in the set union of two result sets if it appears in at least one of the result sets. The twoSELECTstatements that represent the direct operands of theUNIONmust produce the same number of columns, and corresponding columns must be of compatible data types.\nThe result ofUNIONdoes not contain any duplicate rows unless theALLoption is specified.ALLprevents elimination of duplicates. (Therefore,UNION ALLis usually significantly quicker thanUNION; useALLwhen you can.)DISTINCTcan be written to explicitly specify the default behavior of eliminating duplicate rows.\nMultipleUNIONoperators in the sameSELECTstatement are evaluated left to right, unless otherwise indicated by parentheses.\nCurrently,FOR NO KEY UPDATE,FOR UPDATE,FOR SHAREandFOR KEY SHAREcannot be specified either for aUNIONresult or for any input of aUNION.\n"
    },
    {
      "title": "INTERSECTClause",
      "text": "TheINTERSECTclause has this general form:\n\n\nCODE:\n\nselect_statement INTERSECT [ ALL | DISTINCT ] select_statement\n\nselect_statementis anySELECTstatement without anORDER BY,LIMIT,FOR NO KEY UPDATE,FOR UPDATE,FOR SHARE, orFOR KEY SHAREclause.\nTheINTERSECToperator computes the set intersection of the rows returned by the involvedSELECTstatements. A row is in the intersection of two result sets if it appears in both result sets.\nThe result ofINTERSECTdoes not contain any duplicate rows unless theALLoption is specified. WithALL, a row that hasmduplicates in the left table andnduplicates in the right table will appear min(m,n) times in the result set.DISTINCTcan be written to explicitly specify the default behavior of eliminating duplicate rows.\nMultipleINTERSECToperators in the sameSELECTstatement are evaluated left to right, unless parentheses dictate otherwise.INTERSECTbinds more tightly thanUNION. That is,A UNION B INTERSECT Cwill be read asA UNION (B INTERSECT C).\nCurrently,FOR NO KEY UPDATE,FOR UPDATE,FOR SHAREandFOR KEY SHAREcannot be specified either for anINTERSECTresult or for any input of anINTERSECT.\n"
    },
    {
      "title": "EXCEPTClause",
      "text": "TheEXCEPTclause has this general form:\n\n\nCODE:\n\nselect_statement EXCEPT [ ALL | DISTINCT ] select_statement\n\nselect_statementis anySELECTstatement without anORDER BY,LIMIT,FOR NO KEY UPDATE,FOR UPDATE,FOR SHARE, orFOR KEY SHAREclause.\nTheEXCEPToperator computes the set of rows that are in the result of the leftSELECTstatement but not in the result of the right one.\nThe result ofEXCEPTdoes not contain any duplicate rows unless theALLoption is specified. WithALL, a row that hasmduplicates in the left table andnduplicates in the right table will appear max(m-n,0) times in the result set.DISTINCTcan be written to explicitly specify the default behavior of eliminating duplicate rows.\nMultipleEXCEPToperators in the sameSELECTstatement are evaluated left to right, unless parentheses dictate otherwise.EXCEPTbinds at the same level asUNION.\nCurrently,FOR NO KEY UPDATE,FOR UPDATE,FOR SHAREandFOR KEY SHAREcannot be specified either for anEXCEPTresult or for any input of anEXCEPT.\n"
    },
    {
      "title": "ORDER BYClause",
      "text": "The optionalORDER BYclause has this general form:\n\n\nCODE:\n\nORDER BY expression [ ASC | DESC | USING operator ] [ NULLS { FIRST | LAST } ] [, ...]\n\nTheORDER BYclause causes the result rows to be sorted according to the specified expression(s). If two rows are equal according to the leftmost expression, they are compared according to the next expression and so on. If they are equal according to all specified expressions, they are returned in an implementation-dependent order.\nEachexpressioncan be the name or ordinal number of an output column (SELECTlist item), or it can be an arbitrary expression formed from input-column values.\nThe ordinal number refers to the ordinal (left-to-right) position of the output column. This feature makes it possible to define an ordering on the basis of a column that does not have a unique name. This is never absolutely necessary because it is always possible to assign a name to an output column using theASclause.\nIt is also possible to use arbitrary expressions in theORDER BYclause, including columns that do not appear in theSELECToutput list. Thus the following statement is valid:\n\n\nCODE:\n\nSELECT name FROM distributors ORDER BY code;\n\nA limitation of this feature is that anORDER BYclause applying to the result of aUNION,INTERSECT, orEXCEPTclause can only specify an output column name or number, not an expression.\nIf anORDER BYexpression is a simple name that matches both an output column name and an input column name,ORDER BYwill interpret it as the output column name. This is the opposite of the choice thatGROUP BYwill make in the same situation. This inconsistency is made to be compatible with the SQL standard.\nOptionally one can add the key wordASC(ascending) orDESC(descending) after any expression in theORDER BYclause. If not specified,ASCis assumed by default. Alternatively, a specific ordering operator name can be specified in theUSINGclause. An ordering operator must be a less-than or greater-than member of some B-tree operator family.ASCis usually equivalent toUSING <andDESCis usually equivalent toUSING >. (But the creator of a user-defined data type can define exactly what the default sort ordering is, and it might correspond to operators with other names.)\nIfNULLS LASTis specified, null values sort after all non-null values; ifNULLS FIRSTis specified, null values sort before all non-null values. If neither is specified, the default behavior isNULLS LASTwhenASCis specified or implied, andNULLS FIRSTwhenDESCis specified (thus, the default is to act as though nulls are larger than non-nulls). WhenUSINGis specified, the default nulls ordering depends on whether the operator is a less-than or greater-than operator.\nNote that ordering options apply only to the expression they follow; for exampleORDER BY x, y DESCdoes not mean the same thing asORDER BY x DESC, y DESC.\nCharacter-string data is sorted according to the collation that applies to the column being sorted. That can be overridden at need by including aCOLLATEclause in theexpression, for exampleORDER BY mycolumn COLLATE \"en_US\". For more information seeSection 4.2.10andSection 24.2.\n"
    },
    {
      "title": "LIMITClause",
      "text": "TheLIMITclause consists of two independent sub-clauses:\n\n\nCODE:\n\nLIMIT { count | ALL }\nOFFSET start\n\nThe parametercountspecifies the maximum number of rows to return, whilestartspecifies the number of rows to skip before starting to return rows. When both are specified,startrows are skipped before starting to count thecountrows to be returned.\nIf thecountexpression evaluates to NULL, it is treated asLIMIT ALL, i.e., no limit. Ifstartevaluates to NULL, it is treated the same asOFFSET 0.\nSQL:2008 introduced a different syntax to achieve the same result, whichPostgreSQLalso supports. It is:\n\n\nCODE:\n\nOFFSET start { ROW | ROWS }\nFETCH { FIRST | NEXT } [ count ] { ROW | ROWS } { ONLY | WITH TIES }\n\nIn this syntax, thestartorcountvalue is required by the standard to be a literal constant, a parameter, or a variable name; as aPostgreSQLextension, other expressions are allowed, but will generally need to be enclosed in parentheses to avoid ambiguity. Ifcountis omitted in aFETCHclause, it defaults to 1. TheWITH TIESoption is used to return any additional rows that tie for the last place in the result set according to theORDER BYclause;ORDER BYis mandatory in this case, andSKIP LOCKEDis not allowed.ROWandROWSas well asFIRSTandNEXTare noise words that don't influence the effects of these clauses. According to the standard, theOFFSETclause must come before theFETCHclause if both are present; butPostgreSQLis laxer and allows either order.\nWhen usingLIMIT, it is a good idea to use anORDER BYclause that constrains the result rows into a unique order. Otherwise you will get an unpredictable subset of the query's rows — you might be asking for the tenth through twentieth rows, but tenth through twentieth in what ordering? You don't know what ordering unless you specifyORDER BY.\nThe query planner takesLIMITinto account when generating a query plan, so you are very likely to get different plans (yielding different row orders) depending on what you use forLIMITandOFFSET. Thus, using differentLIMIT/OFFSETvalues to select different subsets of a query resultwill give inconsistent resultsunless you enforce a predictable result ordering withORDER BY. This is not a bug; it is an inherent consequence of the fact that SQL does not promise to deliver the results of a query in any particular order unlessORDER BYis used to constrain the order.\nIt is even possible for repeated executions of the sameLIMITquery to return different subsets of the rows of a table, if there is not anORDER BYto enforce selection of a deterministic subset. Again, this is not a bug; determinism of the results is simply not guaranteed in such a case.\n"
    },
    {
      "title": "The Locking Clause",
      "text": "FOR UPDATE,FOR NO KEY UPDATE,FOR SHAREandFOR KEY SHAREarelocking clauses; they affect howSELECTlocks rows as they are obtained from the table.\nThe locking clause has the general form\n\n\nCODE:\n\nFOR lock_strength [ OF table_name [, ...] ] [ NOWAIT | SKIP LOCKED ]\n\nwherelock_strengthcan be one of\n\n\nCODE:\n\nUPDATE\nNO KEY UPDATE\nSHARE\nKEY SHARE\n\nFor more information on each row-level lock mode, refer toSection 13.3.2.\nTo prevent the operation from waiting for other transactions to commit, use either theNOWAITorSKIP LOCKEDoption. WithNOWAIT, the statement reports an error, rather than waiting, if a selected row cannot be locked immediately. WithSKIP LOCKED, any selected rows that cannot be immediately locked are skipped. Skipping locked rows provides an inconsistent view of the data, so this is not suitable for general purpose work, but can be used to avoid lock contention with multiple consumers accessing a queue-like table. Note thatNOWAITandSKIP LOCKEDapply only to the row-level lock(s) — the requiredROW SHAREtable-level lock is still taken in the ordinary way (seeChapter 13). You can useLOCKwith theNOWAIToption first, if you need to acquire the table-level lock without waiting.\nIf specific tables are named in a locking clause, then only rows coming from those tables are locked; any other tables used in theSELECTare simply read as usual. A locking clause without a table list affects all tables used in the statement. If a locking clause is applied to a view or sub-query, it affects all tables used in the view or sub-query. However, these clauses do not apply toWITHqueries referenced by the primary query. If you want row locking to occur within aWITHquery, specify a locking clause within theWITHquery.\nMultiple locking clauses can be written if it is necessary to specify different locking behavior for different tables. If the same table is mentioned (or implicitly affected) by more than one locking clause, then it is processed as if it was only specified by the strongest one. Similarly, a table is processed asNOWAITif that is specified in any of the clauses affecting it. Otherwise, it is processed asSKIP LOCKEDif that is specified in any of the clauses affecting it.\nThe locking clauses cannot be used in contexts where returned rows cannot be clearly identified with individual table rows; for example they cannot be used with aggregation.\nWhen a locking clause appears at the top level of aSELECTquery, the rows that are locked are exactly those that are returned by the query; in the case of a join query, the rows locked are those that contribute to returned join rows. In addition, rows that satisfied the query conditions as of the query snapshot will be locked, although they will not be returned if they were updated after the snapshot and no longer satisfy the query conditions. If aLIMITis used, locking stops once enough rows have been returned to satisfy the limit (but note that rows skipped over byOFFSETwill get locked). Similarly, if a locking clause is used in a cursor's query, only rows actually fetched or stepped past by the cursor will be locked.\nWhen a locking clause appears in a sub-SELECT, the rows locked are those returned to the outer query by the sub-query. This might involve fewer rows than inspection of the sub-query alone would suggest, since conditions from the outer query might be used to optimize execution of the sub-query. For example,\n\n\nCODE:\n\nSELECT * FROM (SELECT * FROM mytable FOR UPDATE) ss WHERE col1 = 5;\n\nwill lock only rows havingcol1 = 5, even though that condition is not textually within the sub-query.\nPrevious releases failed to preserve a lock which is upgraded by a later savepoint. For example, this code:\n\n\nCODE:\n\nBEGIN;\nSELECT * FROM mytable WHERE key = 1 FOR UPDATE;\nSAVEPOINT s;\nUPDATE mytable SET ... WHERE key = 1;\nROLLBACK TO s;\n\nwould fail to preserve theFOR UPDATElock after theROLLBACK TO. This has been fixed in release 9.3.\n"
    },
    {
      "title": "Caution",
      "text": "It is possible for aSELECTcommand running at theREAD COMMITTEDtransaction isolation level and usingORDER BYand a locking clause to return rows out of order. This is becauseORDER BYis applied first. The command sorts the result, but might then block trying to obtain a lock on one or more of the rows. Once theSELECTunblocks, some of the ordering column values might have been modified, leading to those rows appearing to be out of order (though they are in order in terms of the original column values). This can be worked around at need by placing theFOR UPDATE/SHAREclause in a sub-query, for example\n\n\nCODE:\n\nSELECT * FROM (SELECT * FROM mytable FOR UPDATE) ss ORDER BY column1;\n\nNote that this will result in locking all rows ofmytable, whereasFOR UPDATEat the top level would lock only the actually returned rows. This can make for a significant performance difference, particularly if theORDER BYis combined withLIMITor other restrictions. So this technique is recommended only if concurrent updates of the ordering columns are expected and a strictly sorted result is required.\nAt theREPEATABLE READorSERIALIZABLEtransaction isolation level this would cause a serialization failure (with anSQLSTATEof'40001'), so there is no possibility of receiving rows out of order under these isolation levels.\n"
    },
    {
      "title": "TABLECommand",
      "text": "The command\n\n\nCODE:\n\nTABLE name\n\nis equivalent to\n\n\nCODE:\n\nSELECT * FROM name\n\nIt can be used as a top-level command or as a space-saving syntax variant in parts of complex queries. Only theWITH,UNION,INTERSECT,EXCEPT,ORDER BY,LIMIT,OFFSET,FETCHandFORlocking clauses can be used withTABLE; theWHEREclause and any form of aggregation cannot be used.\n"
    },
    {
      "title": "Examples",
      "text": "To join the tablefilmswith the tabledistributors:\n\n\nCODE:\n\nSELECT f.title, f.did, d.name, f.date_prod, f.kind\n    FROM distributors d JOIN films f USING (did);\n\n       title       | did |     name     | date_prod  |   kind\n-------------------+-----+--------------+------------+----------\n The Third Man     | 101 | British Lion | 1949-12-23 | Drama\n The African Queen | 101 | British Lion | 1951-08-11 | Romantic\n ...\n\nTo sum the columnlenof all films and group the results bykind:\n\n\nCODE:\n\nSELECT kind, sum(len) AS total FROM films GROUP BY kind;\n\n   kind   | total\n----------+-------\n Action   | 07:34\n Comedy   | 02:58\n Drama    | 14:28\n Musical  | 06:42\n Romantic | 04:38\n\nTo sum the columnlenof all films, group the results bykindand show those group totals that are less than 5 hours:\n\n\nCODE:\n\nSELECT kind, sum(len) AS total\n    FROM films\n    GROUP BY kind\n    HAVING sum(len) < interval '5 hours';\n\n   kind   | total\n----------+-------\n Comedy   | 02:58\n Romantic | 04:38\n\nThe following two examples are identical ways of sorting the individual results according to the contents of the second column (name):\n\n\nCODE:\n\nSELECT * FROM distributors ORDER BY name;\nSELECT * FROM distributors ORDER BY 2;\n\n did |       name\n-----+------------------\n 109 | 20th Century Fox\n 110 | Bavaria Atelier\n 101 | British Lion\n 107 | Columbia\n 102 | Jean Luc Godard\n 113 | Luso films\n 104 | Mosfilm\n 103 | Paramount\n 106 | Toho\n 105 | United Artists\n 111 | Walt Disney\n 112 | Warner Bros.\n 108 | Westward\n\nThe next example shows how to obtain the union of the tablesdistributorsandactors, restricting the results to those that begin with the letter W in each table. Only distinct rows are wanted, so the key wordALLis omitted.\n\n\nCODE:\n\ndistributors:               actors:\n did |     name              id |     name\n-----+--------------        ----+----------------\n 108 | Westward               1 | Woody Allen\n 111 | Walt Disney            2 | Warren Beatty\n 112 | Warner Bros.           3 | Walter Matthau\n ...                         ...\n\nSELECT distributors.name\n    FROM distributors\n    WHERE distributors.name LIKE 'W%'\nUNION\nSELECT actors.name\n    FROM actors\n    WHERE actors.name LIKE 'W%';\n\n      name\n----------------\n Walt Disney\n Walter Matthau\n Warner Bros.\n Warren Beatty\n Westward\n Woody Allen\n\nThis example shows how to use a function in theFROMclause, both with and without a column definition list:\n\n\nCODE:\n\nCREATE FUNCTION distributors(int) RETURNS SETOF distributors AS $$\n    SELECT * FROM distributors WHERE did = $1;\n$$ LANGUAGE SQL;\n\nSELECT * FROM distributors(111);\n did |    name\n-----+-------------\n 111 | Walt Disney\n\nCREATE FUNCTION distributors_2(int) RETURNS SETOF record AS $$\n    SELECT * FROM distributors WHERE did = $1;\n$$ LANGUAGE SQL;\n\nSELECT * FROM distributors_2(111) AS (f1 int, f2 text);\n f1  |     f2\n-----+-------------\n 111 | Walt Disney\n\nHere is an example of a function with an ordinality column added:\n\n\nCODE:\n\nSELECT * FROM unnest(ARRAY['a','b','c','d','e','f']) WITH ORDINALITY;\n unnest | ordinality\n--------+----------\n a      |        1\n b      |        2\n c      |        3\n d      |        4\n e      |        5\n f      |        6\n(6 rows)\n\nThis example shows how to use a simpleWITHclause:\n\n\nCODE:\n\nWITH t AS (\n    SELECT random() as x FROM generate_series(1, 3)\n  )\nSELECT * FROM t\nUNION ALL\nSELECT * FROM t;\n         x\n--------------------\n  0.534150459803641\n  0.520092216785997\n 0.0735620250925422\n  0.534150459803641\n  0.520092216785997\n 0.0735620250925422\n\nNotice that theWITHquery was evaluated only once, so that we got two sets of the same three random values.\nThis example usesWITH RECURSIVEto find all subordinates (direct or indirect) of the employee Mary, and their level of indirectness, from a table that shows only direct subordinates:\n\n\nCODE:\n\nWITH RECURSIVE employee_recursive(distance, employee_name, manager_name) AS (\n    SELECT 1, employee_name, manager_name\n    FROM employee\n    WHERE manager_name = 'Mary'\n  UNION ALL\n    SELECT er.distance + 1, e.employee_name, e.manager_name\n    FROM employee_recursive er, employee e\n    WHERE er.employee_name = e.manager_name\n  )\nSELECT distance, employee_name FROM employee_recursive;\n\nNotice the typical form of recursive queries: an initial condition, followed byUNION, followed by the recursive part of the query. Be sure that the recursive part of the query will eventually return no tuples, or else the query will loop indefinitely. (SeeSection 7.8for more examples.)\nThis example usesLATERALto apply a set-returning functionget_product_names()for each row of themanufacturerstable:\n\n\nCODE:\n\nSELECT m.name AS mname, pname\nFROM manufacturers m, LATERAL get_product_names(m.id) pname;\n\nManufacturers not currently having any products would not appear in the result, since it is an inner join. If we wished to include the names of such manufacturers in the result, we could do:\n\n\nCODE:\n\nSELECT m.name AS mname, pname\nFROM manufacturers m LEFT JOIN LATERAL get_product_names(m.id) pname ON true;\n\n"
    },
    {
      "title": "Compatibility",
      "text": "Of course, theSELECTstatement is compatible with the SQL standard. But there are some extensions and some missing features.\n"
    },
    {
      "title": "OmittedFROMClauses",
      "text": "PostgreSQLallows one to omit theFROMclause. It has a straightforward use to compute the results of simple expressions:\n\n\nCODE:\n\nSELECT 2+2;\n\n ?column?\n----------\n        4\n\nSome otherSQLdatabases cannot do this except by introducing a dummy one-row table from which to do theSELECT.\n"
    },
    {
      "title": "EmptySELECTLists",
      "text": "The list of output expressions afterSELECTcan be empty, producing a zero-column result table. This is not valid syntax according to the SQL standard.PostgreSQLallows it to be consistent with allowing zero-column tables. However, an empty list is not allowed whenDISTINCTis used.\n"
    },
    {
      "title": "Omitting theASKey Word",
      "text": "In the SQL standard, the optional key wordAScan be omitted before an output column name whenever the new column name is a valid column name (that is, not the same as any reserved keyword).PostgreSQLis slightly more restrictive:ASis required if the new column name matches any keyword at all, reserved or not. Recommended practice is to useASor double-quote output column names, to prevent any possible conflict against future keyword additions.\nInFROMitems, both the standard andPostgreSQLallowASto be omitted before an alias that is an unreserved keyword. But this is impractical for output column names, because of syntactic ambiguities.\n"
    },
    {
      "title": "Omitting Sub-SELECTAliases inFROM",
      "text": "According to the SQL standard, a sub-SELECTin theFROMlist must have an alias. InPostgreSQL, this alias may be omitted.\n"
    },
    {
      "title": "ONLYand Inheritance",
      "text": "The SQL standard requires parentheses around the table name when writingONLY, for exampleSELECT * FROM ONLY (tab1), ONLY (tab2) WHERE ....PostgreSQLconsiders these parentheses to be optional.\nPostgreSQLallows a trailing*to be written to explicitly specify the non-ONLYbehavior of including child tables. The standard does not allow this.\n(These points apply equally to all SQL commands supporting theONLYoption.)\n"
    },
    {
      "title": "TABLESAMPLEClause Restrictions",
      "text": "TheTABLESAMPLEclause is currently accepted only on regular tables and materialized views. According to the SQL standard it should be possible to apply it to anyFROMitem.\n"
    },
    {
      "title": "Function Calls inFROM",
      "text": "PostgreSQLallows a function call to be written directly as a member of theFROMlist. In the SQL standard it would be necessary to wrap such a function call in a sub-SELECT; that is, the syntaxFROMfunc(...)aliasis approximately equivalent toFROM LATERAL (SELECTfunc(...))alias. Note thatLATERALis considered to be implicit; this is because the standard requiresLATERALsemantics for anUNNEST()item inFROM.PostgreSQLtreatsUNNEST()the same as other set-returning functions.\n"
    },
    {
      "title": "Namespace Available toGROUP BYandORDER BY",
      "text": "In the SQL-92 standard, anORDER BYclause can only use output column names or numbers, while aGROUP BYclause can only use expressions based on input column names.PostgreSQLextends each of these clauses to allow the other choice as well (but it uses the standard's interpretation if there is ambiguity).PostgreSQLalso allows both clauses to specify arbitrary expressions. Note that names appearing in an expression will always be taken as input-column names, not as output-column names.\nSQL:1999 and later use a slightly different definition which is not entirely upward compatible with SQL-92. In most cases, however,PostgreSQLwill interpret anORDER BYorGROUP BYexpression the same way SQL:1999 does.\n"
    },
    {
      "title": "Functional Dependencies",
      "text": "PostgreSQLrecognizes functional dependency (allowing columns to be omitted fromGROUP BY) only when a table's primary key is included in theGROUP BYlist. The SQL standard specifies additional conditions that should be recognized.\n"
    },
    {
      "title": "LIMITandOFFSET",
      "text": "The clausesLIMITandOFFSETarePostgreSQL-specific syntax, also used byMySQL. The SQL:2008 standard has introduced the clausesOFFSET ... FETCH {FIRST|NEXT} ...for the same functionality, as shown above inLIMIT Clause. This syntax is also used byIBM DB2. (Applications written forOraclefrequently use a workaround involving the automatically generatedrownumcolumn, which is not available in PostgreSQL, to implement the effects of these clauses.)\n"
    },
    {
      "title": "FOR NO KEY UPDATE,FOR UPDATE,FOR SHARE,FOR KEY SHARE",
      "text": "AlthoughFOR UPDATEappears in the SQL standard, the standard allows it only as an option ofDECLARE CURSOR.PostgreSQLallows it in anySELECTquery as well as in sub-SELECTs, but this is an extension. TheFOR NO KEY UPDATE,FOR SHAREandFOR KEY SHAREvariants, as well as theNOWAITandSKIP LOCKEDoptions, do not appear in the standard.\n"
    },
    {
      "title": "Data-Modifying Statements inWITH",
      "text": "PostgreSQLallowsINSERT,UPDATE, andDELETEto be used asWITHqueries. This is not found in the SQL standard.\n"
    },
    {
      "title": "Nonstandard Clauses",
      "text": "DISTINCT ON ( ... )is an extension of the SQL standard.\nROWS FROM( ... )is an extension of the SQL standard.\nTheMATERIALIZEDandNOT MATERIALIZEDoptions ofWITHare extensions of the SQL standard.\n"
    }
  ]
}